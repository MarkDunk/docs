{
    "docs": [
        {
            "location": "/", 
            "text": "WARG Docs\n\n\nThe official source of all your WARG needs. Joking, there's only documentation and GIFs here. Enjoy!\n\n\n\n\n\n\n\nCompetition\n\n\n\n\nUAS 2017 Competition Homepage\n\n\nCompetition Canops\n\n\n\n\nBootcamps\n\n\n\n\nMechanical Bootcamp\n\n\nElectrical Bootcamp\n\n\nGroundstation Bootcamp\n\n\nComputer Vision Bootcamp\n\n\nEmbedded Software Bootcamp\n\n\n\n\nProjects Documentation\n\n\n\n\nPicPilot Documentation\n\n\nGroundstation Documentation\n\n\nComputer Vision Documentation\n\n\nMechanical Documentation\n\n\n\n\nTutorials\n\n\n\n\nGit Tutorial\n\n\nCommand Line Tutorial\n\n\n\n\nAPI Documentation\n\n\n\n\nComputer Vision API Docs\n\n\nGround Station API Docs", 
            "title": "Home"
        }, 
        {
            "location": "/#warg-docs", 
            "text": "The official source of all your WARG needs. Joking, there's only documentation and GIFs here. Enjoy!", 
            "title": "WARG Docs"
        }, 
        {
            "location": "/#competition", 
            "text": "UAS 2017 Competition Homepage  Competition Canops", 
            "title": "Competition"
        }, 
        {
            "location": "/#bootcamps", 
            "text": "Mechanical Bootcamp  Electrical Bootcamp  Groundstation Bootcamp  Computer Vision Bootcamp  Embedded Software Bootcamp", 
            "title": "Bootcamps"
        }, 
        {
            "location": "/#projects-documentation", 
            "text": "PicPilot Documentation  Groundstation Documentation  Computer Vision Documentation  Mechanical Documentation", 
            "title": "Projects Documentation"
        }, 
        {
            "location": "/#tutorials", 
            "text": "Git Tutorial  Command Line Tutorial", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#api-documentation", 
            "text": "Computer Vision API Docs  Ground Station API Docs", 
            "title": "API Documentation"
        }, 
        {
            "location": "/bootcamp/mechanical/", 
            "text": "WARG Mechanical Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nMake justified mechanical design decisions based on project constraints and criteria\n\n\nLearn to take accurate measurements of parts using vernier callipers\n\n\nLearn CAD design in SolidWorks\n\n\nLearn how to make assemblies in SolidWorks\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Two-Axis Camera Gimbal:\n\n\nBackground\n\n\nA camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.\n\n\nTask\n\n\nYou are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of \nmm and g\n. If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed \npart files and assembly file\n to a Team Lead for evaluation.\n\n\nProject Checklist\n\n\n\n\nParts made in SolidWorks using dimensions of mm and g\n\n\nGoPro Case measured with power button exposed\n\n\nMounting method using 4 M4 bolts to the flat board\n\n\nMotors / Servos selected and modeled (if required)\n\n\nAssembly created with the gimbal able to rotate 360 degrees in both axis\n\n\n\n\nUsing Solidworks\n\n\nThere are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Mechanical"
        }, 
        {
            "location": "/bootcamp/mechanical/#warg-mechanical-bootcamp", 
            "text": "", 
            "title": "WARG Mechanical Bootcamp"
        }, 
        {
            "location": "/bootcamp/mechanical/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/mechanical/#bootcamp-objectives", 
            "text": "Make justified mechanical design decisions based on project constraints and criteria  Learn to take accurate measurements of parts using vernier callipers  Learn CAD design in SolidWorks  Learn how to make assemblies in SolidWorks", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/mechanical/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/mechanical/#1-two-axis-camera-gimbal", 
            "text": "", 
            "title": "1. Two-Axis Camera Gimbal:"
        }, 
        {
            "location": "/bootcamp/mechanical/#background", 
            "text": "A camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/mechanical/#task", 
            "text": "You are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of  mm and g . If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed  part files and assembly file  to a Team Lead for evaluation.", 
            "title": "Task"
        }, 
        {
            "location": "/bootcamp/mechanical/#project-checklist", 
            "text": "Parts made in SolidWorks using dimensions of mm and g  GoPro Case measured with power button exposed  Mounting method using 4 M4 bolts to the flat board  Motors / Servos selected and modeled (if required)  Assembly created with the gimbal able to rotate 360 degrees in both axis", 
            "title": "Project Checklist"
        }, 
        {
            "location": "/bootcamp/mechanical/#using-solidworks", 
            "text": "There are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.", 
            "title": "Using Solidworks"
        }, 
        {
            "location": "/bootcamp/mechanical/#2-previous-team-contribution", 
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/mechanical/#completion-of-bootcamp", 
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/bootcamp/computer-vision/", 
            "text": "Computer-Vision Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve and to familiarize you with our system and conventions. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with the main software project! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\n1. Fork and Setup Local Project\n\n\nForks can be created using the fork button in the top right of the Github Interface (you need to be signed into a Github account).\n\n\nClone your fork with either:\n\n\ngit clone git@github.com:YOUR_USERNAME_HERE/computer-vision-bootcamp.git\n\n\n\n\nif you want to use ssh\nor\n\n\ngit clone https://github.com/YOUR_USERNAME_HERE/computer-vision-bootcamp.git\n\n\n\n\nfor https\n\n\nNote that you will need to have CMake installed so that you can build your module once you've written it.\n\n\n2. Code\n\n\nYour task is to implement \nmerge sort\n (or indeed a different sorting algorithm if you wish).\n\n\nYour code must be implemented in a module (see the included core module for an example) and must:\n\n\n\n\nFollow our \nstyle guide\n\n\nBuild using CMake\n\n\nBe well documented using doxygen-formatted comments\n\n\nBe tested using \nBoost Test\n\n\n\n\nSee \ncontributing\n for an example and more information.\n\n\nYou are also welcome to implement something different if you want, but please run your idea by a computer-vision lead first.\n\n\n3. Submit\n\n\nTo submit your bootcamp project you should create a pull request. Note that this does not mean you are done, we will review your pull request and give you feedback and you will be expected to update it so that if meets all requirements.\n\n\nOnce your pull request has been merged you are ready to work on the Computer Vision project.", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/bootcamp/computer-vision/#computer-vision-bootcamp", 
            "text": "", 
            "title": "Computer-Vision Bootcamp"
        }, 
        {
            "location": "/bootcamp/computer-vision/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve and to familiarize you with our system and conventions. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with the main software project! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/computer-vision/#1-fork-and-setup-local-project", 
            "text": "Forks can be created using the fork button in the top right of the Github Interface (you need to be signed into a Github account).  Clone your fork with either:  git clone git@github.com:YOUR_USERNAME_HERE/computer-vision-bootcamp.git  if you want to use ssh\nor  git clone https://github.com/YOUR_USERNAME_HERE/computer-vision-bootcamp.git  for https  Note that you will need to have CMake installed so that you can build your module once you've written it.", 
            "title": "1. Fork and Setup Local Project"
        }, 
        {
            "location": "/bootcamp/computer-vision/#2-code", 
            "text": "Your task is to implement  merge sort  (or indeed a different sorting algorithm if you wish).  Your code must be implemented in a module (see the included core module for an example) and must:   Follow our  style guide  Build using CMake  Be well documented using doxygen-formatted comments  Be tested using  Boost Test   See  contributing  for an example and more information.  You are also welcome to implement something different if you want, but please run your idea by a computer-vision lead first.", 
            "title": "2. Code"
        }, 
        {
            "location": "/bootcamp/computer-vision/#3-submit", 
            "text": "To submit your bootcamp project you should create a pull request. Note that this does not mean you are done, we will review your pull request and give you feedback and you will be expected to update it so that if meets all requirements.  Once your pull request has been merged you are ready to work on the Computer Vision project.", 
            "title": "3. Submit"
        }, 
        {
            "location": "/bootcamp/electrical/", 
            "text": "\ufeff\n\n\nWARG Electrical Bootcamp\n\n\nIntroduction\n\n\nWelcome to the WARG's electrical bootcamp!\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\nIn this bootcamp you will learn how to do the following in KiCad:\n\n\n\n\nSearch digikey and select a component\n\n\nManage bill of materials (BOM) and the WARG component library\n\n\nMake a symbol or find symbol libraries\n\n\nEdit a schematic\n\n\nFind a footprint and map it to the part\n\n\nPlace and route a PCB\n\n\nExport gerbers\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. ZeroPilot DC/DC Buck Regulator\n\n\nBackground\n\n\nIn 2017 WARG started work on the new autopilot PCB, called ZeroPilot. With the new board comes a lot of tasks involving designing new circuits, converting circuits from Diptrace (our old software) to KiCad, and fixing bugs in various circuits. ZeroPilot is based off of STM microprocessors. It has a main processor called the autopilot controller which is a Cortex-M7 processor which handles most of our calculations. The board also has a secondary processor as a failsafe, which is called the safety controller. It allows us to confidently test new autopilot code since we can always switch into safety mode if there is an autopilot software error.\n\n\nThe ZeroPilot requires multiple voltages to power its various systems. There is the main battery which ranges from 7V-16V, and it has to be converted into 5V and 3.3V for different circuits.\n\n\nTask\n\n\nYour task is to replace the 3.3V regulator to power the main processors. Currently we use a linear regulator (commonly called an LDO) to convert 5V to 3.3V, but this is a very inefficient process, since input current = output current. Replacing the LDO with a buck regulator will save power by more efficiently converting voltage to 3.3V. It\u2019s helpful to know how buck regulators work but not required for the bootcamp\n\n\nReplace the LDO (WARG #REGU-002) with a buck regulator that you can find on digikey. The requirements for the buck regulator are listed below.\n\n\nRequirements\n\n\nBelow is a list of requirements for the buck regulator circuit:\n\n\n\n\nConvert Battery voltage (7V-16V) to 3.3V\n\n\nMust be able to supply at least 1A of current\n\n\nMust be cost effective\n\n\n\n\nSteps\n\n\nHere are the steps you are expected to take to complete this task.\n\n\n\n\n\n\nDownload and setup KiCad, Github, and the ZeroPilot repo. Fork and create a bootcamp branch of both github repos (ZeroPilot and WARG-KiCad).\n\n\n\n\n\n\nOpen the circuit editor and anaylze the current circuit. Identify the 3.3V regulator.\n\n\n\n\n\n\nFind a replacement buck regulator that meets the requirements above. Highly recommend using digikey to find the part.\n\n\n\n\n\n\nAdd the part to the compoent_library.csv in the WARG-KiCad repo and add an appropriate part number, digikey number, and other information to the csv.\n\n\n\n\n\n\nEither create or find a part symbol for the part you chose. Make sure the part is either in the default KiCad library or in WARG's symbol library (WARG-KiCad).\n\n\n\n\n\n\nRemove the 3.3V LDO from the schematic and replace it with the symbol you created. Add the necessary components (hint: there will likely be an inductor needed). Run a design rule check to make sure you don't have any errors.\n\n\n\n\n\n\nMake sure that the parameters of the parts are correct. Make sure every part has a WARG part number field.\n\n\n\n\n\n\nIf needed, create a footprint for the part. Most likely you will be able to find the footprint in KiCad's large library of footprints, but if you do have to create one make sure to save it to the WARG-KiCad repo. Map the footprint to the part you added in step 7.\n\n\n\n\n\n\nExport the netlist and import it into the PCB editor. Feel free to change the board outline to fit the bigger part, as we don't expect you to re-route the whole board to fit the component.\n\n\n\n\n\n\nAdd tracks to connect the components together. Look at the datasheet for a recommended layout pattern. Ensure that your traces are thick enough to handle the current that will be flowing through it. Also, make sure to update the copper pours to fit the new component and board outline.\n\n\n\n\n\n\nExport the gerbers into a zip file. These files are what are sent to the manufacturer to print the boards and stencils.\n\n\n\n\n\n\nSubmitting the bootcamp\n\n\nCreate a pull request (PR) to WARG github. Make sure to title your bootcamp PR in the format, \"Bootcamp: {name here}\". There should be 2 PRs, one for each repo (ZeroPilot and WARG-KiCad). The ZeroPilot PR should also include a zip file containing the manufacturing files. A team lead will review the PR within a few days and reply with approval or with some comments. The team lead will close the PR and not merge it when it is complete.\n\n\nResources\n\n\n\n\nZeroPilot repo\n\n\nKiCad library repo\n\n\nDigikey to find components\n\n\nKiCad Software\n\n\nKiCad Documentation\n\n\nKiCad getting started guide\n\n\nBootcamp channel on  \nslack\n to ask questions to team leads\n\n\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Electrical"
        }, 
        {
            "location": "/bootcamp/electrical/#warg-electrical-bootcamp", 
            "text": "", 
            "title": "WARG Electrical Bootcamp"
        }, 
        {
            "location": "/bootcamp/electrical/#introduction", 
            "text": "Welcome to the WARG's electrical bootcamp!  WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/electrical/#bootcamp-objectives", 
            "text": "In this bootcamp you will learn how to do the following in KiCad:   Search digikey and select a component  Manage bill of materials (BOM) and the WARG component library  Make a symbol or find symbol libraries  Edit a schematic  Find a footprint and map it to the part  Place and route a PCB  Export gerbers", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/electrical/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/electrical/#1-zeropilot-dcdc-buck-regulator", 
            "text": "", 
            "title": "1. ZeroPilot DC/DC Buck Regulator"
        }, 
        {
            "location": "/bootcamp/electrical/#background", 
            "text": "In 2017 WARG started work on the new autopilot PCB, called ZeroPilot. With the new board comes a lot of tasks involving designing new circuits, converting circuits from Diptrace (our old software) to KiCad, and fixing bugs in various circuits. ZeroPilot is based off of STM microprocessors. It has a main processor called the autopilot controller which is a Cortex-M7 processor which handles most of our calculations. The board also has a secondary processor as a failsafe, which is called the safety controller. It allows us to confidently test new autopilot code since we can always switch into safety mode if there is an autopilot software error.  The ZeroPilot requires multiple voltages to power its various systems. There is the main battery which ranges from 7V-16V, and it has to be converted into 5V and 3.3V for different circuits.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/electrical/#task", 
            "text": "Your task is to replace the 3.3V regulator to power the main processors. Currently we use a linear regulator (commonly called an LDO) to convert 5V to 3.3V, but this is a very inefficient process, since input current = output current. Replacing the LDO with a buck regulator will save power by more efficiently converting voltage to 3.3V. It\u2019s helpful to know how buck regulators work but not required for the bootcamp  Replace the LDO (WARG #REGU-002) with a buck regulator that you can find on digikey. The requirements for the buck regulator are listed below.", 
            "title": "Task"
        }, 
        {
            "location": "/bootcamp/electrical/#requirements", 
            "text": "Below is a list of requirements for the buck regulator circuit:   Convert Battery voltage (7V-16V) to 3.3V  Must be able to supply at least 1A of current  Must be cost effective", 
            "title": "Requirements"
        }, 
        {
            "location": "/bootcamp/electrical/#steps", 
            "text": "Here are the steps you are expected to take to complete this task.    Download and setup KiCad, Github, and the ZeroPilot repo. Fork and create a bootcamp branch of both github repos (ZeroPilot and WARG-KiCad).    Open the circuit editor and anaylze the current circuit. Identify the 3.3V regulator.    Find a replacement buck regulator that meets the requirements above. Highly recommend using digikey to find the part.    Add the part to the compoent_library.csv in the WARG-KiCad repo and add an appropriate part number, digikey number, and other information to the csv.    Either create or find a part symbol for the part you chose. Make sure the part is either in the default KiCad library or in WARG's symbol library (WARG-KiCad).    Remove the 3.3V LDO from the schematic and replace it with the symbol you created. Add the necessary components (hint: there will likely be an inductor needed). Run a design rule check to make sure you don't have any errors.    Make sure that the parameters of the parts are correct. Make sure every part has a WARG part number field.    If needed, create a footprint for the part. Most likely you will be able to find the footprint in KiCad's large library of footprints, but if you do have to create one make sure to save it to the WARG-KiCad repo. Map the footprint to the part you added in step 7.    Export the netlist and import it into the PCB editor. Feel free to change the board outline to fit the bigger part, as we don't expect you to re-route the whole board to fit the component.    Add tracks to connect the components together. Look at the datasheet for a recommended layout pattern. Ensure that your traces are thick enough to handle the current that will be flowing through it. Also, make sure to update the copper pours to fit the new component and board outline.    Export the gerbers into a zip file. These files are what are sent to the manufacturer to print the boards and stencils.", 
            "title": "Steps"
        }, 
        {
            "location": "/bootcamp/electrical/#submitting-the-bootcamp", 
            "text": "Create a pull request (PR) to WARG github. Make sure to title your bootcamp PR in the format, \"Bootcamp: {name here}\". There should be 2 PRs, one for each repo (ZeroPilot and WARG-KiCad). The ZeroPilot PR should also include a zip file containing the manufacturing files. A team lead will review the PR within a few days and reply with approval or with some comments. The team lead will close the PR and not merge it when it is complete.", 
            "title": "Submitting the bootcamp"
        }, 
        {
            "location": "/bootcamp/electrical/#resources", 
            "text": "ZeroPilot repo  KiCad library repo  Digikey to find components  KiCad Software  KiCad Documentation  KiCad getting started guide  Bootcamp channel on   slack  to ask questions to team leads", 
            "title": "Resources"
        }, 
        {
            "location": "/bootcamp/electrical/#2-previous-team-contribution", 
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/electrical/#completion-of-bootcamp", 
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/bootcamp/groundstation/", 
            "text": "WARG Groundstation Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nBecome familiar with the Groundstation's underlying architecture\n\n\nLearn Javascript, Node.js,and NW.js\n\n\nGain a general understanding of web development\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Add an altitude dial to the groundstation:\n\n\nBackground\n\n\nThe groundstation receives telemetry data from the plane in real time. To do this, is creates a socket connection to the data relay\nstation, and listens to any data it sends. The point of the groundstation is to allow the ground control team to view the aircraft's\ncurrent position and orientation in real time, all the time. Raw data is hard to follow and track, and some forms of data are better\nrepresented visually.\n\n\nTask\n\n\nYou are tasked creating an altitude dial for the groundstation. This will involve adding a menu item to the application, which in turn\nwill open up a window that displays 2 things:\n\n\n\n\nThe text value of the altitude in meters (ie. 85.63m)\n\n\nA rectangular dial that changes its height based on the altitude of the aircraft\n\n\n\n\nRequirements\n\n\n\n\nThe rectangular dial's maximum height will correspond to the maximum height of the aircraft during the flight\n\n\nThe rectangular dial's color will change from red, to yellow, to green. These will be at 33% intervals of the maximum height. \nSo if for example, throughout the flight, the maximum height of the aircraft was 100m, then if the current height of the aircraft\nis less than 33m, the dial would be red. If its less than 66m it would be yellow, and if its greater it would be green.\n\n\nA maximum of 2 decimal places should be shown in the text of the altitude\n\n\n\n\nChecklist\n\n\n\n\nThere is new menu item under the ground station's Window menu\n\n\nThe menu item opens up a new window, that uses a custom view to display the aircraft's altitude\n\n\nThere is a sensible amount of comments in the code\n\n\nAny custom functions and modules were documented using JSDOC syntax. Read \nhere\n for more info.\n\n\n\n\nNote: It is \nHIGHLY\n reccommended that you read the \ngroundstation tutorial\n.\n\n\nHints\n\n\n\n\nThe \nTelemetryData\n module is the module responsible for sending out telemetry data about the plane\n\n\nThe datalink documentation (the data the groundstation received) can be found \nhere\n\n\nThe \nAltitudeView.js\n file is the view responbile for displaying the circular altitude dial in the groundstation. Its a very good\nreference\n\n\nThe groundstation does nothing until it starts receiving data. To have it receive data, open up the Simulation window and start a simulation\n\n\nWhen you an element under the \nui\n property of the view, \nthis.ui.element_name\n is a jquery wrapper for that element, \nso you can use jquery methods on it to manipulate it (say for example changing its color or height)\n\n\nAdditional resources on the groundstation, including its documentation can be found \nhere\n\n\n\n\nNOTE:\n Don't worry if you're unfamiliar with javascript or if these hints made no sense to you. If you read the \ngroundstation documentation\n and just dive right in, you'll get the hang of it eventually.\n\n\nGit\n\n\nWe suggest making a seperate branch on git to do your bootcamp. Making a pull request is not necessary after the completion of your bootcamp, simply show your work the responsible team lead.\n\n\nExample:\n\n\n\n\n2. Previous Team Contribution\n\n\nIf you have worked on the Groundstation before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the groundstation. If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Groundstation"
        }, 
        {
            "location": "/bootcamp/groundstation/#warg-groundstation-bootcamp", 
            "text": "", 
            "title": "WARG Groundstation Bootcamp"
        }, 
        {
            "location": "/bootcamp/groundstation/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/groundstation/#bootcamp-objectives", 
            "text": "Become familiar with the Groundstation's underlying architecture  Learn Javascript, Node.js,and NW.js  Gain a general understanding of web development", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/groundstation/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/groundstation/#1-add-an-altitude-dial-to-the-groundstation", 
            "text": "", 
            "title": "1. Add an altitude dial to the groundstation:"
        }, 
        {
            "location": "/bootcamp/groundstation/#background", 
            "text": "The groundstation receives telemetry data from the plane in real time. To do this, is creates a socket connection to the data relay\nstation, and listens to any data it sends. The point of the groundstation is to allow the ground control team to view the aircraft's\ncurrent position and orientation in real time, all the time. Raw data is hard to follow and track, and some forms of data are better\nrepresented visually.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/groundstation/#task", 
            "text": "You are tasked creating an altitude dial for the groundstation. This will involve adding a menu item to the application, which in turn\nwill open up a window that displays 2 things:   The text value of the altitude in meters (ie. 85.63m)  A rectangular dial that changes its height based on the altitude of the aircraft", 
            "title": "Task"
        }, 
        {
            "location": "/bootcamp/groundstation/#requirements", 
            "text": "The rectangular dial's maximum height will correspond to the maximum height of the aircraft during the flight  The rectangular dial's color will change from red, to yellow, to green. These will be at 33% intervals of the maximum height. \nSo if for example, throughout the flight, the maximum height of the aircraft was 100m, then if the current height of the aircraft\nis less than 33m, the dial would be red. If its less than 66m it would be yellow, and if its greater it would be green.  A maximum of 2 decimal places should be shown in the text of the altitude", 
            "title": "Requirements"
        }, 
        {
            "location": "/bootcamp/groundstation/#checklist", 
            "text": "There is new menu item under the ground station's Window menu  The menu item opens up a new window, that uses a custom view to display the aircraft's altitude  There is a sensible amount of comments in the code  Any custom functions and modules were documented using JSDOC syntax. Read  here  for more info.   Note: It is  HIGHLY  reccommended that you read the  groundstation tutorial .", 
            "title": "Checklist"
        }, 
        {
            "location": "/bootcamp/groundstation/#hints", 
            "text": "The  TelemetryData  module is the module responsible for sending out telemetry data about the plane  The datalink documentation (the data the groundstation received) can be found  here  The  AltitudeView.js  file is the view responbile for displaying the circular altitude dial in the groundstation. Its a very good\nreference  The groundstation does nothing until it starts receiving data. To have it receive data, open up the Simulation window and start a simulation  When you an element under the  ui  property of the view,  this.ui.element_name  is a jquery wrapper for that element, \nso you can use jquery methods on it to manipulate it (say for example changing its color or height)  Additional resources on the groundstation, including its documentation can be found  here   NOTE:  Don't worry if you're unfamiliar with javascript or if these hints made no sense to you. If you read the  groundstation documentation  and just dive right in, you'll get the hang of it eventually.", 
            "title": "Hints"
        }, 
        {
            "location": "/bootcamp/groundstation/#git", 
            "text": "We suggest making a seperate branch on git to do your bootcamp. Making a pull request is not necessary after the completion of your bootcamp, simply show your work the responsible team lead.", 
            "title": "Git"
        }, 
        {
            "location": "/bootcamp/groundstation/#example", 
            "text": "", 
            "title": "Example:"
        }, 
        {
            "location": "/bootcamp/groundstation/#2-previous-team-contribution", 
            "text": "If you have worked on the Groundstation before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/groundstation/#completion-of-bootcamp", 
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the groundstation. If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/bootcamp/embedded/", 
            "text": "WARG Embedded Software Bootcamp\n\n\nIntroduction\n\n\nWelcome to the Embedded Software Bootcamp!\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nLearn C, and become familiar with some of the concepts in embedded programming\n\n\nLearn the underlying PicPilot(autopilot) code structure\n\n\nLearn how to track code revisions and perform code reviews via Git\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\nNote\n: \nThis will vary depending on your expirience level in programming. This is a rough estimate and don't get discouraged if it takes you longer!\n\n\n1. Add a drop and snap command to the picpilot:\n\n\nBackground\n\n\nThe groundstation is the main line of communication between the aircraft and the ground control crew. Even though the aircraft is completely autonomous, someone's got to tell it what to do and where to go.\n\n\nThe aircraft's autopilot (called the PicPilot) is what manages the communication to the groundstation from the aircraft. The groundstation communicates with the plane by sending it integer-based commmands, through the XBee data link. The autopilot interprets the command, and can choose to perform a certain action in response.\n\n\nThe aircraft is also equipped with 2 modules for the purposes of the competition. A go pro camera attached the front of the aircraft for taking aerial photos, and a probe drop module that's capable of dropping its payload.\n\n\nTask\n\n\nThe groundstation operator has to be able to send a command to drop the probe, which involves actuating a servo using PWM. There are 3 probe drops, so you will have to write some code to manage the 3 separate servos.\n\n\nThe command will be a multi-part command. The first part will tell the autopilot which servo to operate (1,2, or 3), and the second part will tell the autopilot what position the servo should be in (opened or closed). All servos should be closed on startup.\n\n\nYou are tasked with implementing this feature for the autopilot.\n\n\nHints\n\n\n\n\nBecause of resource constraints, you will not have the ability to actually test the code. Just make sure it compiles\n\n\nUse the PWM.c file to actuate the servo. Set reasonable constants for minimum and maximum PWM for the probe drop servo.\n\n\nMake sure you use a PWM channel that is currently not in use, and make sure to initialize it when the vehicle arms.\n\n\nYou can name the command whatever you want, but it has to be sensible and match the already existing command naming convention\n\n\nFeel free to use the existing code as reference\n\n\nThe datalink documentation (the data the groundstation received) can be found \nhere\n\n\n\n\nGit\n\n\nThe code for the picpilot is hosted on \nGithub\n. You will have to fork the repository to make your changes. Also its recommended that you make your own branch. If you don't know what git or github is, or how to use it, please read this \ngit and github tutorial\n that we wrote.\n\n\nSubmission\n\n\nTo submit your work, create a pull request of your fork against the main PicPilot repository. Name your pull request \nBootcamp by YOURNAME\n. Tell the responsible team lead that you've completed the bootcamp and they will review your submission. You may be asked to revise some things.\n\n\nNote\n: \nIf you would really like to test out the code, come to one of the work days and we'll show  you how to program the picpilot and actually test it out\n\n\nAdditional Resources\n\n\n\n\nYour most valuable resource will be our \npicpilot documentation\n\n\nOur Git Tutorial\n\n\nDatalink Documentation\n\n\nSparkfun Embedded Electronics Tutorial\n\n\n\n\n2. Previous Team Contribution\n\n\nIf you have worked on the PicPilot before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the picpilot! If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Embedded Software"
        }, 
        {
            "location": "/bootcamp/embedded/#warg-embedded-software-bootcamp", 
            "text": "", 
            "title": "WARG Embedded Software Bootcamp"
        }, 
        {
            "location": "/bootcamp/embedded/#introduction", 
            "text": "Welcome to the Embedded Software Bootcamp!  WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/embedded/#bootcamp-objectives", 
            "text": "Learn C, and become familiar with some of the concepts in embedded programming  Learn the underlying PicPilot(autopilot) code structure  Learn how to track code revisions and perform code reviews via Git", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/embedded/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.  Note :  This will vary depending on your expirience level in programming. This is a rough estimate and don't get discouraged if it takes you longer!", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/embedded/#1-add-a-drop-and-snap-command-to-the-picpilot", 
            "text": "", 
            "title": "1. Add a drop and snap command to the picpilot:"
        }, 
        {
            "location": "/bootcamp/embedded/#background", 
            "text": "The groundstation is the main line of communication between the aircraft and the ground control crew. Even though the aircraft is completely autonomous, someone's got to tell it what to do and where to go.  The aircraft's autopilot (called the PicPilot) is what manages the communication to the groundstation from the aircraft. The groundstation communicates with the plane by sending it integer-based commmands, through the XBee data link. The autopilot interprets the command, and can choose to perform a certain action in response.  The aircraft is also equipped with 2 modules for the purposes of the competition. A go pro camera attached the front of the aircraft for taking aerial photos, and a probe drop module that's capable of dropping its payload.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/embedded/#task", 
            "text": "The groundstation operator has to be able to send a command to drop the probe, which involves actuating a servo using PWM. There are 3 probe drops, so you will have to write some code to manage the 3 separate servos.  The command will be a multi-part command. The first part will tell the autopilot which servo to operate (1,2, or 3), and the second part will tell the autopilot what position the servo should be in (opened or closed). All servos should be closed on startup.  You are tasked with implementing this feature for the autopilot.", 
            "title": "Task"
        }, 
        {
            "location": "/bootcamp/embedded/#hints", 
            "text": "Because of resource constraints, you will not have the ability to actually test the code. Just make sure it compiles  Use the PWM.c file to actuate the servo. Set reasonable constants for minimum and maximum PWM for the probe drop servo.  Make sure you use a PWM channel that is currently not in use, and make sure to initialize it when the vehicle arms.  You can name the command whatever you want, but it has to be sensible and match the already existing command naming convention  Feel free to use the existing code as reference  The datalink documentation (the data the groundstation received) can be found  here", 
            "title": "Hints"
        }, 
        {
            "location": "/bootcamp/embedded/#git", 
            "text": "The code for the picpilot is hosted on  Github . You will have to fork the repository to make your changes. Also its recommended that you make your own branch. If you don't know what git or github is, or how to use it, please read this  git and github tutorial  that we wrote.", 
            "title": "Git"
        }, 
        {
            "location": "/bootcamp/embedded/#submission", 
            "text": "To submit your work, create a pull request of your fork against the main PicPilot repository. Name your pull request  Bootcamp by YOURNAME . Tell the responsible team lead that you've completed the bootcamp and they will review your submission. You may be asked to revise some things.  Note :  If you would really like to test out the code, come to one of the work days and we'll show  you how to program the picpilot and actually test it out", 
            "title": "Submission"
        }, 
        {
            "location": "/bootcamp/embedded/#additional-resources", 
            "text": "Your most valuable resource will be our  picpilot documentation  Our Git Tutorial  Datalink Documentation  Sparkfun Embedded Electronics Tutorial", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/bootcamp/embedded/#2-previous-team-contribution", 
            "text": "If you have worked on the PicPilot before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/embedded/#completion-of-bootcamp", 
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the picpilot! If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/bootcamp/rccompetition/", 
            "text": "RC Car Competition\n\n\nDesigned by Students, For Students\n\n\n\n\nCompetition Sign Up Deadline\n : Continuous\u2026. Come Join!\n\n\nCompetition Showcase Date:\n Saturday March 21\n\n\nst\n\n\n2014 (Tentative)\n\n\nThe Waterloo Aerial Robotics Group \u2013 RC Car Competition\n\n\nBackground\n\n\nThe goal of the RC Car competition is to motivate potential recruits to participate in the normal activities of the Waterloo Aerial Robotics Group (WARG). The team leads of WARG have come to realize that it can be difficult for recruits to immediately jump into the day-to-day activities of WARG without having any prior knowledge or experience with the technology. It's a very common occurrence for new recruits to come to the team with very little to no knowledge of the skills needed to immediately contribute, but WARG has a fundamental goal of teaching any student the skills, if they wish to learn.\n\n\nThis competition has been developed by WARG as a tool to teach students about the following:\n\n\n\n\n\uf0b7\uf0b7Basic Programming Skills\n\n\n\uf0b7\uf0b7Control Theory\n\n\n\uf0b7\uf0b7Problem Solving\n\n\n\uf0b7\uf0b7Gain Tuning (Stabilizing a Controlled System)\n\n\n\uf0b7\uf0b7Path Following and Path Planning\n\n\n\n\nAt the end of the competition, it is WARG's goal that each participating student has learned how to perform a majority of the topics listed above. The competition has been designed to guide the recruits through the process, and for this reason, each phase of the competition relies on the previous phase to a certain extent. In other words, as the recruit proceeds through each phase of the competition, they are in fact building further upon their control program. Once the last phase is reached, the recruit should have a fully functional control program. How well this program functions will be based on the recruits time, effort, and general understanding of the skills WARG is trying to teach over the course of the competition.\n\n\nFurthermore, the skills that students develop while participating in this competition can be immediately transferred to the normal activities of WARG. As well, these newly acquired skills can be advertised by the students during interviews, where they can inform the employer on what they've accomplished while participating in the competition.\n\n\nThe end goal of the competition is to develop a program that will make the RC Car autonomously follow a predetermined path. This is in fact exactly what is done by our airplane (SPIKE) in order to complete its competition. Our aircraft can always be improved upon, and it is our hope that students become interested in assisting the team with the skills they acquire through this competition.\n\n\nRegistration Fee\n\n\n*** There will be a $5 fee in order to sign up for the competition, but the amount of money gathered by WARG will simply be put back to the participating students registered in the competition. To be an \"official\" member of WARG, the constitution of the team states that each member must pay an initial $5 fee. In order to incorporate this fee, as well as make the competition day a little more enticing, WARG is using this collection for the sole purpose of buying items such as pizza, pop, snacks, etc. for the final Competition Showcase Day.\n\n\nThe Competition\n\n\nIn teams of 3 or 4 (ideally), students will compete to control a remote control (RC) car that has been outfitted by WARG to have autonomous capabilities. Each team will be competing against the others for a prize pool (prizes to be determined and announced based on participation), where the top 3 teams will be rewarded respectively.\n\n\n* Note that individual sign up is more than welcome, and teams of individuals will be generated\n\n\nThe competition will be graded as follows:\n\n\n\n\n\n\n\n\nPhase\n\n\nTask\n\n\nSkills Acquired\n\n\nWeighting\n\n\n\n\n\n\n\n\n\n\nl\n\n\n-Drive Forward 10sec-Drive Backward 10sec-Turn Right 10sec-Turn Left 10sec\n\n\nCan you \ncall\n a function?Can you make a loop?\n\n\n2.5% each(10% total)\n\n\n\n\n\n\nll\n\n\n-Drive Forward 10m-Drive Backward 10m\n\n\nCan you \nmake\n a function?\n\n\n5% each(10% total)\n\n\n\n\n\n\nlll\n\n\n-Drive Forward 5m,   then Turn Right 90 degrees   then Turn Left 90 degrees\n\n\nCan you think in terms of Heading?\n\n\n15%\n\n\n\n\n\n\nlV\n\n\n-Drive a Straight Line   while Maintaining Heading   Stop after _(100)_m\n\n\nCan you put everything together and create a Control Program?\n\n\n15%\n\n\n\n\n\n\nV\n\n\n-Drive from Point A to Point B   Stop within a _(5)_m Radius\n\n\n15%\n\n\n\n\n\n\n\n\nVl\n\n\nFollow _(10)_ Waypoints\n\n\n35%\n\n\n\n\n\n\n\n\n\n\nNotes:\n\n\n\n\n--Basic programming concepts will be explained to new recruits in order to help them succeed\n\n\n--Values given in the _(Value)_ form are tentative and subject to change\n\n\n--Phases 1 and 3: marks are awarded based on performance of the described task, not preciseness to the defined values (i.e. if you turn further than 90deg we will not punish you, but you must turn at least 90deg)\n\n\n--Phases 2, 4, 5, 6, 7, 8: will be marked based on your team's error, relative to the other teams\n\n\n--The system has been set up to relay GPS information back to WARG, we will use this information to determine your error in accordance to the given task. This eliminates discrepancy with regards to GPS drift (i.e. if we were to mark a GPS coordinate on the ground and say \"go here,\" the GPS may think that spot is in two different locations based on the number of satellites it has at that given time)\n\n\n\n\nTerminology:\n\n\n\n\n--Heading: a 360 degree value of the direction to North (basically like a compass with N = 0deg and 360deg, E = 90deg, S = 180deg, and W = 270deg)\n\n\n--Waypoint: a GPS coordinate described by a Latitude and a Longitude\n\n\n\n\nWhat You Need To Know\n\n\nThere are a few things you'll need to know and understand (other than basic programming concepts) in order to control the RC Car.\n\n\nWhat to Download\n\n\nWARG has created presentational step-by-step presentations to help you setup the programs needed:\n\n\nMPLAB X:  (required)\n\n\nhttps://docs.google.com/presentation/d/1XvRea8qPeCgIOqU_4q_P-z-q1EOupfJyO801Is2gDz4/edit?usp=sharing\n\n\nThis is the IDE used to program the chip on the RC Car\n\n\nGithub:\n  \n(optional)\n\n\nhttps://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing\n\n\n*Please note that the Github presenation presentation might be out of date, but the same concepts will apply in order to get it setup on your system. Contrary, you might not need to download the desktop client, and can simple get the RC-Car-Bootstrap-Competition project as a .ZIP, in which case you can place it where you want and open the Project from MPLAB.\n\n\n*If you choose to use Github, you DO NOT need a UWARG member to add you to the group. Since the project is Public, anyone can view and download the RC-Car-Bootstrap in order to start programming. See the next section for instructions on how to do so.\n\n\nWhere to Get the Code (GitHub)\n\n\nThe following link is where you can download the base project for the RC Car Competition:\n\n\nhttps://github.com/UWARG/RC-Car-Bootstrap-Competition\n\n\nOn the right side of the screen, select \"Download ZIP.\" Place the unzipped folder somewhere on your computer for you to access. Open this folder as a Project in MPLAB X, and you should be ready to start coding.\n\n\n*Note: A presentation may be created later to teach people how to use MPLAB X, but if you start typing some code and want to test that it compiles (i.e. you've created correct code), then you may press the \"Build \n Clean\" button to initially test the program. It should tell you if there are any errors with your code, or something that it doesn't understand.\n\n\nFunctionality Developed by WARG for You to Use\n\n\nWARG has developed a bunch of functions that perform hardware communication with the car. This means that the recruits do not need to understand how to truly talk to the devices, but instead can program the system at a much higher level. What this means is something similar to the following comparison. Somebody tells you to shout \"Hello!\" You don't truly think about the fact that all those fancy biology components in your body are doing things, and somehow in the end\u2026. magical noise comes from your mouth. What happened is that somebody gave you a command at a \"higher level,\" your brain then took that command and did the appropriate things without you truly knowing what's going on, in order to make \"Hello!\" come from your mouth. Might be a weird analogy yes, but that's similar to what's going on in the code.\n\n\nWARG has given you the following functions to work with. They must have the specified inputs, and they perform the specified actions:\n\n\nsetSteering(int percent);\n\n\nThis function does exactly what you think it does. It takes an int value input ranging from -100 to 100.    With -100 turning the wheels fully to the left, and 100 turning the wheels fully to the right.\n\n\nsetThrottle(int percent);\n\n\nThis function does exactly what you think it does. It takes an int value input ranging from -100 to 100. With -100 being full speed in reverse, and 100 being full speed forward.\n\n\ngetTime();\n\n\nThis function returns the time in milliseconds as type \nlong int\n, the function takes no inputs.\n\n\nYou are also given a struct to work with that holds and updates all of the appropriate GPS Data. In order to access this information, simply type \"GPS.______\" where the ____ is filled appropriately as follows:\n\n\nGPS.latitude;     // the current latitude as type \nlong double\n\n\nGPS.longitude;     // the current latitude as type \nlong double\n\n\nGPS.speed;           // the current ground speed as type \nfloat\n\n\nGPS.heading;       // the current heading as type \nint\n\n\nGPS.satellites;     // the current number of satellites as type \nchar\n\n\nGPS.positionFix;  // if there is a position fix or not as type \nchar\n\n\nGPS.altitude;        // the current altitude as type \nint\n\n\nWhere You Program in the Code\n\n\nWhen you download all of the required programs, and get the RC-Car-Bootstrap from Github, you will see the following code segment in the main.c file.\n\n\n\n\nYou will notice that there is already some code in the main body\u2026. YOU MUST LEAVE THIS THERE.\n\n\nThe code that exists is there to initialize the system and ensure it is running properly. As well, it performs all of our background tasks that send data do us about what your system is doing at the moment. All of your code must take place after \"setSteering(0);\" and before \"background();.\" Please note that this is meant by your code in the main function of your program, later on in the phases, you will be required to develop your own functions, which must be developed outside of this main.\n\n\nAspects of Programming (Super Simplified)\n\n\n***WARNING: THIS SECTION IS NOT COMPLETED, AND YOU'LL NEED TO KNOW A FEW MORE THINGS THAN WHAT IS DESCRIBED HERE. FOLLOW THE PROVIDED TUTORIAL LINKS TO HELP YOU LEARN FOR THE TIME BEING.\n\n\nFor any recruit who is nervous, unsure, or thinking twice about joining the competition due to not having prior (or having minimal) knowledge of programming, WARG would like to motivate you to get past that fear. SO GET MOTIVATED!!!\n\n\nProgramming may take a little bit in order for the concepts to finally \"click,\" but once you grasp it\u2026     \u2026it all seems so simple\n\n\nYou will be programming in a language known as C. Just as there are multiple verbal languages (i.e. English, French, Spanish, etc.), there are a bunch of programming languages. These programming languages are a lot easier to transition between and pick up if you know one of the languages, in comparison to verbal languages.\n\n\nMoving on, here is a REALLY REALLY simplified generalization of some programming concepts.\n\n\nVariables\n\n\nYou can think of variables just like the ones you'd use in math, by this we mean that they can be seen as \"place holders\" for a value. Meaning that in math you may declare:\n\n\n\"Let x be the number of apples Brian has on Monday\"\n\n\nVariables in programming are similar, and are place holders for actual values. These values are hidden away and saved somewhere in the microchip (in memory\u2026. but we don't need to know about this right now). Here are a couple examples of variable \ntypes\n:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nint\n\n\nCan be thought of as a \nwhole\n number, or a number \nwithout\n decimals\n\n\n1,  16,  3054\n\n\n\n\n\n\nfloat\n\n\nCan be thought of as a number \nwith\n decimals\n\n\n1.02,  506.23579\n\n\n\n\n\n\n\n\nYou totally thought the list was going to be longer didn't you. Well, technically it is quite a bit larger yes, but in all honesty you could write the whole code for the competition using just these variables and you would be fine. With that said, you might want to utilize something known as an \nArray\n. An array can be thought of as a list of a certain type of variable. If you want to save data on a few things that may relate, or be of similar characteristic, to one another\u2026 you may want to put them into a list.\n\n\nIn order to initialize your variables in your program, you would do as such:\n\n\nint x = 0;    //This means that you've declared a new variable \"x\", that is of type int, and has starting value 0\n\n\nfloat myFloat = 2.34; //a new variable \"myFloat\", of type float, with starting value 2.34\n\n\nint myArray[5];  //Declaration of an array (un-initialized)\u2026\n\n\n\u2026This means that you've declared an array of 5 int variables (i.e. there is a list of 5 int's), you've called this array \"myArray\", and you did not initialize the values to anything\n\n\nYou would then later access individual members of the array by doing the following:\n\n\nmyArray[0] = 8; //This sets the first member in the list to hold a value of 8\n\n\nPiece of cake right? No? Well that's ok, because it took some of the Lead members of WARG a little while to truly get a grasp as well.\n\n\n*** Obviously there's more to programming then just declaring variables, and WARG is currently in the process of writing this document to better help recruits get involved! For the time being, please look at the following tutorials online regarding basic C programming. There's lots of things on the internet if you use that thing\u2026. what are the kids calling it? \"The Google?\"\n\n\nYou'll need to know about \"if\" statements, \"while\" loops, and possible \"for\" loops in order to successfully complete the phases in the competition. Here are a few useful links to help you:\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson1.html\n  -- Specifically:\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson2.html\n  // if statements\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson3.html\n  // looping\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson4.html\n  // functions\n\n\nOr more importantly for now (considering we're still developing this document), in order to be a part of any student team, you need to be able to research. Therefore the following is the most important link we can give you: \nhttp://lmgtfy.com/?q=c+tutorial\n\n\nPhase Definitions\n\n\nThis section of the document is meant to further define what is required, and expected for each Phase of the competition.\n\n\nPhase I\n\n\nPurpose:\n\n\nAllow recruits to get acquainted with a very simple program, and how the process works to program the RC Car. The recruits will need to call functions that have been premade for them, and make a simple loop.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward for 10 seconds\n\n\n\uf0b7\uf0b7Drive Backward for 10 seconds\n\n\n\uf0b7\uf0b7Turn Right for 10 seconds\n\n\n\uf0b7\uf0b7Turn Left for 10 seconds\n\n\n\n\nExplanation:\n\n\nThis phase should not require further explanation in order to get a grasp on what's required. By defining a few variables, and using the pre-made functions given to use, the recruit should be able to create a program that performs the above tasks.\n\n\nEvaluation and Weighting:  \n 10% in total for the phase\n\n\n2.5% will be given per each of the 4 tasks\n\n\nIt is simply expected that the car moves in the appropriate direction for the given time period. The car does not need to stop \"spot on\" the 10 second mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.\n\n\nPhase II\n\n\nPurpose:\n\n\nThe initial purpose of this phase is to have the recruits create a new function from scratch. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward 10 meters\n\n\n\uf0b7\uf0b7Drive Backward 10 meters\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create their own function in order to determine the distance travelled from the car's current position, to a start point (or previous waypoint).\n\n\nYour function definition should pass in latitude and longitude values of the GPS coordinates (2 sets, one for point 'A' and one for point 'B'). The following website gives you a pretty good layout of how your code should look (to some extent, it will look different due to you programming in C and not Java Script). Specifically the following code bite as well:\n\n\nhttp://www.movable-type.co.uk/scripts/latlong.html\n\n\n\n\nAbove is the formula you must program into your function.\n\n\nBelow is how the created such a function with Java Script. *** Your function should return a float of \"d\"\n\n\n\n\nvar R =6371;// km\n\n\nvar\u03c61= lat1.toRadians();\n\n\nvar\u03c62= lat2.toRadians();\n\n\nvar\u0394\u03c6=(lat2-lat1).toRadians();\n\n\nvar\u0394\u03bb=(lon2-lon1).toRadians();\n\n\nvar a =Math.sin(\u0394\u03c6/2)*Math.sin(\u0394\u03c6/2)+\n\n\n    Math.cos(\u03c61)\\*Math.cos(\u03c62)\\*\n\n    Math.sin(\u0394\u03bb/2)\\*Math.sin(\u0394\u03bb/2);\n\n\n\nvar c =2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));\n\n\nvar d = R * c;\n\n\n\n\nThe only addition you must make to this code (besides writing it correctly for your C program), is to multiple the \"c\" value above by \u00b11000. Is needed to convert kilometers into meters.\n\n\nEvaluation and Weighting:  \n 10% in total for the phase\n\n\n5% will be given per each of the 2 tasks\n\n\nInitially, it is simply expected that the car moves in the appropriate direction for the given distance. The car does not need to stop \"spot on\" the 10 meter mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.\n\n\nFurthermore, out of the 5% given towards either task, a weighting of 4% will be achieved by implementing the functionality described in the previous paragraph. The additional 1% will be achieved based on error to the 10m mark. In order to reach the 10m as close as possible, the recruit must implement proper Control Theory in order to slow the car down and receive the extra weighting. The code cannot be written to simply reverse the car for a millisecond after reaching the 10m mark, as this harms the equipment and decreases its lifespan. You may not reverse back to the 10m mark either if you have passed it. Additionally, in order to achieve this extra weighting (and so that WARG can see your control loop is working correctly), the RC Car must be started at an initial throttle of _(40)_%. The weighting will be received based on error in comparison to the top team for this phase (team closest to the 10m mark).\n\n\nPlease note that the control theory aspect will be learned in later phases of the competition. The \"closeness\" to the 10m mark is worth only 1% since it is WARG's desire that all teams initially develop the code well enough to accomplish the initial 4% of this phase for each task. If teams finish the majority of the competition, and after learning control theory, they may return back to this phase in order to try and receive the addition 1%.\n\n\nPhase III\n\n\nPurpose:\n\n\nThe initial purpose of this phase is to have the recruits begin to think in terms of heading, and how it relates to controlling the steering of the car. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward 5 meters, then\n\n\nooTurn Right 90 degrees, then\n\n\nooTurn Left 90 degrees\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create their own functionality in order to determine which direction to steer the car at any given point in time. The car may bounce around, and therefore move off of the desired path. Since we are constantly checking the state of the car (by continuously looping through the entire code), we can determine which way to steer the car at any point in time. It is recommended that this functionality be developed in the form of a function.\n\n\nAt no point during this phase should the car come to a stop while transitioning between task objectives. The desire is that the car drives a smooth path. For this reason, the car should never operate under _(20)_% throttle while transitioning between task objectives. The car may only be controlled to a complete stop once you are completed the phase in the \"Turn Left 90 degrees\" sub-task. Again, the car may never be driven backwards, and must always be moving forwards.\n\n\nEvaluation and Weighting:  \n 15% in total for the phase\n\n\n12% will be given for initially achieving the tasks above by going (at minimum) the distance or angle change that's stated.\n\n\nInitially it is WARG's desire that the recruit moves on after achieving this initial functionality, and returns back at a later time to improve upon the phase's functionality. The additional 3% will be achieved similarly to the methods described in Phase II, in the same manner that the additional 1% is achieved.\n\n\nPhase IV\n\n\nPurpose:\n\n\nThe purpose of this phase is for the recruit to put all of the functionality they've developed together, and create a simple control loop.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive a straight line\n\n\nooWhile maintaining heading\n\n\nooStop after _(100)_m\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create a control loop that will steer the car accordingly and keep it on the desired path. This involves monitoring the heading of the car, and steering the car in the appropriate direction if it starts to stray from the desired path. A heading a starting direction will be determined by WARG based on the competition testing location (the heading to hold will be hardcoded into the recruits program ahead of time, since at this point we are not expecting anything that calculates which heading should be held).\n\n\nYou will notice that if you turn the car too much in a given direction when it strays off the path, it will quickly be weaving back and forth on the path, and the amplitude of this \"weave\" will increase overtime. This is because you must \nconverge\n towards the desired path, rather than do a jerking turn that makes the car immediately be on the path. The rate at which you turn the steering, relative to your distance from the path, is controlled through the \ncontrol loop\n, and by tuning the gains appropriately to fit your system (in this case the system is the RC Car).\n\n\nPlease refer to the \nControl Theory\n section in order to gain more knowledge on how to create a control loop. As well, WARG is considering bring in lecturers in order to host short lectures / tutorials on these concepts. This will be done based on the interest of the students.\n\n\nEvaluation and Weighting:  \n 15% in total for the phase\n\n\nConsidering that we do not expect the car to stray to too far from the desired path (there are no strong winds pushing the car off its path, such as that which occurs with the airplane while in the air), we do not expect the error from the path to be very large at all. Even if the recruit poorly tuned that control loops / gains, we believe the system shouldn't have a problem staying on the desired path.\n\n\nWith this in mind, the 10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error.\n\n\nThe additional 5% of this phase will be calculated based on the recruit's error in distance travelled, in comparison to that of the top team's error. (Hint: this is a controlled stop like that described in Phase II)\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired travel distance of _(100)_m. Again, the car should always be moving forward.\n\n\nPhase V\n\n\nPurpose:\n\n\nThe purpose of this phase is for the recruit to develop dynamic functionality of their code (i.e. not hardcoded values). This phase also has the purpose of developing code that drives the car based on waypoints.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive from Point A to Point B\n\n\nooStop within a _(5)_m radius\n\n\n\n\nExplanation:\n\n\nThe functionality as described in Phase IV should be implemented in this phase in order to better complete the task described.\n\n\nYou'll need to apply some logic into your program and probably create another function to perform basic geometry. In order to find the line (and heading) you must follow, you'll have to generate a xy based system from you latitude / longitude coordinates. You can do this by specifying an anchor point (of latitude longitude, this could possibly be your position on start-up). You can then find your x component, and y component of any given waypoint by holding either your latitude / longitude constant, and sending your anchor, and new waypoint through your getDistance() function.\n\n\nOn competition day, WARG will provide the recruit with a Waypoint to travel to. The program must get its current GPS position (current waypoint), and then calculate a straight line from this current position to the desired waypoint given by WARG. This is the heading that the car must be desired to hold in order to get to the waypoint.\n\n\nWARG will start the car in the opposite (or some determined) direction relative to the goal Waypoint in order to ensure the system is calculating things appropriately.\n\n\n*Hint: The RC Car should calculated which direction to turn in order to be going the appropriate heading the fastest.\n\n\nEvaluation and Weighting:\n   15% in total for the phase\n\n\n10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.\n\n\nThe additional 5% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 5% weighting.\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.\n\n\nPhase VI\n\n\nPurpose:\n\n\nThe purpose of this phase is to combine everything that the recruit has learned in order to make the RC Car follow a dynamic path of waypoints. Two paths of _(10)_ waypoints will be given for the car to follow (the car will follow one path, and then the new waypoints will be programmed, and the second path will be followed).\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Follow a set of _(10)_ Waypoints\n\n\n\n\nExplanation:\n\n\nAt this point in time, WARG hopes that the recruit has learned enough from previous stages in order to accomplish the described task of following a set of _(10)_ waypoints.\n\n\nWaypoint 1 will be the RC Car's current position, the additional 9 waypoints will be provided.\n\n\nEvaluation and Weighting:  \n 35% in total for the phase\n\n\n34% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.\n\n\nThe additional 1% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the final waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 1% weighting.\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.", 
            "title": "RC Car Competition"
        }, 
        {
            "location": "/bootcamp/rccompetition/#rc-car-competition", 
            "text": "", 
            "title": "RC Car Competition"
        }, 
        {
            "location": "/bootcamp/rccompetition/#designed-by-students-for-students", 
            "text": "Competition Sign Up Deadline  : Continuous\u2026. Come Join!  Competition Showcase Date:  Saturday March 21", 
            "title": "Designed by Students, For Students"
        }, 
        {
            "location": "/bootcamp/rccompetition/#st", 
            "text": "2014 (Tentative)  The Waterloo Aerial Robotics Group \u2013 RC Car Competition", 
            "title": "st"
        }, 
        {
            "location": "/bootcamp/rccompetition/#background", 
            "text": "The goal of the RC Car competition is to motivate potential recruits to participate in the normal activities of the Waterloo Aerial Robotics Group (WARG). The team leads of WARG have come to realize that it can be difficult for recruits to immediately jump into the day-to-day activities of WARG without having any prior knowledge or experience with the technology. It's a very common occurrence for new recruits to come to the team with very little to no knowledge of the skills needed to immediately contribute, but WARG has a fundamental goal of teaching any student the skills, if they wish to learn.  This competition has been developed by WARG as a tool to teach students about the following:   \uf0b7\uf0b7Basic Programming Skills  \uf0b7\uf0b7Control Theory  \uf0b7\uf0b7Problem Solving  \uf0b7\uf0b7Gain Tuning (Stabilizing a Controlled System)  \uf0b7\uf0b7Path Following and Path Planning   At the end of the competition, it is WARG's goal that each participating student has learned how to perform a majority of the topics listed above. The competition has been designed to guide the recruits through the process, and for this reason, each phase of the competition relies on the previous phase to a certain extent. In other words, as the recruit proceeds through each phase of the competition, they are in fact building further upon their control program. Once the last phase is reached, the recruit should have a fully functional control program. How well this program functions will be based on the recruits time, effort, and general understanding of the skills WARG is trying to teach over the course of the competition.  Furthermore, the skills that students develop while participating in this competition can be immediately transferred to the normal activities of WARG. As well, these newly acquired skills can be advertised by the students during interviews, where they can inform the employer on what they've accomplished while participating in the competition.  The end goal of the competition is to develop a program that will make the RC Car autonomously follow a predetermined path. This is in fact exactly what is done by our airplane (SPIKE) in order to complete its competition. Our aircraft can always be improved upon, and it is our hope that students become interested in assisting the team with the skills they acquire through this competition.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/rccompetition/#registration-fee", 
            "text": "*** There will be a $5 fee in order to sign up for the competition, but the amount of money gathered by WARG will simply be put back to the participating students registered in the competition. To be an \"official\" member of WARG, the constitution of the team states that each member must pay an initial $5 fee. In order to incorporate this fee, as well as make the competition day a little more enticing, WARG is using this collection for the sole purpose of buying items such as pizza, pop, snacks, etc. for the final Competition Showcase Day.", 
            "title": "Registration Fee"
        }, 
        {
            "location": "/bootcamp/rccompetition/#the-competition", 
            "text": "In teams of 3 or 4 (ideally), students will compete to control a remote control (RC) car that has been outfitted by WARG to have autonomous capabilities. Each team will be competing against the others for a prize pool (prizes to be determined and announced based on participation), where the top 3 teams will be rewarded respectively.  * Note that individual sign up is more than welcome, and teams of individuals will be generated  The competition will be graded as follows:     Phase  Task  Skills Acquired  Weighting      l  -Drive Forward 10sec-Drive Backward 10sec-Turn Right 10sec-Turn Left 10sec  Can you  call  a function?Can you make a loop?  2.5% each(10% total)    ll  -Drive Forward 10m-Drive Backward 10m  Can you  make  a function?  5% each(10% total)    lll  -Drive Forward 5m,   then Turn Right 90 degrees   then Turn Left 90 degrees  Can you think in terms of Heading?  15%    lV  -Drive a Straight Line   while Maintaining Heading   Stop after _(100)_m  Can you put everything together and create a Control Program?  15%    V  -Drive from Point A to Point B   Stop within a _(5)_m Radius  15%     Vl  Follow _(10)_ Waypoints  35%      Notes:   --Basic programming concepts will be explained to new recruits in order to help them succeed  --Values given in the _(Value)_ form are tentative and subject to change  --Phases 1 and 3: marks are awarded based on performance of the described task, not preciseness to the defined values (i.e. if you turn further than 90deg we will not punish you, but you must turn at least 90deg)  --Phases 2, 4, 5, 6, 7, 8: will be marked based on your team's error, relative to the other teams  --The system has been set up to relay GPS information back to WARG, we will use this information to determine your error in accordance to the given task. This eliminates discrepancy with regards to GPS drift (i.e. if we were to mark a GPS coordinate on the ground and say \"go here,\" the GPS may think that spot is in two different locations based on the number of satellites it has at that given time)   Terminology:   --Heading: a 360 degree value of the direction to North (basically like a compass with N = 0deg and 360deg, E = 90deg, S = 180deg, and W = 270deg)  --Waypoint: a GPS coordinate described by a Latitude and a Longitude", 
            "title": "The Competition"
        }, 
        {
            "location": "/bootcamp/rccompetition/#what-you-need-to-know", 
            "text": "There are a few things you'll need to know and understand (other than basic programming concepts) in order to control the RC Car.", 
            "title": "What You Need To Know"
        }, 
        {
            "location": "/bootcamp/rccompetition/#what-to-download", 
            "text": "WARG has created presentational step-by-step presentations to help you setup the programs needed:  MPLAB X:  (required)  https://docs.google.com/presentation/d/1XvRea8qPeCgIOqU_4q_P-z-q1EOupfJyO801Is2gDz4/edit?usp=sharing  This is the IDE used to program the chip on the RC Car  Github:    (optional)  https://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing  *Please note that the Github presenation presentation might be out of date, but the same concepts will apply in order to get it setup on your system. Contrary, you might not need to download the desktop client, and can simple get the RC-Car-Bootstrap-Competition project as a .ZIP, in which case you can place it where you want and open the Project from MPLAB.  *If you choose to use Github, you DO NOT need a UWARG member to add you to the group. Since the project is Public, anyone can view and download the RC-Car-Bootstrap in order to start programming. See the next section for instructions on how to do so.", 
            "title": "What to Download"
        }, 
        {
            "location": "/bootcamp/rccompetition/#where-to-get-the-code-github", 
            "text": "The following link is where you can download the base project for the RC Car Competition:  https://github.com/UWARG/RC-Car-Bootstrap-Competition  On the right side of the screen, select \"Download ZIP.\" Place the unzipped folder somewhere on your computer for you to access. Open this folder as a Project in MPLAB X, and you should be ready to start coding.  *Note: A presentation may be created later to teach people how to use MPLAB X, but if you start typing some code and want to test that it compiles (i.e. you've created correct code), then you may press the \"Build   Clean\" button to initially test the program. It should tell you if there are any errors with your code, or something that it doesn't understand.", 
            "title": "Where to Get the Code (GitHub)"
        }, 
        {
            "location": "/bootcamp/rccompetition/#functionality-developed-by-warg-for-you-to-use", 
            "text": "WARG has developed a bunch of functions that perform hardware communication with the car. This means that the recruits do not need to understand how to truly talk to the devices, but instead can program the system at a much higher level. What this means is something similar to the following comparison. Somebody tells you to shout \"Hello!\" You don't truly think about the fact that all those fancy biology components in your body are doing things, and somehow in the end\u2026. magical noise comes from your mouth. What happened is that somebody gave you a command at a \"higher level,\" your brain then took that command and did the appropriate things without you truly knowing what's going on, in order to make \"Hello!\" come from your mouth. Might be a weird analogy yes, but that's similar to what's going on in the code.  WARG has given you the following functions to work with. They must have the specified inputs, and they perform the specified actions:  setSteering(int percent);  This function does exactly what you think it does. It takes an int value input ranging from -100 to 100.    With -100 turning the wheels fully to the left, and 100 turning the wheels fully to the right.  setThrottle(int percent);  This function does exactly what you think it does. It takes an int value input ranging from -100 to 100. With -100 being full speed in reverse, and 100 being full speed forward.  getTime();  This function returns the time in milliseconds as type  long int , the function takes no inputs.  You are also given a struct to work with that holds and updates all of the appropriate GPS Data. In order to access this information, simply type \"GPS.______\" where the ____ is filled appropriately as follows:  GPS.latitude;     // the current latitude as type  long double  GPS.longitude;     // the current latitude as type  long double  GPS.speed;           // the current ground speed as type  float  GPS.heading;       // the current heading as type  int  GPS.satellites;     // the current number of satellites as type  char  GPS.positionFix;  // if there is a position fix or not as type  char  GPS.altitude;        // the current altitude as type  int", 
            "title": "Functionality Developed by WARG for You to Use"
        }, 
        {
            "location": "/bootcamp/rccompetition/#where-you-program-in-the-code", 
            "text": "When you download all of the required programs, and get the RC-Car-Bootstrap from Github, you will see the following code segment in the main.c file.   You will notice that there is already some code in the main body\u2026. YOU MUST LEAVE THIS THERE.  The code that exists is there to initialize the system and ensure it is running properly. As well, it performs all of our background tasks that send data do us about what your system is doing at the moment. All of your code must take place after \"setSteering(0);\" and before \"background();.\" Please note that this is meant by your code in the main function of your program, later on in the phases, you will be required to develop your own functions, which must be developed outside of this main.", 
            "title": "Where You Program in the Code"
        }, 
        {
            "location": "/bootcamp/rccompetition/#aspects-of-programming-super-simplified", 
            "text": "***WARNING: THIS SECTION IS NOT COMPLETED, AND YOU'LL NEED TO KNOW A FEW MORE THINGS THAN WHAT IS DESCRIBED HERE. FOLLOW THE PROVIDED TUTORIAL LINKS TO HELP YOU LEARN FOR THE TIME BEING.  For any recruit who is nervous, unsure, or thinking twice about joining the competition due to not having prior (or having minimal) knowledge of programming, WARG would like to motivate you to get past that fear. SO GET MOTIVATED!!!  Programming may take a little bit in order for the concepts to finally \"click,\" but once you grasp it\u2026     \u2026it all seems so simple  You will be programming in a language known as C. Just as there are multiple verbal languages (i.e. English, French, Spanish, etc.), there are a bunch of programming languages. These programming languages are a lot easier to transition between and pick up if you know one of the languages, in comparison to verbal languages.  Moving on, here is a REALLY REALLY simplified generalization of some programming concepts.", 
            "title": "Aspects of Programming (Super Simplified)"
        }, 
        {
            "location": "/bootcamp/rccompetition/#variables", 
            "text": "You can think of variables just like the ones you'd use in math, by this we mean that they can be seen as \"place holders\" for a value. Meaning that in math you may declare:  \"Let x be the number of apples Brian has on Monday\"  Variables in programming are similar, and are place holders for actual values. These values are hidden away and saved somewhere in the microchip (in memory\u2026. but we don't need to know about this right now). Here are a couple examples of variable  types :     Type  Description  Example      int  Can be thought of as a  whole  number, or a number  without  decimals  1,  16,  3054    float  Can be thought of as a number  with  decimals  1.02,  506.23579     You totally thought the list was going to be longer didn't you. Well, technically it is quite a bit larger yes, but in all honesty you could write the whole code for the competition using just these variables and you would be fine. With that said, you might want to utilize something known as an  Array . An array can be thought of as a list of a certain type of variable. If you want to save data on a few things that may relate, or be of similar characteristic, to one another\u2026 you may want to put them into a list.  In order to initialize your variables in your program, you would do as such:  int x = 0;    //This means that you've declared a new variable \"x\", that is of type int, and has starting value 0  float myFloat = 2.34; //a new variable \"myFloat\", of type float, with starting value 2.34  int myArray[5];  //Declaration of an array (un-initialized)\u2026  \u2026This means that you've declared an array of 5 int variables (i.e. there is a list of 5 int's), you've called this array \"myArray\", and you did not initialize the values to anything  You would then later access individual members of the array by doing the following:  myArray[0] = 8; //This sets the first member in the list to hold a value of 8  Piece of cake right? No? Well that's ok, because it took some of the Lead members of WARG a little while to truly get a grasp as well.  *** Obviously there's more to programming then just declaring variables, and WARG is currently in the process of writing this document to better help recruits get involved! For the time being, please look at the following tutorials online regarding basic C programming. There's lots of things on the internet if you use that thing\u2026. what are the kids calling it? \"The Google?\"  You'll need to know about \"if\" statements, \"while\" loops, and possible \"for\" loops in order to successfully complete the phases in the competition. Here are a few useful links to help you:  http://www.cprogramming.com/tutorial/c/lesson1.html   -- Specifically:  http://www.cprogramming.com/tutorial/c/lesson2.html   // if statements  http://www.cprogramming.com/tutorial/c/lesson3.html   // looping  http://www.cprogramming.com/tutorial/c/lesson4.html   // functions  Or more importantly for now (considering we're still developing this document), in order to be a part of any student team, you need to be able to research. Therefore the following is the most important link we can give you:  http://lmgtfy.com/?q=c+tutorial", 
            "title": "Variables"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-definitions", 
            "text": "This section of the document is meant to further define what is required, and expected for each Phase of the competition.", 
            "title": "Phase Definitions"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-i", 
            "text": "Purpose:  Allow recruits to get acquainted with a very simple program, and how the process works to program the RC Car. The recruits will need to call functions that have been premade for them, and make a simple loop.  Required Tasks:   \uf0b7\uf0b7Drive Forward for 10 seconds  \uf0b7\uf0b7Drive Backward for 10 seconds  \uf0b7\uf0b7Turn Right for 10 seconds  \uf0b7\uf0b7Turn Left for 10 seconds   Explanation:  This phase should not require further explanation in order to get a grasp on what's required. By defining a few variables, and using the pre-made functions given to use, the recruit should be able to create a program that performs the above tasks.  Evaluation and Weighting:    10% in total for the phase  2.5% will be given per each of the 4 tasks  It is simply expected that the car moves in the appropriate direction for the given time period. The car does not need to stop \"spot on\" the 10 second mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.", 
            "title": "Phase I"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-ii", 
            "text": "Purpose:  The initial purpose of this phase is to have the recruits create a new function from scratch. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.  Required Tasks:   \uf0b7\uf0b7Drive Forward 10 meters  \uf0b7\uf0b7Drive Backward 10 meters   Explanation:  In this phase the recruit must create their own function in order to determine the distance travelled from the car's current position, to a start point (or previous waypoint).  Your function definition should pass in latitude and longitude values of the GPS coordinates (2 sets, one for point 'A' and one for point 'B'). The following website gives you a pretty good layout of how your code should look (to some extent, it will look different due to you programming in C and not Java Script). Specifically the following code bite as well:  http://www.movable-type.co.uk/scripts/latlong.html   Above is the formula you must program into your function.  Below is how the created such a function with Java Script. *** Your function should return a float of \"d\"   var R =6371;// km  var\u03c61= lat1.toRadians();  var\u03c62= lat2.toRadians();  var\u0394\u03c6=(lat2-lat1).toRadians();  var\u0394\u03bb=(lon2-lon1).toRadians();  var a =Math.sin(\u0394\u03c6/2)*Math.sin(\u0394\u03c6/2)+      Math.cos(\u03c61)\\*Math.cos(\u03c62)\\*\n\n    Math.sin(\u0394\u03bb/2)\\*Math.sin(\u0394\u03bb/2);  var c =2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));  var d = R * c;   The only addition you must make to this code (besides writing it correctly for your C program), is to multiple the \"c\" value above by \u00b11000. Is needed to convert kilometers into meters.  Evaluation and Weighting:    10% in total for the phase  5% will be given per each of the 2 tasks  Initially, it is simply expected that the car moves in the appropriate direction for the given distance. The car does not need to stop \"spot on\" the 10 meter mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.  Furthermore, out of the 5% given towards either task, a weighting of 4% will be achieved by implementing the functionality described in the previous paragraph. The additional 1% will be achieved based on error to the 10m mark. In order to reach the 10m as close as possible, the recruit must implement proper Control Theory in order to slow the car down and receive the extra weighting. The code cannot be written to simply reverse the car for a millisecond after reaching the 10m mark, as this harms the equipment and decreases its lifespan. You may not reverse back to the 10m mark either if you have passed it. Additionally, in order to achieve this extra weighting (and so that WARG can see your control loop is working correctly), the RC Car must be started at an initial throttle of _(40)_%. The weighting will be received based on error in comparison to the top team for this phase (team closest to the 10m mark).  Please note that the control theory aspect will be learned in later phases of the competition. The \"closeness\" to the 10m mark is worth only 1% since it is WARG's desire that all teams initially develop the code well enough to accomplish the initial 4% of this phase for each task. If teams finish the majority of the competition, and after learning control theory, they may return back to this phase in order to try and receive the addition 1%.", 
            "title": "Phase II"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-iii", 
            "text": "Purpose:  The initial purpose of this phase is to have the recruits begin to think in terms of heading, and how it relates to controlling the steering of the car. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.  Required Tasks:   \uf0b7\uf0b7Drive Forward 5 meters, then  ooTurn Right 90 degrees, then  ooTurn Left 90 degrees   Explanation:  In this phase the recruit must create their own functionality in order to determine which direction to steer the car at any given point in time. The car may bounce around, and therefore move off of the desired path. Since we are constantly checking the state of the car (by continuously looping through the entire code), we can determine which way to steer the car at any point in time. It is recommended that this functionality be developed in the form of a function.  At no point during this phase should the car come to a stop while transitioning between task objectives. The desire is that the car drives a smooth path. For this reason, the car should never operate under _(20)_% throttle while transitioning between task objectives. The car may only be controlled to a complete stop once you are completed the phase in the \"Turn Left 90 degrees\" sub-task. Again, the car may never be driven backwards, and must always be moving forwards.  Evaluation and Weighting:    15% in total for the phase  12% will be given for initially achieving the tasks above by going (at minimum) the distance or angle change that's stated.  Initially it is WARG's desire that the recruit moves on after achieving this initial functionality, and returns back at a later time to improve upon the phase's functionality. The additional 3% will be achieved similarly to the methods described in Phase II, in the same manner that the additional 1% is achieved.", 
            "title": "Phase III"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-iv", 
            "text": "Purpose:  The purpose of this phase is for the recruit to put all of the functionality they've developed together, and create a simple control loop.  Required Tasks:   \uf0b7\uf0b7Drive a straight line  ooWhile maintaining heading  ooStop after _(100)_m   Explanation:  In this phase the recruit must create a control loop that will steer the car accordingly and keep it on the desired path. This involves monitoring the heading of the car, and steering the car in the appropriate direction if it starts to stray from the desired path. A heading a starting direction will be determined by WARG based on the competition testing location (the heading to hold will be hardcoded into the recruits program ahead of time, since at this point we are not expecting anything that calculates which heading should be held).  You will notice that if you turn the car too much in a given direction when it strays off the path, it will quickly be weaving back and forth on the path, and the amplitude of this \"weave\" will increase overtime. This is because you must  converge  towards the desired path, rather than do a jerking turn that makes the car immediately be on the path. The rate at which you turn the steering, relative to your distance from the path, is controlled through the  control loop , and by tuning the gains appropriately to fit your system (in this case the system is the RC Car).  Please refer to the  Control Theory  section in order to gain more knowledge on how to create a control loop. As well, WARG is considering bring in lecturers in order to host short lectures / tutorials on these concepts. This will be done based on the interest of the students.  Evaluation and Weighting:    15% in total for the phase  Considering that we do not expect the car to stray to too far from the desired path (there are no strong winds pushing the car off its path, such as that which occurs with the airplane while in the air), we do not expect the error from the path to be very large at all. Even if the recruit poorly tuned that control loops / gains, we believe the system shouldn't have a problem staying on the desired path.  With this in mind, the 10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error.  The additional 5% of this phase will be calculated based on the recruit's error in distance travelled, in comparison to that of the top team's error. (Hint: this is a controlled stop like that described in Phase II)  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired travel distance of _(100)_m. Again, the car should always be moving forward.", 
            "title": "Phase IV"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-v", 
            "text": "Purpose:  The purpose of this phase is for the recruit to develop dynamic functionality of their code (i.e. not hardcoded values). This phase also has the purpose of developing code that drives the car based on waypoints.  Required Tasks:   \uf0b7\uf0b7Drive from Point A to Point B  ooStop within a _(5)_m radius   Explanation:  The functionality as described in Phase IV should be implemented in this phase in order to better complete the task described.  You'll need to apply some logic into your program and probably create another function to perform basic geometry. In order to find the line (and heading) you must follow, you'll have to generate a xy based system from you latitude / longitude coordinates. You can do this by specifying an anchor point (of latitude longitude, this could possibly be your position on start-up). You can then find your x component, and y component of any given waypoint by holding either your latitude / longitude constant, and sending your anchor, and new waypoint through your getDistance() function.  On competition day, WARG will provide the recruit with a Waypoint to travel to. The program must get its current GPS position (current waypoint), and then calculate a straight line from this current position to the desired waypoint given by WARG. This is the heading that the car must be desired to hold in order to get to the waypoint.  WARG will start the car in the opposite (or some determined) direction relative to the goal Waypoint in order to ensure the system is calculating things appropriately.  *Hint: The RC Car should calculated which direction to turn in order to be going the appropriate heading the fastest.  Evaluation and Weighting:    15% in total for the phase  10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.  The additional 5% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 5% weighting.  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.", 
            "title": "Phase V"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-vi", 
            "text": "Purpose:  The purpose of this phase is to combine everything that the recruit has learned in order to make the RC Car follow a dynamic path of waypoints. Two paths of _(10)_ waypoints will be given for the car to follow (the car will follow one path, and then the new waypoints will be programmed, and the second path will be followed).  Required Tasks:   \uf0b7\uf0b7Follow a set of _(10)_ Waypoints   Explanation:  At this point in time, WARG hopes that the recruit has learned enough from previous stages in order to accomplish the described task of following a set of _(10)_ waypoints.  Waypoint 1 will be the RC Car's current position, the additional 9 waypoints will be provided.  Evaluation and Weighting:    35% in total for the phase  34% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.  The additional 1% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the final waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 1% weighting.  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.", 
            "title": "Phase VI"
        }, 
        {
            "location": "/tutorials/git/", 
            "text": "Git and Github Tutorial\n\n\nThis tutorial will introduce you to git and github. Knowing these is essential if you want to contribute to the software side of UWARG.\n\n\nWhat is Git?\n\n\nGit\n is a source code version control system. What does this mean? It lets you manage source code. Git tracks changes to your code, lets you revert your code, and allows you to collaborate with other people easily.  Git tracks the \nchanges\n to your files only, not the individual files themselves.\n\n\nWhy use Git?\n\n\nYou may just be used to saving code to your computer locally only, and relying on Ctrl-Z in case you break something and want to restart. This is where git shines. You commit code, which allows you to revert to it later if need be (say, you break something).\n\n\nInstalling git\n\n\nYou have two options when installing Git. There's the command line version (you use it through the command promt/no gui). There's also \nGithub for Desktop\n, which is a GUI client for Git that integrates with Github (don't worry we'll explain github later on). If you're a beginner, you should probably start out with the GUI client. If you're on linux or interested in using the command shell (its usually faster than the GUI client) then install that.\n\n\nWindows\n\n\nYou can download and run the \ngit installer\n\n\nMac OS X\n\n\nYou can install \nhomebrew\n and install git with \nbrew install git\n\n\nUbuntu\n\n\nIf you're using linux, you can install git by simply running:\n\nsudo apt-get install git\n. \n\n\nCreating a Github account\n\n\nSign up\n for a github account if you don't have one. We'll later explain what github is, but you can just create an account for now.\n\n\nSetting up git for the first time\n\n\nTo set up git for the first time on your computer, run these commands in the git shell (or the command line): \n\n\ngit config --global user.name \nYour Name\n\ngit config --global user.email your.email@example.com\ngit config --global push.default matching\ngit config --global alias.co checkout\n\n\n\n\nWhere \nYour Name\n and \nyour.email@example.com\n preferrably match your github account. If you've installed the GUI Github for Desktop client, you've probably done all of these steps already at the startup screen.\n\n\nHow to use Git\n\n\nUsing git is very simple. How the workflow works is:\n\n\n\n\nYou edit your code in your project\n\n\nYou decide that you would like to save the current state of your project\n\n\nYou add the changed files to the staging index with \ngit add .\n\n\nYou commit the files with \ngit commit -m \"Your unique commit message here\n\n\n\n\nBranching\n\n\nGit branches are a feature of git that allow you to work on multiple features at once. Branches also allow you to\nprototype and try new things without breaking the main code. A branch lets you essentially create a current snapshot\nof your code. A git repo can have as many branches as you want. \n\n\nSay for example you're working on Feature X. Feature X will take a while to make, and since you don't want it to be in the main code until its ready, you decide you want to  branch off of the \nmaster\n branch with a new branch called \nfeature-x\n. To create a branch you type in \ngit checkout -b feature-x\n. Now all of your changes and commits are applied to the \nfeature-x\n branch, and not the master branch. \n\n\nSay now you want to add Feature Y. Because you're using branches, you're not directly affecting the main code. You can\nswitch to the \nmaster\n branch with \ngit checkout master\n, which contains the latest, most stable code for your application. \nNow you can create a branch off of master called \nfeature-y\n with \ngit branch feature-y\n and then work on that branch \nwith \ngit checkout feature-y\n. Note that \ngit checkout -b feature-y\n is the same as running the previous two commands.\n\n\nYou can move between branches this way, and work on multiple features all at the same time, whilst not affecting the main code,\nusually located in the \nmaster\n branch until your feature is ready.\n\n\nThat's it! Its that simple. When using git you may want to wrap your head around the concept of the staging index, the remote repository, local repository, etc. Those go beyond this tutorial however if you're interested you head scroll down to the \nAdditional Resources\n section which lists articles that explain it.\n\n\nCommon Commands\n\n\nHere are some common commands you can use with git:\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit init\n\n\nCreate a repository in the current directory\n\n\n\n\n\n\ngit clone {url}\n\n\nClone a remote repository into a subdirectory\n\n\n\n\n\n\ngit add {file or path}\n\n\nAdd file or files in directory recursively to the staging index\n\n\n\n\n\n\ngit add .\n\n\nAdd all of your changes to the staging index\n\n\n\n\n\n\ngit add . --all\n\n\nAdd all of your changes to the staging index (including removed files)\n\n\n\n\n\n\ngit reset HEAD {file or path}\n\n\nRemove file or files from the staging index\n\n\n\n\n\n\ngit checkout -- .\n\n\nRemove all changes from your working tree\n\n\n\n\n\n\ngit checkout {branch_name}\n\n\nSwitch to a branch\n\n\n\n\n\n\ngit checkout -b {branch_name}\n\n\nSwitch to a branch and create it if it doesnt yet exist\n\n\n\n\n\n\ngit branch {branch_name}\n\n\nCreate a branch off of the one you're currently on\n\n\n\n\n\n\ngit branch\n\n\nView all the branches you have stored locally, as well as view the branch you're on\n\n\n\n\n\n\ngit status\n\n\nShow status of the working tree\n\n\n\n\n\n\ngit diff {file}\n\n\nShow the changes in the file\n\n\n\n\n\n\ngit diff\n\n\nShow all changes in the working tree\n\n\n\n\n\n\ngit commit {file or path}\n\n\nCommit files that has been staged (with git-add)\n\n\n\n\n\n\ngit reset --soft HEAD^\n\n\nUndo commit \n keep changes in the working tree\n\n\n\n\n\n\ngit reset --hard HEAD^\n\n\nReset the working tree to the last commit\n\n\n\n\n\n\ngit log {path} --oneline\n\n\nView commit log, optionally for specific path\n\n\n\n\n\n\ngit blame [file]\n\n\nShow file annotated with line modifications\n\n\n\n\n\n\ngit fetch\n\n\nFetch changes from a remote repository\n\n\n\n\n\n\ngit pull\n\n\nFetch and merge changes from a remote repository\n\n\n\n\n\n\ngit push origin {branch_name}\n\n\nPush branch and its changes to a remote repository (like github)\n\n\n\n\n\n\ngit remote -v\n\n\nList remote repositories\n\n\n\n\n\n\n\n\nWhat is Github?\n\n\nWhen you create a git repository, it created on your file system. \nGithub\n is the dropbox of git. It allows you to store your git repository online in public. This lets other people download and collaborate with your repo. Github has some extra perks in terms\nof collaborating with other people. One of these features includes the creation of Pull Requests. \n\n\nPull Requests\n\n\nA pull requests is analogous to you asking everyone on your project to take a look at the work you did, and accept your changes if they all agree. Thats what a pull request lets you do.\n\n\nA normal git/github workflow works like this:\n\n\n\n\nYou branch off of the master branch of the repo you're working on\n\n\nYou make your changes, committing often\n\n\nYou open up a Pull Request on Github against the master branch\n\n\nAnyone else working on the project will look at the PR, look at the changes you've made, and make comments on them if necessary\n\n\nAfter everyone gives you the thumbs up, you have permission to merge your changes in to the master branch. At that point anyone else that branches of off master will have your changes\n\n\nRepeat Step 1\n\n\n\n\nForks\n\n\nGithub also allows forks. Forks are essentially the ability to clone github repos that you dont have permission to push to into\nyour own account. After you've made changes to your fork, you can create a pull request against the original repo, and the developers\nof the repo can merge your changes in if they like them. \n\n\nAdditional Resources\n\n\n\n\n15 Minute Git Tutorial\n\n\nCodeAcademy Git Course\n\n\nMore Resources", 
            "title": "Git and Github"
        }, 
        {
            "location": "/tutorials/git/#git-and-github-tutorial", 
            "text": "This tutorial will introduce you to git and github. Knowing these is essential if you want to contribute to the software side of UWARG.", 
            "title": "Git and Github Tutorial"
        }, 
        {
            "location": "/tutorials/git/#what-is-git", 
            "text": "Git  is a source code version control system. What does this mean? It lets you manage source code. Git tracks changes to your code, lets you revert your code, and allows you to collaborate with other people easily.  Git tracks the  changes  to your files only, not the individual files themselves.", 
            "title": "What is Git?"
        }, 
        {
            "location": "/tutorials/git/#why-use-git", 
            "text": "You may just be used to saving code to your computer locally only, and relying on Ctrl-Z in case you break something and want to restart. This is where git shines. You commit code, which allows you to revert to it later if need be (say, you break something).", 
            "title": "Why use Git?"
        }, 
        {
            "location": "/tutorials/git/#installing-git", 
            "text": "You have two options when installing Git. There's the command line version (you use it through the command promt/no gui). There's also  Github for Desktop , which is a GUI client for Git that integrates with Github (don't worry we'll explain github later on). If you're a beginner, you should probably start out with the GUI client. If you're on linux or interested in using the command shell (its usually faster than the GUI client) then install that.", 
            "title": "Installing git"
        }, 
        {
            "location": "/tutorials/git/#windows", 
            "text": "You can download and run the  git installer", 
            "title": "Windows"
        }, 
        {
            "location": "/tutorials/git/#mac-os-x", 
            "text": "You can install  homebrew  and install git with  brew install git", 
            "title": "Mac OS X"
        }, 
        {
            "location": "/tutorials/git/#ubuntu", 
            "text": "If you're using linux, you can install git by simply running: sudo apt-get install git .", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/tutorials/git/#creating-a-github-account", 
            "text": "Sign up  for a github account if you don't have one. We'll later explain what github is, but you can just create an account for now.", 
            "title": "Creating a Github account"
        }, 
        {
            "location": "/tutorials/git/#setting-up-git-for-the-first-time", 
            "text": "To set up git for the first time on your computer, run these commands in the git shell (or the command line):   git config --global user.name  Your Name \ngit config --global user.email your.email@example.com\ngit config --global push.default matching\ngit config --global alias.co checkout  Where  Your Name  and  your.email@example.com  preferrably match your github account. If you've installed the GUI Github for Desktop client, you've probably done all of these steps already at the startup screen.", 
            "title": "Setting up git for the first time"
        }, 
        {
            "location": "/tutorials/git/#how-to-use-git", 
            "text": "Using git is very simple. How the workflow works is:   You edit your code in your project  You decide that you would like to save the current state of your project  You add the changed files to the staging index with  git add .  You commit the files with  git commit -m \"Your unique commit message here", 
            "title": "How to use Git"
        }, 
        {
            "location": "/tutorials/git/#branching", 
            "text": "Git branches are a feature of git that allow you to work on multiple features at once. Branches also allow you to\nprototype and try new things without breaking the main code. A branch lets you essentially create a current snapshot\nof your code. A git repo can have as many branches as you want.   Say for example you're working on Feature X. Feature X will take a while to make, and since you don't want it to be in the main code until its ready, you decide you want to  branch off of the  master  branch with a new branch called  feature-x . To create a branch you type in  git checkout -b feature-x . Now all of your changes and commits are applied to the  feature-x  branch, and not the master branch.   Say now you want to add Feature Y. Because you're using branches, you're not directly affecting the main code. You can\nswitch to the  master  branch with  git checkout master , which contains the latest, most stable code for your application. \nNow you can create a branch off of master called  feature-y  with  git branch feature-y  and then work on that branch \nwith  git checkout feature-y . Note that  git checkout -b feature-y  is the same as running the previous two commands.  You can move between branches this way, and work on multiple features all at the same time, whilst not affecting the main code,\nusually located in the  master  branch until your feature is ready.  That's it! Its that simple. When using git you may want to wrap your head around the concept of the staging index, the remote repository, local repository, etc. Those go beyond this tutorial however if you're interested you head scroll down to the  Additional Resources  section which lists articles that explain it.", 
            "title": "Branching"
        }, 
        {
            "location": "/tutorials/git/#common-commands", 
            "text": "Here are some common commands you can use with git:     Command  Description      git init  Create a repository in the current directory    git clone {url}  Clone a remote repository into a subdirectory    git add {file or path}  Add file or files in directory recursively to the staging index    git add .  Add all of your changes to the staging index    git add . --all  Add all of your changes to the staging index (including removed files)    git reset HEAD {file or path}  Remove file or files from the staging index    git checkout -- .  Remove all changes from your working tree    git checkout {branch_name}  Switch to a branch    git checkout -b {branch_name}  Switch to a branch and create it if it doesnt yet exist    git branch {branch_name}  Create a branch off of the one you're currently on    git branch  View all the branches you have stored locally, as well as view the branch you're on    git status  Show status of the working tree    git diff {file}  Show the changes in the file    git diff  Show all changes in the working tree    git commit {file or path}  Commit files that has been staged (with git-add)    git reset --soft HEAD^  Undo commit   keep changes in the working tree    git reset --hard HEAD^  Reset the working tree to the last commit    git log {path} --oneline  View commit log, optionally for specific path    git blame [file]  Show file annotated with line modifications    git fetch  Fetch changes from a remote repository    git pull  Fetch and merge changes from a remote repository    git push origin {branch_name}  Push branch and its changes to a remote repository (like github)    git remote -v  List remote repositories", 
            "title": "Common Commands"
        }, 
        {
            "location": "/tutorials/git/#what-is-github", 
            "text": "When you create a git repository, it created on your file system.  Github  is the dropbox of git. It allows you to store your git repository online in public. This lets other people download and collaborate with your repo. Github has some extra perks in terms\nof collaborating with other people. One of these features includes the creation of Pull Requests.", 
            "title": "What is Github?"
        }, 
        {
            "location": "/tutorials/git/#pull-requests", 
            "text": "A pull requests is analogous to you asking everyone on your project to take a look at the work you did, and accept your changes if they all agree. Thats what a pull request lets you do.  A normal git/github workflow works like this:   You branch off of the master branch of the repo you're working on  You make your changes, committing often  You open up a Pull Request on Github against the master branch  Anyone else working on the project will look at the PR, look at the changes you've made, and make comments on them if necessary  After everyone gives you the thumbs up, you have permission to merge your changes in to the master branch. At that point anyone else that branches of off master will have your changes  Repeat Step 1", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/tutorials/git/#forks", 
            "text": "Github also allows forks. Forks are essentially the ability to clone github repos that you dont have permission to push to into\nyour own account. After you've made changes to your fork, you can create a pull request against the original repo, and the developers\nof the repo can merge your changes in if they like them.", 
            "title": "Forks"
        }, 
        {
            "location": "/tutorials/git/#additional-resources", 
            "text": "15 Minute Git Tutorial  CodeAcademy Git Course  More Resources", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/tutorials/shell/", 
            "text": "Using the command shell\n\n\nSome of the docs and tutorials on this site assume that you know how to navigate the file system using the terminal (whether it be on Windows, Linux, or Mac). For example, working with the computer-vision and groundstation projects is alot easier to do on the command line than with a GUI. In both cases, it isn't possible to setup either of these projects without touching the command line. \n\n\nA recommended tutorial you can checkout is \nCodeAcademy's Command Line Course\n. They guide you through using bash to navigate the file system, run commands, etc. The course is free and should only take you about 3 hours. It's interactive and will teach you how to use the shell far better than we can ;).\n\n\nNote: This course teaches bash (which is what runs on linux by default). It is however far better than the Windows CMD and you can install and use it on Windows by downloading and installing something like \ncmder\n.", 
            "title": "Using the terminal"
        }, 
        {
            "location": "/tutorials/shell/#using-the-command-shell", 
            "text": "Some of the docs and tutorials on this site assume that you know how to navigate the file system using the terminal (whether it be on Windows, Linux, or Mac). For example, working with the computer-vision and groundstation projects is alot easier to do on the command line than with a GUI. In both cases, it isn't possible to setup either of these projects without touching the command line.   A recommended tutorial you can checkout is  CodeAcademy's Command Line Course . They guide you through using bash to navigate the file system, run commands, etc. The course is free and should only take you about 3 hours. It's interactive and will teach you how to use the shell far better than we can ;).  Note: This course teaches bash (which is what runs on linux by default). It is however far better than the Windows CMD and you can install and use it on Windows by downloading and installing something like  cmder .", 
            "title": "Using the command shell"
        }, 
        {
            "location": "/groundstation/", 
            "text": "Welcome to the Groundstation docs!\n\n\nThe groundstation is the software running on the ground computer communicating to the plane through the \ndata-relay-station\n. This wiki describes everything you need to know about it in order to start contributing.\n\n\nTable of Contents\n\n\n\n\nIntroduction\n\n\nWhat you need to know\n\n\nInstallation\n\n\nTutorial\n\n\nProject Structure\n\n\nContributing\n\n\nDocumenting\n\n\nAdditional Resources", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/groundstation/#welcome-to-the-groundstation-docs", 
            "text": "The groundstation is the software running on the ground computer communicating to the plane through the  data-relay-station . This wiki describes everything you need to know about it in order to start contributing.", 
            "title": "Welcome to the Groundstation docs!"
        }, 
        {
            "location": "/groundstation/#table-of-contents", 
            "text": "Introduction  What you need to know  Installation  Tutorial  Project Structure  Contributing  Documenting  Additional Resources", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/groundstation/introduction/", 
            "text": "Introduction\n\n\nThe groundstation is a desktop application based on \nNW.js\n. This section will explain what NW.js and \nNode.js\n is.\n\n\nCommunication Path\n\n\nThe groundstation talks directly to the \ndata-relay-station\n. The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).\n\n\n\n\nWhat is Javascript and Node.js?\n\n\nAs you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes. \n\n\nEnter \nNode.js\n\n\nNode.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with \npython script.py\n you can run javascript scripts with \nnode script.js\n. It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it. \n\n\nWhat is NW.js?\n\n\nOk, so where does \nNW.js\n fit in all this? Why do we need it if we can already write native applications with node.js and javascript? You can think of NW.js as a GUI framework. Usually when making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.\n\n\nNW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.", 
            "title": "Introduction"
        }, 
        {
            "location": "/groundstation/introduction/#introduction", 
            "text": "The groundstation is a desktop application based on  NW.js . This section will explain what NW.js and  Node.js  is.", 
            "title": "Introduction"
        }, 
        {
            "location": "/groundstation/introduction/#communication-path", 
            "text": "The groundstation talks directly to the  data-relay-station . The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).", 
            "title": "Communication Path"
        }, 
        {
            "location": "/groundstation/introduction/#what-is-javascript-and-nodejs", 
            "text": "As you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes.   Enter  Node.js  Node.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with  python script.py  you can run javascript scripts with  node script.js . It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it.", 
            "title": "What is Javascript and Node.js?"
        }, 
        {
            "location": "/groundstation/introduction/#what-is-nwjs", 
            "text": "Ok, so where does  NW.js  fit in all this? Why do we need it if we can already write native applications with node.js and javascript? You can think of NW.js as a GUI framework. Usually when making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.  NW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.", 
            "title": "What is NW.js?"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/", 
            "text": "What you need to know\n\n\nThis section will help to highlight \nmost\n of what you need to know before you can start developing. \n\n\nJavascript\n\n\nIf you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this \nCodeacademy Javascript Course\n. The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are: \n\n\n\n\nThe significance of var and when and when not to use it\n\n\nThat everything in javascript is an object, including functions\n\n\nThe 3 different ways of declaring javascript objects, and how they are different\n\n\n\n\nNode.js\n\n\nSo you don't need to read all of the gigantic \nNode.js API Documentation\n, though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.\n\n\nNode.js modules\n\n\nSo what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word \nrequire\n being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you. \n\n\nUsually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.\n\n\nSo what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling \nrequire('filelocation/filename)\n. But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.\n\n\nLets take an example comparing traditional methods and using require. \n\n\nUsing Regular Javascript\n\n\nhead\n\n    \nscript\n\n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n    \n/script\n\n    \nscript\n\n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n    \n/script\n\n\n/head\n\n\n\n\n\nThis is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.\n\n\nUsing Node.js Modules\n\n\n//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;\n\n\n\n\n//this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!\n\n\n\n\nYou may have noticed the \nmodule.exports=hello;\n line in the \nhello.js\n module. What this tells node is the result of calling \nrequire\n on the hello.js module will return the variable/function hello. In \napp.js\n we use this module by calling \nvar hello=require('hello')\n. The variable hello now contains whatever the \nhello.js\n module exported, which in this case is a function.\n\n\nYou can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling \nvar\n will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.\n\n\nNode Package Manager (npm)\n\n\nNPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the \nNPM registry\n. \n\n\nThe most important command of npm is \nnpm install \npackagename\n. This will install a package in your project directory. Doing an \nnpm install\n without any parameters at the project root will tell npm to look in your projects \npackage.json\n file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running \nnpm install -g nw\n. This will install the NW.js module globally on your computer, allowing you to use the \nnw\n command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running \nnw\n in the terminal.\n\n\nJavascript Frameworks\n\n\nThe groundstation uses \nBackbone\n and \nMarionette\n as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.\n\n\nYou don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation. \n\n\nLibraries Used\n\n\nOne of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include \nJquery\n for simple dom manipulations, and \nleaflet\n as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the \nLeaflet API Docs\n is pretty useful if you're working with the Map modules.", 
            "title": "What you need to know"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#what-you-need-to-know", 
            "text": "This section will help to highlight  most  of what you need to know before you can start developing.", 
            "title": "What you need to know"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#javascript", 
            "text": "If you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this  Codeacademy Javascript Course . The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are:    The significance of var and when and when not to use it  That everything in javascript is an object, including functions  The 3 different ways of declaring javascript objects, and how they are different", 
            "title": "Javascript"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs", 
            "text": "So you don't need to read all of the gigantic  Node.js API Documentation , though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.", 
            "title": "Node.js"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs-modules", 
            "text": "So what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word  require  being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you.   Usually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.  So what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling  require('filelocation/filename) . But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.  Lets take an example comparing traditional methods and using require.", 
            "title": "Node.js modules"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#using-regular-javascript", 
            "text": "head \n     script \n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n     /script \n     script \n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n     /script  /head   This is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.", 
            "title": "Using Regular Javascript"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#using-nodejs-modules", 
            "text": "//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;  //this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!  You may have noticed the  module.exports=hello;  line in the  hello.js  module. What this tells node is the result of calling  require  on the hello.js module will return the variable/function hello. In  app.js  we use this module by calling  var hello=require('hello') . The variable hello now contains whatever the  hello.js  module exported, which in this case is a function.  You can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling  var  will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.", 
            "title": "Using Node.js Modules"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#node-package-manager-npm", 
            "text": "NPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the  NPM registry .   The most important command of npm is  npm install  packagename . This will install a package in your project directory. Doing an  npm install  without any parameters at the project root will tell npm to look in your projects  package.json  file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running  npm install -g nw . This will install the NW.js module globally on your computer, allowing you to use the  nw  command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running  nw  in the terminal.", 
            "title": "Node Package Manager (npm)"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#javascript-frameworks", 
            "text": "The groundstation uses  Backbone  and  Marionette  as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.  You don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation.", 
            "title": "Javascript Frameworks"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#libraries-used", 
            "text": "One of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include  Jquery  for simple dom manipulations, and  leaflet  as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the  Leaflet API Docs  is pretty useful if you're working with the Map modules.", 
            "title": "Libraries Used"
        }, 
        {
            "location": "/groundstation/installation/", 
            "text": "Installation\n\n\n\n\n\n\nThe first step is cloning the repository. Open up the terminal and run: \n\ngit clone https://github.com/UWARG/WARG-Ground-Station\n\n\n\n\n\n\nThen you need to install Node.js. You can download and install it \nhere\n. Download Node version 5 and above preferably. After you've installed node you should have the \nnode\n command available for you to use in your terminal. Run \nnode help\n to verify that you've successfuly installed node and make sure you're running the right version.\n\n\n\n\n\n\nNow that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run \nnpm install\n to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).\n\n\n\n\n\n\nNow you're ready to start the app up. Run \nnpm start\n to start the application. You should see a window appear of the groundsation.\n\n\n\n\n\n\nNow you need to download the offline satelite files that the application uses for it's map. \nDownload them here.\n. Extract the zip into the \nassets\n folder of the project directory (so you should have a folder called \nsat_tiles\n in the assets folder). \n\n\n\n\n\n\nCongratulations! You should now have the groundstation installed on your computer ready for you to develop on!", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/installation/#installation", 
            "text": "The first step is cloning the repository. Open up the terminal and run:  git clone https://github.com/UWARG/WARG-Ground-Station    Then you need to install Node.js. You can download and install it  here . Download Node version 5 and above preferably. After you've installed node you should have the  node  command available for you to use in your terminal. Run  node help  to verify that you've successfuly installed node and make sure you're running the right version.    Now that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run  npm install  to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).    Now you're ready to start the app up. Run  npm start  to start the application. You should see a window appear of the groundsation.    Now you need to download the offline satelite files that the application uses for it's map.  Download them here. . Extract the zip into the  assets  folder of the project directory (so you should have a folder called  sat_tiles  in the assets folder).     Congratulations! You should now have the groundstation installed on your computer ready for you to develop on!", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/tutorial/", 
            "text": "Groundstation Tutorial\n\n\nThis tutorial will guide you through creating a groundstation window and adding logic to it using the core application modules. \n\n\nInstallation\n\n\nFollow the installation guide \nhere\n to install the groundstation on your computer.\n\n\nEditor\n\n\nYou can use your prefered editor for this application, or an IDE like Webstorm if you prefer.\n\n\nGetting Started\n\n\nTake a look at the \nproject structure\n so you roughly know what each folder of the application is for.\n\n\nCreating a new window\n\n\nTo start create a window, we need to create an html file that will represent our window. In the \nwindow\n folder at the project root, create a file and call it \nnew-window.html\n. Paste this boilerplate code on there:\n\n\n!DOCTYPE html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nUTF-8\n\n    \ntitle\nMy new window\n/title\n\n\n/head\n\n\nbody\n\n    \np\nHello this is my new window!\n/p\n\n\n/body\n\n\n/html\n\n\n\n\n\nAdding a menu item\n\n\nSo all we've done is create a layout file for the new window. Now we've got to \nhave a way of opening the window. To do this we'll add a menu item to our application which will open up our window. \n\n\nOpen up \napp/Menu.js\n. This is the file the application uses to configure it's menu items. At the bottom of the file, add this entry under the window submenu:\n\n\n// ===Window Submenu ===\n    var window_submenu=new gui.Menu();\n\n    //A bunch of code here\n\n    //You need to add this\n  window_submenu.append(new gui.MenuItem({\n    label:'My new window',\n    type:'checkbox',\n    click: function(){\n      gui.Window.open('windows/new-window.html',{\n        focus: true\n      });\n    },\n    key: \nk\n,\n    modifiers: \nctrl-shift\n,\n  }));\n\n\n\n\n\n\nNow lets see what we just did. Calling \nwindow_submenu.append(..)\n appends a menu item to the Window menu of the app. In this case its a \ngui.MenuItem\n which represents a menu item in NW.js applications. The \nlabel\n parameter is the name of the menu item, the \ntype: checkbox\n  indicates that we want the menu item to behave as a checkbox (when you open the window its checked). The \nclick\n parameter indicates the callback funtion to execute when the user has clicked on the menu item. Here, we are calling \ngui.Window.open(...)\n to open up the window layout file we've just created. The \nkey\n and \nmodifiers\n parameters indicate the keyboard shortcuts that may be used to open up the window as well.\n\n\nNow run the app. In the window submenu you should see a new item called \"My new window\". When you click it a new window will appear, with the text 'Hello this is my new window!'. \n\n\nAwesome, you've just added a window to the app. Now lets add more functionality to it with javascript.\n\n\nAdding javascript functionality\n\n\nEvery window you add will require a starting point. A single entry-point module. For the main application it is \napp/App.js\n. For your window it'll be different. You will have to create that entry-point module and load it in the window layout file you just created. This module will then load all of its dependencies (if any) and handle creating the view. \n\n\nTo begin create a file called \nnew-window.js\n inside the \napp/windows/\n folder. Then in \nnew-window.html\n file you created earlier, paste this after the \ntitle\n tag.\n\n\n!-- Our libraries --\n\n\nscript src=\n../app/lib/jquery-2.1.4.js\n/script\n\n\nscript src=\n../app/lib/underscore.js\n/script\n\n\nscript src=\n../app/lib/backbone.js\n/script\n\n\nscript src=\n../app/lib/backbone.marionette.js\n/script\n\n\n\n!-- Our window entry point --\n\n\nscript src=\n../app/windows/new-window.js\n/script\n\n\n\n\n\nSo what are all of these scripts? They are libraries that you will end up using later in the tutorial. The main one we'll use is Marionette, and the rest are dependencies that Marionette requires, such as underscore and jquery.\n\n\nNow lets create an element that we can play around with in our script. Under the \np\n tag add of the \nnew-window.html\n file add this line:\n\n\ndiv id=\nspecial\nOur Special div\n/div\n\n\n\n\n\nWe've assigned an id to this div so that we can reference it later in our javascript. \n\n\nNow that we've got our layout file ready, lets add the functionality in our application entry point. In \nnew-window.js\n, add this line:\n\n\n$(document).ready(function(){\n  $('#special').text('This text was not originally written on the div! Amazing!');\n});\n\n\n\n\nNow lets go to our app and open up the window. You should see this: \n\n\n\n\nIf all went well, you have successfully created an application entry point script for your newly created window. You are now ready to add more complex functionality to it. The next section will talk about debugging your application and implementing Marionette and MVC in your window.\n\n\nDebugging\n\n\nIf your window still says 'Our Special div' that means you've made a mistake. To diagnose what went wrong, you can open up the developer tools console by clicking on the three bars right next to the url bar of the window. It'll tell you if there were any javascript errors or if any files failed to load.\n\n\nCreating the Marionette ItemView\n\n\nSo what we did previously is use jquery directly to manipulate a div in our layout (the view). That was a pretty simple example, however continuing to work on it this way will lead to hard to maintain code, since we're mixing our view logic (ie manipulations) and our application logic together. This is something we should avoid doing, and with the help of Marionette, its pretty easy to do so. \n\n\nTo get started, create a new file called \nnewWindowView.js\n in the \napp/views/\n folder. Copy and paste this boilerplate code:\n\n\n//This is an example Marionette view\n//NOTE: you should not require jquery in your views, as you should only reference the elements inside the view which you can do with the ui property of the view\nvar Template=require('../util/Template');\n/*\ncall your other dependencies here (for example if you need to listen to network events, call this)\nvar Network=require('../Network'); \nthen use the Network object inside your view\n*/\n\nmodule.exports=function(Marionette){\n\n  return Marionette.ItemView.extend({\n    template:Template('newWindowView'), //name of the file in the views folder at the project root\n    className:'newWindowView', //this is the class name the injected div will have (refer to this class in your style sheets)\n\n    ui:{ //any ui elements in the view that you would like to reference within your view logic\n      an_element:\n#an-example-element\n //you can now refer to the jquery wrapped element within the view with this.ui.an_element\n    },\n\n    //your custom jquery events\n    //selector then the name of the callback function\n    events:{\n      \nclick #an-example-element\n: \nclickCallback\n\n    },\n\n    initialize: function(){\n      //called when the view is first initialized (ie new ExampleView())\n    },\n    onRender:function(){\n      //called right after a render is called on the view (view.render())\n    },\n    onBeforeDestroy:function(){\n      //called just before destroy is called on the view\n    },\n    onDestroy:function(){\n      //called right after a destroy is called on the view\n    },\n\n    clickCallback:function(event){ //will be fired when a user clicks on #an-example-element\n\n    }\n  });\n};\n\n\n\n\nThen, in your \nnew-window.html\n file, delete the \np\n and \ndiv\n lines, so that there is nothing in the \nbody\n tag.\n\n\nNow create a new layout file for the view by creating a file called \nnewWindowView.html\n inside the \nviews/\n folder at the project root. Paste this in the file:\n\n\np\nHello I am my own view!\n/p\n\n\n\n\n\nAnd in your \nnew-window.js\n file replace all of the code with this:\n\n\n//our new-window.js file (the window entry point)\nvar windowView=require('./app/views/newWindowView')(Marionette);\n\n$(document).ready(function(){\n  $('body').append((new windowView()).render().$el);\n});\n\n\n\n\nNow open up the groundstation and open up your window again. You should now see this:\n\n\n\n\nExplaning Marionette and ItemViews\n\n\nSo lets do a breakdown of what we just did. \n\n\nLets start of by explaning what an ItemView is. A Marionette itemView represents..a view. The itemView manages all aspects of the view, including rendering, capturing user input, etc.. \n\n\nEach ItemView has to have its own template file, which is the \nnewWindowView.html\n file we created in the \nviews/\n folder. We specify this in our ItemView by setting the \ntemplate\n property. The ItemView will render that template and then our application entry point (\nexample-window.js\n) will append it to the body of our window. Here is a diagram showing what happens:\n\n\n\n\nWhy do it this way?\n\n\nYou may be asking yourself what was the point of doing all the fancy stuff if the end result was the same. What we've just done is seperated our view logic and application logic into different modules. Now, say we want to create a combined window that combines our view with the map. Because all of the logic associated\nwith our view is completely isolated, there is no code that we have re-write. We simply import the views that we're interested in and inject them into our new window. This form of writing applications is called an \nMVC\n pattern, standing for Model View Controller.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/groundstation/tutorial/#groundstation-tutorial", 
            "text": "This tutorial will guide you through creating a groundstation window and adding logic to it using the core application modules.", 
            "title": "Groundstation Tutorial"
        }, 
        {
            "location": "/groundstation/tutorial/#installation", 
            "text": "Follow the installation guide  here  to install the groundstation on your computer.", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/tutorial/#editor", 
            "text": "You can use your prefered editor for this application, or an IDE like Webstorm if you prefer.", 
            "title": "Editor"
        }, 
        {
            "location": "/groundstation/tutorial/#getting-started", 
            "text": "Take a look at the  project structure  so you roughly know what each folder of the application is for.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/groundstation/tutorial/#creating-a-new-window", 
            "text": "To start create a window, we need to create an html file that will represent our window. In the  window  folder at the project root, create a file and call it  new-window.html . Paste this boilerplate code on there:  !DOCTYPE html  html lang= en  head \n     meta charset= UTF-8 \n     title My new window /title  /head  body \n     p Hello this is my new window! /p  /body  /html", 
            "title": "Creating a new window"
        }, 
        {
            "location": "/groundstation/tutorial/#adding-a-menu-item", 
            "text": "So all we've done is create a layout file for the new window. Now we've got to \nhave a way of opening the window. To do this we'll add a menu item to our application which will open up our window.   Open up  app/Menu.js . This is the file the application uses to configure it's menu items. At the bottom of the file, add this entry under the window submenu:  // ===Window Submenu ===\n    var window_submenu=new gui.Menu();\n\n    //A bunch of code here\n\n    //You need to add this\n  window_submenu.append(new gui.MenuItem({\n    label:'My new window',\n    type:'checkbox',\n    click: function(){\n      gui.Window.open('windows/new-window.html',{\n        focus: true\n      });\n    },\n    key:  k ,\n    modifiers:  ctrl-shift ,\n  }));  Now lets see what we just did. Calling  window_submenu.append(..)  appends a menu item to the Window menu of the app. In this case its a  gui.MenuItem  which represents a menu item in NW.js applications. The  label  parameter is the name of the menu item, the  type: checkbox   indicates that we want the menu item to behave as a checkbox (when you open the window its checked). The  click  parameter indicates the callback funtion to execute when the user has clicked on the menu item. Here, we are calling  gui.Window.open(...)  to open up the window layout file we've just created. The  key  and  modifiers  parameters indicate the keyboard shortcuts that may be used to open up the window as well.  Now run the app. In the window submenu you should see a new item called \"My new window\". When you click it a new window will appear, with the text 'Hello this is my new window!'.   Awesome, you've just added a window to the app. Now lets add more functionality to it with javascript.", 
            "title": "Adding a menu item"
        }, 
        {
            "location": "/groundstation/tutorial/#adding-javascript-functionality", 
            "text": "Every window you add will require a starting point. A single entry-point module. For the main application it is  app/App.js . For your window it'll be different. You will have to create that entry-point module and load it in the window layout file you just created. This module will then load all of its dependencies (if any) and handle creating the view.   To begin create a file called  new-window.js  inside the  app/windows/  folder. Then in  new-window.html  file you created earlier, paste this after the  title  tag.  !-- Our libraries --  script src= ../app/lib/jquery-2.1.4.js /script  script src= ../app/lib/underscore.js /script  script src= ../app/lib/backbone.js /script  script src= ../app/lib/backbone.marionette.js /script  !-- Our window entry point --  script src= ../app/windows/new-window.js /script   So what are all of these scripts? They are libraries that you will end up using later in the tutorial. The main one we'll use is Marionette, and the rest are dependencies that Marionette requires, such as underscore and jquery.  Now lets create an element that we can play around with in our script. Under the  p  tag add of the  new-window.html  file add this line:  div id= special Our Special div /div   We've assigned an id to this div so that we can reference it later in our javascript.   Now that we've got our layout file ready, lets add the functionality in our application entry point. In  new-window.js , add this line:  $(document).ready(function(){\n  $('#special').text('This text was not originally written on the div! Amazing!');\n});  Now lets go to our app and open up the window. You should see this:    If all went well, you have successfully created an application entry point script for your newly created window. You are now ready to add more complex functionality to it. The next section will talk about debugging your application and implementing Marionette and MVC in your window.", 
            "title": "Adding javascript functionality"
        }, 
        {
            "location": "/groundstation/tutorial/#debugging", 
            "text": "If your window still says 'Our Special div' that means you've made a mistake. To diagnose what went wrong, you can open up the developer tools console by clicking on the three bars right next to the url bar of the window. It'll tell you if there were any javascript errors or if any files failed to load.", 
            "title": "Debugging"
        }, 
        {
            "location": "/groundstation/tutorial/#creating-the-marionette-itemview", 
            "text": "So what we did previously is use jquery directly to manipulate a div in our layout (the view). That was a pretty simple example, however continuing to work on it this way will lead to hard to maintain code, since we're mixing our view logic (ie manipulations) and our application logic together. This is something we should avoid doing, and with the help of Marionette, its pretty easy to do so.   To get started, create a new file called  newWindowView.js  in the  app/views/  folder. Copy and paste this boilerplate code:  //This is an example Marionette view\n//NOTE: you should not require jquery in your views, as you should only reference the elements inside the view which you can do with the ui property of the view\nvar Template=require('../util/Template');\n/*\ncall your other dependencies here (for example if you need to listen to network events, call this)\nvar Network=require('../Network'); \nthen use the Network object inside your view\n*/\n\nmodule.exports=function(Marionette){\n\n  return Marionette.ItemView.extend({\n    template:Template('newWindowView'), //name of the file in the views folder at the project root\n    className:'newWindowView', //this is the class name the injected div will have (refer to this class in your style sheets)\n\n    ui:{ //any ui elements in the view that you would like to reference within your view logic\n      an_element: #an-example-element  //you can now refer to the jquery wrapped element within the view with this.ui.an_element\n    },\n\n    //your custom jquery events\n    //selector then the name of the callback function\n    events:{\n       click #an-example-element :  clickCallback \n    },\n\n    initialize: function(){\n      //called when the view is first initialized (ie new ExampleView())\n    },\n    onRender:function(){\n      //called right after a render is called on the view (view.render())\n    },\n    onBeforeDestroy:function(){\n      //called just before destroy is called on the view\n    },\n    onDestroy:function(){\n      //called right after a destroy is called on the view\n    },\n\n    clickCallback:function(event){ //will be fired when a user clicks on #an-example-element\n\n    }\n  });\n};  Then, in your  new-window.html  file, delete the  p  and  div  lines, so that there is nothing in the  body  tag.  Now create a new layout file for the view by creating a file called  newWindowView.html  inside the  views/  folder at the project root. Paste this in the file:  p Hello I am my own view! /p   And in your  new-window.js  file replace all of the code with this:  //our new-window.js file (the window entry point)\nvar windowView=require('./app/views/newWindowView')(Marionette);\n\n$(document).ready(function(){\n  $('body').append((new windowView()).render().$el);\n});  Now open up the groundstation and open up your window again. You should now see this:", 
            "title": "Creating the Marionette ItemView"
        }, 
        {
            "location": "/groundstation/tutorial/#explaning-marionette-and-itemviews", 
            "text": "So lets do a breakdown of what we just did.   Lets start of by explaning what an ItemView is. A Marionette itemView represents..a view. The itemView manages all aspects of the view, including rendering, capturing user input, etc..   Each ItemView has to have its own template file, which is the  newWindowView.html  file we created in the  views/  folder. We specify this in our ItemView by setting the  template  property. The ItemView will render that template and then our application entry point ( example-window.js ) will append it to the body of our window. Here is a diagram showing what happens:", 
            "title": "Explaning Marionette and ItemViews"
        }, 
        {
            "location": "/groundstation/tutorial/#why-do-it-this-way", 
            "text": "You may be asking yourself what was the point of doing all the fancy stuff if the end result was the same. What we've just done is seperated our view logic and application logic into different modules. Now, say we want to create a combined window that combines our view with the map. Because all of the logic associated\nwith our view is completely isolated, there is no code that we have re-write. We simply import the views that we're interested in and inject them into our new window. This form of writing applications is called an  MVC  pattern, standing for Model View Controller.", 
            "title": "Why do it this way?"
        }, 
        {
            "location": "/groundstation/project-structure/", 
            "text": "Project Structure\n\n\nThis is the project folder structure. Not that there are\nmore folders than listed here, however these are the most relevant.\n\n\n/\n    app/\n        connections/\n        lib/\n        map/\n        models/\n        util/\n        views/\n        windows/\n    assets/\n        fonts/\n        images/\n        simulation/\n        stl/\n    build/\n    config/\n    logs/\n    node_modules/\n    styles/\n        lib/\n        views/\n    views/\n    index.html\n    package.json\n\n\n\n\napp/\n\n\nThis is where all of the applications javascript files are located. It is the heart and soul of the groundstation.\n\n\napp/lib\n\n\nAll javascript libraries go here, including jquery, marionette, leaflet, etc..\n\n\napp/views\n\n\nApplication logic that's responsible for views. Every single view has its own file here.\n\n\nassets/\n\n\nAny binary assets are stored here\n\n\nbuild/\n\n\nThe output of running \nnpm run build\n, which creates an executable of the groundstation for every operating system.\n\n\nconfig/\n\n\nThe groundstation config files are stored here. These config files are then dynamically loaded, stored, and persisted across the application lifecycle.\n\n\nlogs/\n\n\nGroundstation log output. \n\n\nlogs/data_entries/\n\n\nOutput of the logs from the Data Entry Window\n\n\nnode_modules/\n\n\nAll of the node modules installed by running \nnpm install\n are stored in here. You don't really need to be concerned about this directory.\n\n\nstyles/\n\n\nCSS directory. This is where styles go. Everything in here is a .css file.\n\n\nviews/\n\n\nTemplates for the views of the app. Everything in here is .html files.\n\n\nindex.html\n\n\nThis is the starting point of the application. This file is loaded, which in turn loads the necessary javascript files required to make the application run.\n\n\npackage.json\n\n\nThis file describes the application, including any dependencies that it requires. You can read more about this file \nhere\n.", 
            "title": "Project Structure"
        }, 
        {
            "location": "/groundstation/project-structure/#project-structure", 
            "text": "This is the project folder structure. Not that there are\nmore folders than listed here, however these are the most relevant.  /\n    app/\n        connections/\n        lib/\n        map/\n        models/\n        util/\n        views/\n        windows/\n    assets/\n        fonts/\n        images/\n        simulation/\n        stl/\n    build/\n    config/\n    logs/\n    node_modules/\n    styles/\n        lib/\n        views/\n    views/\n    index.html\n    package.json", 
            "title": "Project Structure"
        }, 
        {
            "location": "/groundstation/project-structure/#app", 
            "text": "This is where all of the applications javascript files are located. It is the heart and soul of the groundstation.", 
            "title": "app/"
        }, 
        {
            "location": "/groundstation/project-structure/#applib", 
            "text": "All javascript libraries go here, including jquery, marionette, leaflet, etc..", 
            "title": "app/lib"
        }, 
        {
            "location": "/groundstation/project-structure/#appviews", 
            "text": "Application logic that's responsible for views. Every single view has its own file here.", 
            "title": "app/views"
        }, 
        {
            "location": "/groundstation/project-structure/#assets", 
            "text": "Any binary assets are stored here", 
            "title": "assets/"
        }, 
        {
            "location": "/groundstation/project-structure/#build", 
            "text": "The output of running  npm run build , which creates an executable of the groundstation for every operating system.", 
            "title": "build/"
        }, 
        {
            "location": "/groundstation/project-structure/#config", 
            "text": "The groundstation config files are stored here. These config files are then dynamically loaded, stored, and persisted across the application lifecycle.", 
            "title": "config/"
        }, 
        {
            "location": "/groundstation/project-structure/#logs", 
            "text": "Groundstation log output.", 
            "title": "logs/"
        }, 
        {
            "location": "/groundstation/project-structure/#logsdata_entries", 
            "text": "Output of the logs from the Data Entry Window", 
            "title": "logs/data_entries/"
        }, 
        {
            "location": "/groundstation/project-structure/#node_modules", 
            "text": "All of the node modules installed by running  npm install  are stored in here. You don't really need to be concerned about this directory.", 
            "title": "node_modules/"
        }, 
        {
            "location": "/groundstation/project-structure/#styles", 
            "text": "CSS directory. This is where styles go. Everything in here is a .css file.", 
            "title": "styles/"
        }, 
        {
            "location": "/groundstation/project-structure/#views", 
            "text": "Templates for the views of the app. Everything in here is .html files.", 
            "title": "views/"
        }, 
        {
            "location": "/groundstation/project-structure/#indexhtml", 
            "text": "This is the starting point of the application. This file is loaded, which in turn loads the necessary javascript files required to make the application run.", 
            "title": "index.html"
        }, 
        {
            "location": "/groundstation/project-structure/#packagejson", 
            "text": "This file describes the application, including any dependencies that it requires. You can read more about this file  here .", 
            "title": "package.json"
        }, 
        {
            "location": "/groundstation/contributing/", 
            "text": "Contributing\n\n\nIn order to contribute to the groundstation you must know how to use git. Check out our tutorial \nhere\n to learn how to use it.\nFollow the guidelines here if you want to contribute to the groundstation.\n\n\nGetting yourself a task\n\n\nIn order to qualify yourself to work on the groundstation, you must complete the groundstation bootcamp. The bootcamp should give you a good\nunderstanding of the underlying structure of the groundstation, and help you get familiar with the code.\n\n\nAfterwords, talk to the responsible team lead, and they will assign you a task on \nasana\n.\n\n\nBranches\n\n\nIf you are working on a feature or adding anything to the groundstation, \nbranch off of master\n first, and then start working on your task.\n\nDO NOT WORK ON MASTER\n. You are making your life harder if you do so, since you'll have to transfer your changes to a different branch before\nyou can make a pull request.\n\n\nPlease name your branches in the following format: \n{type_of_change}-{your_name}-{title_of_task}\n\n\ntype_of_change\n is either a \nfeature\n or a \nbug\n, depending on the context of your task. For \ntitle_of_task\n, just name it something relevant.\nAs an example, say a really cool developer named Serge is working on adding a PID graph to the groundstation. The branch name would be in the form of:\n\nfeature-serge-pid-graph\n.\n\n\nCoding Conventions\n\n\nVariable names in lower case with underscores as seperators. eg \nthis_is_a_variable\n\n\nFunction names in camel case. For example: \nfunctionNameHere()\n\n\nConstants in all capitals seperated by underscores. eg. \nTHIS_IS_A_CONSTANT\n\n\nModule and class names in capital camel case. For example: \nThisIsAModule\n\n\nFor file names, look at the file names in the folder and follow them. \n\n\nAs a rule of thumb, when in doubt, look at the existing code and follow the same pattern.\n\n\nDocumentating your code\n\n\nMost times your code should be verbose enough that you shouldn't need too many comments. However times may arise when your\nlogic gets too complicated, so use your judgement as a developer and comment your code where you think it is necessary. Imagine\ntrying to read the code you're writing 5 years from now, and think of how easily you'd understand it.\n\n\nNote that if you're creating any sort of function, class, object, or module, \nYOU MUST DOCUMENT IT WITH JSDOC SYNTAX!\n. More information can be found in\nthe \ndocumenting section\n. Your code will not be merged in if this is not done.\n\n\nPull Requests\n\n\nAfter you finish implementing your feature, open up a pull request on github. Let the responsible team lead know and they will code review your changes.\nUntil the pull request is merged in, your task is not complete.\n\n\nYOU MUST OPEN UP PULL REQUESTS. \nNEVER\n PUSH DIRECTLY TO THE MASTER BRANCH ON GITHUB!", 
            "title": "Contributing"
        }, 
        {
            "location": "/groundstation/contributing/#contributing", 
            "text": "In order to contribute to the groundstation you must know how to use git. Check out our tutorial  here  to learn how to use it.\nFollow the guidelines here if you want to contribute to the groundstation.", 
            "title": "Contributing"
        }, 
        {
            "location": "/groundstation/contributing/#getting-yourself-a-task", 
            "text": "In order to qualify yourself to work on the groundstation, you must complete the groundstation bootcamp. The bootcamp should give you a good\nunderstanding of the underlying structure of the groundstation, and help you get familiar with the code.  Afterwords, talk to the responsible team lead, and they will assign you a task on  asana .", 
            "title": "Getting yourself a task"
        }, 
        {
            "location": "/groundstation/contributing/#branches", 
            "text": "If you are working on a feature or adding anything to the groundstation,  branch off of master  first, and then start working on your task. DO NOT WORK ON MASTER . You are making your life harder if you do so, since you'll have to transfer your changes to a different branch before\nyou can make a pull request.  Please name your branches in the following format:  {type_of_change}-{your_name}-{title_of_task}  type_of_change  is either a  feature  or a  bug , depending on the context of your task. For  title_of_task , just name it something relevant.\nAs an example, say a really cool developer named Serge is working on adding a PID graph to the groundstation. The branch name would be in the form of: feature-serge-pid-graph .", 
            "title": "Branches"
        }, 
        {
            "location": "/groundstation/contributing/#coding-conventions", 
            "text": "Variable names in lower case with underscores as seperators. eg  this_is_a_variable  Function names in camel case. For example:  functionNameHere()  Constants in all capitals seperated by underscores. eg.  THIS_IS_A_CONSTANT  Module and class names in capital camel case. For example:  ThisIsAModule  For file names, look at the file names in the folder and follow them.   As a rule of thumb, when in doubt, look at the existing code and follow the same pattern.", 
            "title": "Coding Conventions"
        }, 
        {
            "location": "/groundstation/contributing/#documentating-your-code", 
            "text": "Most times your code should be verbose enough that you shouldn't need too many comments. However times may arise when your\nlogic gets too complicated, so use your judgement as a developer and comment your code where you think it is necessary. Imagine\ntrying to read the code you're writing 5 years from now, and think of how easily you'd understand it.  Note that if you're creating any sort of function, class, object, or module,  YOU MUST DOCUMENT IT WITH JSDOC SYNTAX! . More information can be found in\nthe  documenting section . Your code will not be merged in if this is not done.", 
            "title": "Documentating your code"
        }, 
        {
            "location": "/groundstation/contributing/#pull-requests", 
            "text": "After you finish implementing your feature, open up a pull request on github. Let the responsible team lead know and they will code review your changes.\nUntil the pull request is merged in, your task is not complete.  YOU MUST OPEN UP PULL REQUESTS.  NEVER  PUSH DIRECTLY TO THE MASTER BRANCH ON GITHUB!", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/groundstation/documenting/", 
            "text": "Documenting\n\n\nThe ground station uses \njsdocs\n for its documentation purposes.\n\n\nIf you're familiar with JavaDoc or PHPDoc, then its very similar. Essentially you add comments\nto your code using a double star comment in the form of \n/** your comment */\n and the jsdoc \ninterpreter generates nice well-described documentation based on your source code files.\n\n\nA good tutorial of what it is, why we use it, and how to use it can be found here: \nhttp://speakingjs.com/es5/ch29.html\n.\n\n\nYou are required to document the necessary part of your code with this format.\n\n\nJSDoc Reference\n\n\n\n\n\n\n\n\nBlock\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@abstract\n\u02d9(synonyms: @virtual)\n\n\nThis member must be implemented (or overridden) by the inheritor.\n\n\n\n\n\n\n@author\n\n\nIdentify the author of an item.\n\n\n\n\n\n\n@callback\n\n\nDocument a callback function.\n\n\n\n\n\n\n@class\n (synonyms: @constructor)\n\n\nThis function is intended to be called with the \"new\" keyword.\n\n\n\n\n\n\n@classdesc\n\n\nUse the following text to describe the entire class.\n\n\n\n\n\n\n@constant\n (synonyms: @const)\n\n\nDocument an object as a constant.\n\n\n\n\n\n\n@constructs\n\n\nThis function member will be the constructor for the previous class.\n\n\n\n\n\n\n@copyright\n\n\nDocument some copyright information.\n\n\n\n\n\n\n@default\n (synonyms: @defaultvalue)\n\n\nDocument the default value.\n\n\n\n\n\n\n@deprecated\n\n\nDocument that this is no longer the preferred way.\n\n\n\n\n\n\n@description\n (synonyms: @desc)\n\n\nDescribe a symbol.\n\n\n\n\n\n\n@enum\n\n\nDocument a collection of related properties.\n\n\n\n\n\n\n@event\n\n\nDocument an event.\n\n\n\n\n\n\n@example\n\n\nProvide an example of how to use a documented item.\n\n\n\n\n\n\n@exports\n\n\nIdentify the member that is exported by a JavaScript module.\n\n\n\n\n\n\n@external\n (synonyms: @host)\n\n\nIdentifies an external class or module.\n\n\n\n\n\n\n@file\n (synonyms: @fileoverview or @overview)\n\n\nDescribe a file.\n\n\n\n\n\n\n@fires\n (synonyms: @emits)\n\n\nDescribe the events this method may fire.\n\n\n\n\n\n\n@function\n (synonyms: @funco or @method)\n\n\nDescribe a function or method.\n\n\n\n\n\n\n@global\n\n\nDocument a global object.\n\n\n\n\n\n\n@ignore\n\n\nOmit a symbol from the documentation.\n\n\n\n\n\n\n@implements\n\n\nThis symbol implements an interface.\n\n\n\n\n\n\n@inheritdoc\n\n\nIndicate that a symbol should inherit its parent's documentation.\n\n\n\n\n\n\n@instance\n\n\nDocument an instance member.\n\n\n\n\n\n\n@interface\n\n\nThis symbol is an interface that others can implement.\n\n\n\n\n\n\n@lends\n\n\nDocument properties on an object literal as if they belonged to a symbol with a given name.\n\n\n\n\n\n\n@license\n\n\nIdentify the license that applies to this code.\n\n\n\n\n\n\n@listens\n\n\nList the events that a symbol listens for.\n\n\n\n\n\n\n@member\n (synonyms: @var)\n\n\nDocument a member.\n\n\n\n\n\n\n@mixin\n\n\nDocument a mixin object.\n\n\n\n\n\n\n@module\n\n\nDocument a JavaScript module.\n\n\n\n\n\n\n@name\n\n\nDocument the name of an object.\n\n\n\n\n\n\n@namespace\n\n\nDocument a namespace object.\n\n\n\n\n\n\n@override\n\n\nIndicate that a symbol overrides its parent.\n\n\n\n\n\n\n@param\n (synonyms: @arg or @argument)\n\n\nDocument the parameter to a function.\n\n\n\n\n\n\n@property\n (synonyms: @prop)\n\n\nDocument a property of an object.\n\n\n\n\n\n\n@protected\n\n\nThis symbol is meant to be protected.\n\n\n\n\n\n\n@public\n\n\nThis symbol is meant to be public.\n\n\n\n\n\n\n@readonly\n\n\nThis symbol is meant to be read-only.\n\n\n\n\n\n\n@requires\n\n\nThis file requires a JavaScript module.\n\n\n\n\n\n\n@returns\n (synonyms: @return)\n\n\nDocument the return value of a function.\n\n\n\n\n\n\n@see\n\n\nRefer to some other documentation for more information.\n\n\n\n\n\n\n@static\n\n\nDocument a static member.\n\n\n\n\n\n\n@summary\n\n\nA shorter version of the full description.\n\n\n\n\n\n\n@this\n\n\nWhat does the 'this' keyword refer to here?\n\n\n\n\n\n\n@throws\n (synonyms: @exception)\n\n\nDescribe what errors could be thrown.\n\n\n\n\n\n\n@todo\n\n\nDocument tasks to be completed.\n\n\n\n\n\n\n@tutorial\n\n\nInsert a link to an included tutorial file.\n\n\n\n\n\n\n@type\n\n\nDocument the type of an object.\n\n\n\n\n\n\n@typedef\n\n\nDocument a custom type.", 
            "title": "Documenting"
        }, 
        {
            "location": "/groundstation/documenting/#documenting", 
            "text": "The ground station uses  jsdocs  for its documentation purposes.  If you're familiar with JavaDoc or PHPDoc, then its very similar. Essentially you add comments\nto your code using a double star comment in the form of  /** your comment */  and the jsdoc \ninterpreter generates nice well-described documentation based on your source code files.  A good tutorial of what it is, why we use it, and how to use it can be found here:  http://speakingjs.com/es5/ch29.html .  You are required to document the necessary part of your code with this format.", 
            "title": "Documenting"
        }, 
        {
            "location": "/groundstation/documenting/#jsdoc-reference", 
            "text": "Block  Description      @abstract \u02d9(synonyms: @virtual)  This member must be implemented (or overridden) by the inheritor.    @author  Identify the author of an item.    @callback  Document a callback function.    @class  (synonyms: @constructor)  This function is intended to be called with the \"new\" keyword.    @classdesc  Use the following text to describe the entire class.    @constant  (synonyms: @const)  Document an object as a constant.    @constructs  This function member will be the constructor for the previous class.    @copyright  Document some copyright information.    @default  (synonyms: @defaultvalue)  Document the default value.    @deprecated  Document that this is no longer the preferred way.    @description  (synonyms: @desc)  Describe a symbol.    @enum  Document a collection of related properties.    @event  Document an event.    @example  Provide an example of how to use a documented item.    @exports  Identify the member that is exported by a JavaScript module.    @external  (synonyms: @host)  Identifies an external class or module.    @file  (synonyms: @fileoverview or @overview)  Describe a file.    @fires  (synonyms: @emits)  Describe the events this method may fire.    @function  (synonyms: @funco or @method)  Describe a function or method.    @global  Document a global object.    @ignore  Omit a symbol from the documentation.    @implements  This symbol implements an interface.    @inheritdoc  Indicate that a symbol should inherit its parent's documentation.    @instance  Document an instance member.    @interface  This symbol is an interface that others can implement.    @lends  Document properties on an object literal as if they belonged to a symbol with a given name.    @license  Identify the license that applies to this code.    @listens  List the events that a symbol listens for.    @member  (synonyms: @var)  Document a member.    @mixin  Document a mixin object.    @module  Document a JavaScript module.    @name  Document the name of an object.    @namespace  Document a namespace object.    @override  Indicate that a symbol overrides its parent.    @param  (synonyms: @arg or @argument)  Document the parameter to a function.    @property  (synonyms: @prop)  Document a property of an object.    @protected  This symbol is meant to be protected.    @public  This symbol is meant to be public.    @readonly  This symbol is meant to be read-only.    @requires  This file requires a JavaScript module.    @returns  (synonyms: @return)  Document the return value of a function.    @see  Refer to some other documentation for more information.    @static  Document a static member.    @summary  A shorter version of the full description.    @this  What does the 'this' keyword refer to here?    @throws  (synonyms: @exception)  Describe what errors could be thrown.    @todo  Document tasks to be completed.    @tutorial  Insert a link to an included tutorial file.    @type  Document the type of an object.    @typedef  Document a custom type.", 
            "title": "JSDoc Reference"
        }, 
        {
            "location": "/groundstation/resources/", 
            "text": "Additional Resources\n\n\nThe following is a list of helpful resources that you can use in case you get stuck:\n\n\nDocumentation:\n\n\n\n\nJavascript Documentation\n\n\nNW.js Documentation\n\n\nNode.js Documentation\n\n\nMarionette Documentation\n\n\nBackbone Documentation\n\n\nUnderscore Documentation\n\n\nJquery Documentation\n\n\n\n\nTutorials\n\n\n\n\nCodeAcademy Javascript course\n\n\nCodeAcademy HTML \n CSS course\n\n\nCodeAcademy jQuery course\n\n\n\n\nHelp\n\n\nTheres a huge community around javascript and node.js. 99% of the issues you'll encounter you can resolve by a simple google or stack overflow search.\n\n\nCommon problems\n\n\nQ: A module or library or something is complaining about \nwindow\n or \ndocument\n being undefined.\n\n\nA: \nRead this section about NW.js contexts\n\n\nTips\n\n\n\n\nIf you're using windows and want a much better terminal, use \ncmder\n\n\nIf you want to consolidate all of the documentation sources together, there's a really good site called \nDevDocs.io", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/groundstation/resources/#additional-resources", 
            "text": "The following is a list of helpful resources that you can use in case you get stuck:", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/groundstation/resources/#documentation", 
            "text": "Javascript Documentation  NW.js Documentation  Node.js Documentation  Marionette Documentation  Backbone Documentation  Underscore Documentation  Jquery Documentation", 
            "title": "Documentation:"
        }, 
        {
            "location": "/groundstation/resources/#tutorials", 
            "text": "CodeAcademy Javascript course  CodeAcademy HTML   CSS course  CodeAcademy jQuery course", 
            "title": "Tutorials"
        }, 
        {
            "location": "/groundstation/resources/#help", 
            "text": "Theres a huge community around javascript and node.js. 99% of the issues you'll encounter you can resolve by a simple google or stack overflow search.", 
            "title": "Help"
        }, 
        {
            "location": "/groundstation/resources/#common-problems", 
            "text": "Q: A module or library or something is complaining about  window  or  document  being undefined.  A:  Read this section about NW.js contexts", 
            "title": "Common problems"
        }, 
        {
            "location": "/groundstation/resources/#tips", 
            "text": "If you're using windows and want a much better terminal, use  cmder  If you want to consolidate all of the documentation sources together, there's a really good site called  DevDocs.io", 
            "title": "Tips"
        }, 
        {
            "location": "/zeropilot/", 
            "text": "ZeroPilot Table of Contents\n\n\n\n\nPinout Reference\n\n\nHardware\n\n\nSoftware documentation coming soon", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/zeropilot/#zeropilot-table-of-contents", 
            "text": "Pinout Reference  Hardware  Software documentation coming soon", 
            "title": "ZeroPilot Table of Contents"
        }, 
        {
            "location": "/zeropilot/pinout_reference/", 
            "text": "ZeroPilot Pinout Reference\n\n\nTODO: make reference for connections to sensors and such and show the pin order for each connector", 
            "title": "Pinout Reference"
        }, 
        {
            "location": "/zeropilot/pinout_reference/#zeropilot-pinout-reference", 
            "text": "TODO: make reference for connections to sensors and such and show the pin order for each connector", 
            "title": "ZeroPilot Pinout Reference"
        }, 
        {
            "location": "/zeropilot/hardware/", 
            "text": "ZeroPilot Hardware\n\n\nIntroduction\n\n\nThe Zeropilot is WARG's autopilot platform using a custom PCB and firmware. The ZeroPilot has 2 processors on board. The first one, an STM32F7 chip, is the main autopilot processing unit. It controls both low level and high level control, including PID loops, navigation control, and sensor communication. The secondary chip is a STM32F0 chip called the safety controller, which translates the receiver's PPM to PWM, and then transmits it to the main autopilot unit using I2C or SPI. It also controls the autopilot's failsafe mode, and passes the PPM straight to the PWM output so that the pilot has full control of the UAV in case of firmware bugs.\n\n\nThe ZeroPilot schematic and PCB are created using KiCad and can be found on \nWARG's Github\n.\n\n\nPCB Overview\n\n\nBelow is an overview of the sections of the PCB:\n\n\n\n\nStackup\n\n\nThe ZeroPilot is a 4 layer board. This makes routing the PCB much easier and allows the PCB to be smaller. Each layer has a designated purpose and they are connected through small plated through holes known as vias.\n\n\nLayer 1 (Top layer)\n\n\nThis layer has all the components on it including the 2 processors, power circuitry, and molex-SPOX connectors. Routing on here is minimal and is limited to critical routing for components listed below.\n\n\n\n\nDecoupling capacitors are routed on the top layer since they need to directly be connected to VCC and GND as close as possible. These capacitors smooth out the voltage into the processor and ensure there is no stray AC noise in the 3.3V power supply. There is 1 decoupling capacitor for each VCC pin.\n\n\nCrystals are routed on the top layer because the traces must remain short in order to produce a consisent and predictable frequency. Longer traces cause stray capacitance which can affect the frequency of the oscilation. It is also important that the crystals have a good ground pour surrounding them to prevent excess RF energy to be released and affect other components.\n\n\nSwitching power supplies are routed on the top layer since there is a lot of AC current caused by the 2 buck regulators. Switching regulators quickly turn on and off a switch to let current flow through the inductor, causing a consistent voltage. The feedback pin of the buck regulator allows it monitor the output voltage and change the amount of time the switch is on (its duty cycle) so that the output voltage is constant. This high frequency switching can cause a lot of RF noise, so keeping this routing on one layer helps reduce any stray RF energy.\n\n\n\n\nLayer 2\n\n\nThis layer is where most of the routing is done. There are a few important things to note when routing on this layer:\n\n\n\n\nDo not route underneath any of the 4 crystals. Layer 2 is not shielded from the RF energy of the crystals, so it can induce noise in the signal lines and corrupt communication busses.\n\n\nMake sure there are no large gaps with no copper. When the 4 layers are laminated together in the PCB fabrication process, large gaps of copper can cause the layers above to sag and deform.\n\n\nFor debugging purposes, it is helpful not to run the complete trace on layer 2. If part of the trace is routed on layer 1 or 4, those traces can be cut if there is an issue with it. If the trace is completely on layer 2 then there is no way to break the trace. However, this isn't a high priority\n\n\n\n\nLayer 3\n\n\nThis layer is the ground plane. It makes sure all the circuitry has the same ground. Any ground pin of ICs should have a via to connect the chip to this layer and should be near the ground pin of the chip. There are a couple things to note about routing on this layer:\n\n\n\n\nThere should be no routing done on this layer.\n\n\nNever route on this layer\n\n\nMake sure there isn't a single trace on this layer or else you will be shamed and exiled from WARG (not actually).\n\n\n\n\nLayer 4 (Bottom layer)\n\n\nThis layer is used for power planes and some various components. Reserving a layer for power makes routing significantly easier and minimizes resistances in the power traces.\n\n\n\n\nMake sure there are no thin spots in the power planes. Bottlenecks cause high resistance and can cause voltages to be different in different parts of the power planes\n\n\nSome components can be placed here, but they must have low Z-height so that it is easy to mount on a surface.\n\n\nMinimize components on this layer. Due to the SMD reflow process, all components on this side must be done by hand. Only put selective components on this layer when they might not always be used or are easy to solder by hand.\n\n\n\n\nPower\n\n\nThe ZeroPilot has 3 voltage regulators to power all the ICs and peripherals.\n\n\n5V External\n\n\nThe 5V external power supply powers PWM and PPM. This is because these connections have a high risk of being shorted. PWMs are not shrouded or keyed connections, so they can be connected backwards or shifted. Separating 5V external and 5V interal power supplies allows increased safety and redundancy to prevent brown-outs on the processors.\n\n\nThe 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V interal. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.\n\n\nthe PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.\n\n\n5V Internal\n\n\nThe 5V internal power supply powers the communication headers (I2C, SPI, UART), the speaker, and the 3.3V supply. It is more safe than the 5V external supply since it is routed to interal circuitry or to shrouded and keyed connectors.\n\n\nThe 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V external. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.\n\n\nthe PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.\n\n\n3.3V\n\n\nThe 3.3V power supply is a linear regulator (LDO). It power both processors, microSD card, and flash memory.\n\n\nUsing and LDO enables a smoother output voltage and smaller footprint at the cost of less efficiency. The regulator is powered off of 5V internal supply and converts the 5V down to 3.3V. LDOs are inefficient because input current = output current. This means that is it is supplying 20mA at 3.3V, the input current will be 20mA at 5V.\n\n\nSchematic Conventions\n\n\nTo make sure the schematic looks clean and consistent, we have standardized convetions for schematic design.\n\n\n\n\nKeep as much circuitry off of the main page as possible. KiCad works in hierarchical structure, so the main page should essentially be a block diagram to show how the schematic is structured\n\n\nUse busses for cleanliness. It is possible to just put net names for everything and the schematic can be connected that way. However, this is very hard to read and follow where everything is going. If the distance is short, just use lines to connect the pins together. If there are multiple similar signals (such as UART), group them into a bus so that it is visually obvious where else it connects to. It is acceptable for power to be connected only via net names.\n\n\nMake sure the schematic flows left to right. Because of how we read english, we look at the schematic from left to right. This means that all inputs should be on the left side, and all outputs should be on the right side. For example, the power circuit should always be on the left side of the schematic since it is the input for the system. PWMs are on the right since that is the final output for the system.\n\n\nMake sure to use standard WARG or KiCad attribute names. If you need a specific attribute on a part, add its name here for reference.\n\n\n\n\n-part_num: WARG's unique part number that maps to the component library\n-no_load: This parameter should be used if a component isn't always be soldered onto the board. Use the value \nNO LOAD\n to indicate this.\n\n\n\n\nWhen you fabricate a board, make a Github release and attached the gerber files to it. This makes it easy to track what is being fabricated. Do the same for the WARG-KiCad library when you order the components for the board, and attach the bill of materials to the release.\n\n\nUse common sense. Make the schematic look clean and understandable, even if it means taking a couple hours after a schematic change to make it look nice. Having an easy to understand schematic will make debugging the PCB and schematic issues a much more pleasant experience.", 
            "title": "Hardware"
        }, 
        {
            "location": "/zeropilot/hardware/#zeropilot-hardware", 
            "text": "", 
            "title": "ZeroPilot Hardware"
        }, 
        {
            "location": "/zeropilot/hardware/#introduction", 
            "text": "The Zeropilot is WARG's autopilot platform using a custom PCB and firmware. The ZeroPilot has 2 processors on board. The first one, an STM32F7 chip, is the main autopilot processing unit. It controls both low level and high level control, including PID loops, navigation control, and sensor communication. The secondary chip is a STM32F0 chip called the safety controller, which translates the receiver's PPM to PWM, and then transmits it to the main autopilot unit using I2C or SPI. It also controls the autopilot's failsafe mode, and passes the PPM straight to the PWM output so that the pilot has full control of the UAV in case of firmware bugs.  The ZeroPilot schematic and PCB are created using KiCad and can be found on  WARG's Github .", 
            "title": "Introduction"
        }, 
        {
            "location": "/zeropilot/hardware/#pcb-overview", 
            "text": "Below is an overview of the sections of the PCB:", 
            "title": "PCB Overview"
        }, 
        {
            "location": "/zeropilot/hardware/#stackup", 
            "text": "The ZeroPilot is a 4 layer board. This makes routing the PCB much easier and allows the PCB to be smaller. Each layer has a designated purpose and they are connected through small plated through holes known as vias.", 
            "title": "Stackup"
        }, 
        {
            "location": "/zeropilot/hardware/#layer-1-top-layer", 
            "text": "This layer has all the components on it including the 2 processors, power circuitry, and molex-SPOX connectors. Routing on here is minimal and is limited to critical routing for components listed below.   Decoupling capacitors are routed on the top layer since they need to directly be connected to VCC and GND as close as possible. These capacitors smooth out the voltage into the processor and ensure there is no stray AC noise in the 3.3V power supply. There is 1 decoupling capacitor for each VCC pin.  Crystals are routed on the top layer because the traces must remain short in order to produce a consisent and predictable frequency. Longer traces cause stray capacitance which can affect the frequency of the oscilation. It is also important that the crystals have a good ground pour surrounding them to prevent excess RF energy to be released and affect other components.  Switching power supplies are routed on the top layer since there is a lot of AC current caused by the 2 buck regulators. Switching regulators quickly turn on and off a switch to let current flow through the inductor, causing a consistent voltage. The feedback pin of the buck regulator allows it monitor the output voltage and change the amount of time the switch is on (its duty cycle) so that the output voltage is constant. This high frequency switching can cause a lot of RF noise, so keeping this routing on one layer helps reduce any stray RF energy.", 
            "title": "Layer 1 (Top layer)"
        }, 
        {
            "location": "/zeropilot/hardware/#layer-2", 
            "text": "This layer is where most of the routing is done. There are a few important things to note when routing on this layer:   Do not route underneath any of the 4 crystals. Layer 2 is not shielded from the RF energy of the crystals, so it can induce noise in the signal lines and corrupt communication busses.  Make sure there are no large gaps with no copper. When the 4 layers are laminated together in the PCB fabrication process, large gaps of copper can cause the layers above to sag and deform.  For debugging purposes, it is helpful not to run the complete trace on layer 2. If part of the trace is routed on layer 1 or 4, those traces can be cut if there is an issue with it. If the trace is completely on layer 2 then there is no way to break the trace. However, this isn't a high priority", 
            "title": "Layer 2"
        }, 
        {
            "location": "/zeropilot/hardware/#layer-3", 
            "text": "This layer is the ground plane. It makes sure all the circuitry has the same ground. Any ground pin of ICs should have a via to connect the chip to this layer and should be near the ground pin of the chip. There are a couple things to note about routing on this layer:   There should be no routing done on this layer.  Never route on this layer  Make sure there isn't a single trace on this layer or else you will be shamed and exiled from WARG (not actually).", 
            "title": "Layer 3"
        }, 
        {
            "location": "/zeropilot/hardware/#layer-4-bottom-layer", 
            "text": "This layer is used for power planes and some various components. Reserving a layer for power makes routing significantly easier and minimizes resistances in the power traces.   Make sure there are no thin spots in the power planes. Bottlenecks cause high resistance and can cause voltages to be different in different parts of the power planes  Some components can be placed here, but they must have low Z-height so that it is easy to mount on a surface.  Minimize components on this layer. Due to the SMD reflow process, all components on this side must be done by hand. Only put selective components on this layer when they might not always be used or are easy to solder by hand.", 
            "title": "Layer 4 (Bottom layer)"
        }, 
        {
            "location": "/zeropilot/hardware/#power", 
            "text": "The ZeroPilot has 3 voltage regulators to power all the ICs and peripherals.", 
            "title": "Power"
        }, 
        {
            "location": "/zeropilot/hardware/#5v-external", 
            "text": "The 5V external power supply powers PWM and PPM. This is because these connections have a high risk of being shorted. PWMs are not shrouded or keyed connections, so they can be connected backwards or shifted. Separating 5V external and 5V interal power supplies allows increased safety and redundancy to prevent brown-outs on the processors.  The 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V interal. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.  the PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.", 
            "title": "5V External"
        }, 
        {
            "location": "/zeropilot/hardware/#5v-internal", 
            "text": "The 5V internal power supply powers the communication headers (I2C, SPI, UART), the speaker, and the 3.3V supply. It is more safe than the 5V external supply since it is routed to interal circuitry or to shrouded and keyed connectors.  The 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V external. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.  the PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.", 
            "title": "5V Internal"
        }, 
        {
            "location": "/zeropilot/hardware/#33v", 
            "text": "The 3.3V power supply is a linear regulator (LDO). It power both processors, microSD card, and flash memory.  Using and LDO enables a smoother output voltage and smaller footprint at the cost of less efficiency. The regulator is powered off of 5V internal supply and converts the 5V down to 3.3V. LDOs are inefficient because input current = output current. This means that is it is supplying 20mA at 3.3V, the input current will be 20mA at 5V.", 
            "title": "3.3V"
        }, 
        {
            "location": "/zeropilot/hardware/#schematic-conventions", 
            "text": "To make sure the schematic looks clean and consistent, we have standardized convetions for schematic design.   Keep as much circuitry off of the main page as possible. KiCad works in hierarchical structure, so the main page should essentially be a block diagram to show how the schematic is structured  Use busses for cleanliness. It is possible to just put net names for everything and the schematic can be connected that way. However, this is very hard to read and follow where everything is going. If the distance is short, just use lines to connect the pins together. If there are multiple similar signals (such as UART), group them into a bus so that it is visually obvious where else it connects to. It is acceptable for power to be connected only via net names.  Make sure the schematic flows left to right. Because of how we read english, we look at the schematic from left to right. This means that all inputs should be on the left side, and all outputs should be on the right side. For example, the power circuit should always be on the left side of the schematic since it is the input for the system. PWMs are on the right since that is the final output for the system.  Make sure to use standard WARG or KiCad attribute names. If you need a specific attribute on a part, add its name here for reference.   -part_num: WARG's unique part number that maps to the component library\n-no_load: This parameter should be used if a component isn't always be soldered onto the board. Use the value  NO LOAD  to indicate this.   When you fabricate a board, make a Github release and attached the gerber files to it. This makes it easy to track what is being fabricated. Do the same for the WARG-KiCad library when you order the components for the board, and attach the bill of materials to the release.  Use common sense. Make the schematic look clean and understandable, even if it means taking a couple hours after a schematic change to make it look nice. Having an easy to understand schematic will make debugging the PCB and schematic issues a much more pleasant experience.", 
            "title": "Schematic Conventions"
        }, 
        {
            "location": "/computer-vision/", 
            "text": "Welcome to the Computer Vision Docs!\n\n\nContents\n\n\n\n\nBuilding the project - Linux\n\n\nBuilding the project - Windows\n\n\nCoding Conventions\n\n\nUsing the WARG Server Environment\n\n\nContributing\n\n\nWriting Tests\n\n\n\n\nInstallation\n\n\nThe installation process depends on what system you have. WARG-CV runs on Linux. However, in case you don\u2019t have Linux, we have premade a DockerFile, so that you can setup a virtual image on any system.\nYou may be able to get the project to compile on Mac OS X, but that is up to you to figure out.\n\n\nIf you don't have a Linux environment, don't worry! You can download a docker image. It is essentially a premade virtual machine.\n\n\n\n\nGo to \nhttps://docs.docker.com/mac/\n for Mac systems\n\n\nGo to \nhttps://docs.docker.com/windows/\n for Windows systems.\n\n\n\n\nOnce docker is installed you can get our docker image by running \ndocker pull uwarg/warg-cv\n\n\nAfter the image has been fetched:\n\n\n\n\ndocker create -it --name cv uwarg/warg-cv\n to create a new container using the warg-cv image called cv\n\n\ndocker exec -it cv bash\n to enter the container\n\n\n\n\nWhen you want to use the container again in future, use docker exec (as in step 2 above). There is no need to create a new container unless the image has changed.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/computer-vision/#welcome-to-the-computer-vision-docs", 
            "text": "", 
            "title": "Welcome to the Computer Vision Docs!"
        }, 
        {
            "location": "/computer-vision/#contents", 
            "text": "Building the project - Linux  Building the project - Windows  Coding Conventions  Using the WARG Server Environment  Contributing  Writing Tests", 
            "title": "Contents"
        }, 
        {
            "location": "/computer-vision/#installation", 
            "text": "The installation process depends on what system you have. WARG-CV runs on Linux. However, in case you don\u2019t have Linux, we have premade a DockerFile, so that you can setup a virtual image on any system.\nYou may be able to get the project to compile on Mac OS X, but that is up to you to figure out.  If you don't have a Linux environment, don't worry! You can download a docker image. It is essentially a premade virtual machine.   Go to  https://docs.docker.com/mac/  for Mac systems  Go to  https://docs.docker.com/windows/  for Windows systems.   Once docker is installed you can get our docker image by running  docker pull uwarg/warg-cv  After the image has been fetched:   docker create -it --name cv uwarg/warg-cv  to create a new container using the warg-cv image called cv  docker exec -it cv bash  to enter the container   When you want to use the container again in future, use docker exec (as in step 2 above). There is no need to create a new container unless the image has changed.", 
            "title": "Installation"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/", 
            "text": "Building the Project\n\n\n1. Install Dependencies\n\n\nDependencies:\n- OpenCV - 3.x (2.x.x is no longer supported)\n- Boost - Tested with 1.56-60, should work with earlier versions\n- ZBar\n- DecklinkSDK (Optional, if available builds support for reading video from Decklink video capture cards)\n- Exiv2\n\n\n2. Clone the Repo\n\n\ngit clone https://github.com/UWARG/computer-vision.git\n\n\n\n\nIf you want to be able to submit changes you should fork the repository first and then clone your fork\n\n\ngit clone https://github.com/YOUR_NAME_HERE/computer-vision.git\n\n\n\n\n3. Configure the project with CMake\n\n\nIt is recommended to build from a separate directory to keep the source tree clean\n\n\ncd computer vision\nmkdir build\ncd build\ncmake ..\n\n\n\n\n4. Build\n\n\nmake\n\n\n\n\nBuilding individual modules\nOnce the project is configured\n\n\nmake MODULE_NAME\n\n\n\n\nFor a list of build targets including Submodules\n\n\nmake help\n\n\n\n\nRunning tests\n\n\nmake test", 
            "title": "Building the project [Linux]"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#building-the-project", 
            "text": "", 
            "title": "Building the Project"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#1-install-dependencies", 
            "text": "Dependencies:\n- OpenCV - 3.x (2.x.x is no longer supported)\n- Boost - Tested with 1.56-60, should work with earlier versions\n- ZBar\n- DecklinkSDK (Optional, if available builds support for reading video from Decklink video capture cards)\n- Exiv2", 
            "title": "1. Install Dependencies"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#2-clone-the-repo", 
            "text": "git clone https://github.com/UWARG/computer-vision.git  If you want to be able to submit changes you should fork the repository first and then clone your fork  git clone https://github.com/YOUR_NAME_HERE/computer-vision.git", 
            "title": "2. Clone the Repo"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#3-configure-the-project-with-cmake", 
            "text": "It is recommended to build from a separate directory to keep the source tree clean  cd computer vision\nmkdir build\ncd build\ncmake ..", 
            "title": "3. Configure the project with CMake"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#4-build", 
            "text": "make  Building individual modules\nOnce the project is configured  make MODULE_NAME  For a list of build targets including Submodules  make help  Running tests  make test", 
            "title": "4. Build"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Windows]/", 
            "text": "Building the project\n\n\nTODO: Anyone who wants to try doing this, please fill this out", 
            "title": "Building the project [Windows]"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Windows]/#building-the-project", 
            "text": "TODO: Anyone who wants to try doing this, please fill this out", 
            "title": "Building the project"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/", 
            "text": "Coding Conventions\n\n\nCode\n\n\nVariable Names:\n\n\nvarName\n\n\nConstant Names:\n\n\nCONST_NAME\n\n\nFunction Names:\n\n\nfunction_name\n\n\nClass Names:\n\n\nClassName\n\n\nIndentation:\n\n\n4 spaces per level of indentation\n\n\nbrackets:\n\n\nvoid foo_bar(int i) {\n    int varName = (i + 2)/2;\n}\n\n\n\n\nFile Structure\n\n\nFile Names:\n\n\nfile_name.ext\n\n\nDirectory Structure:\n\n\n|-- computer-vision\n    |-- modules\n        |-- core\n            |-- include\n                |-- header.h\n            |-- src\n                |-- source.cpp\n            |-- CMakeLists.txt\n    |-- CMakeLists.txt\n    |-- main.cpp\n         ...\n\n\n\n\nHeader File Formatting\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \nbar.h\n\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED\n\n\n\n\nSource file formatting\n\n\n/*\n * This file is part of WARG's computer-vision\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \nbar.h\n\n#include \nfoo.h\n\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}", 
            "title": "Coding Conventions"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#coding-conventions", 
            "text": "", 
            "title": "Coding Conventions"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#variable-names", 
            "text": "varName", 
            "title": "Variable Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#constant-names", 
            "text": "CONST_NAME", 
            "title": "Constant Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#function-names", 
            "text": "function_name", 
            "title": "Function Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#class-names", 
            "text": "ClassName", 
            "title": "Class Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#indentation", 
            "text": "4 spaces per level of indentation", 
            "title": "Indentation:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#brackets", 
            "text": "void foo_bar(int i) {\n    int varName = (i + 2)/2;\n}", 
            "title": "brackets:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#file-structure", 
            "text": "", 
            "title": "File Structure"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#file-names", 
            "text": "file_name.ext", 
            "title": "File Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#directory-structure", 
            "text": "|-- computer-vision\n    |-- modules\n        |-- core\n            |-- include\n                |-- header.h\n            |-- src\n                |-- source.cpp\n            |-- CMakeLists.txt\n    |-- CMakeLists.txt\n    |-- main.cpp\n         ...", 
            "title": "Directory Structure:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#header-file-formatting", 
            "text": "/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include  bar.h \n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED", 
            "title": "Header File Formatting"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#source-file-formatting", 
            "text": "/*\n * This file is part of WARG's computer-vision\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include  bar.h \n#include  foo.h \n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}", 
            "title": "Source file formatting"
        }, 
        {
            "location": "/computer-vision/Contributing/", 
            "text": "Contributing\n\n\n\n\nAdding a New Class\n\n\nThe project is divided into modules. Any class that is specific to a certain module should be stored in that module's directory. Classes that need to be accessed by multiple modules should go in Core.\n\n\nThe class should be declared in a header file of the same name as the class and placed in the appropriate module's include directory.\n\n\nFor example: Suppose we are creating class Foo in module Core\n\n\n(See \nCoding Conventions\n for details on formatting)\n\n\nFile: modules/core/include/foo.h\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \nbar.h\n\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED\n\n\n\n\nThe corresponding source file which contains the definitions for the class Foo is placed in the src folder\n\n\nFile: modules/core/src/foo.cpp\n\n\n/**\n * @file foo.cpp\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \nbar.h\n\n#include \nfoo.h\n\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}\n\n\n\n\n\nHowever we're not done yet. While header files when placed in the proper directory are immediately ready for use, source files must be added to the module's CMakeLists.txt file to be compiled into the module.\n\n\nFile: modules/core/CMakeLists.txt\n\n\ninclude_directories(include)\nadd_library(Core src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\n\n\n\n\nYour source file should be added to the arguments of the add_library function (ideally in retaining alphabetical order for readability)\n\n\nBut what if bar is part of an external library?\n\n\nIf you've forgotten what bar is already notice that it is an external class included in foo.h\n\n\nThe first question to answer is whether or not the use of bar can be avoided. In particular it may provide functionality that is already available in one of the project's current dependencies. Unless it provides substantially improved functionality over what is already available it probably shouldn't be added to the project.\n\n\nIf you determine that bar is a necessary dependency, then it needs to be added to CMakeLists.txt as well. As long as it is only being used in one module, it can be defined in that module's CMakeLists.txt rather than the global CMakeLists.txt.\n\n\nFor simplicity we will assume bar.h is part of the package Bar\n\n\nFile: modules/core/CMakeLists.txt\n\n\ninclude_directories(include)\nfind_package(Bar)\nif(Bar_FOUND)\n    include_directories(${Bar_INCLUDE_DIRS})\n    add_library(Core ${Bar_LIBRARIES} src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\nendif()\n\n\n\n\nYou may want to research the library you've added online since many external libraries have additional configuration that needs to be added to the CMakeLists or unusual naming conventions for the package.\n\n\nAnd we're done.\nNow if you re-run cmake and re-build Foo should be built into the project.\n\n\n\n\nContributing to Master Repository\n\n\nTo get your code added to master you will, if you haven't done so already, need to fork the project. This can be done by going to the computer-vision page on GitHub and clicking the fork button in the top right.\n\n\nYou then need to make your local code point your fork rather than master.\n\n\ngit remote set-url origin $FORK_URL\n\n\n\n\nWhere $FORK_URL is the clone link for your fork\n\n\nYou will also want to set a new remote, called upstream, to reference the master repository so that you can pull changes.\n\n\ngit remote add upstream git@github.com:UWARG/computer-vision.git\n\n\n\n\nor for https\n\n\ngit remote add upstream https://github.com/UWARG/computer-vision.git\n\n\n\n\nthis allows upstream changes to be fetched with \ngit fetch upstream\n and merged into the current branch with \ngit merge upstream/branch_name\n\n\nNow, you can commit your code and push to the fork with\n\n\ngit add modules/core/src/foo.cpp modules/core/include/foo.h modules/core/CMakeLists.txt\ngit commit -m \nAdded class Foo\n\ngit push origin\n\n\n\n\nNote that it is recommended to add files individually rather than adding all at once with \ngit add -A .\n\n\nThat way you ensure you only commit the files you intend to add.\nYou can also see a list of all unstaged changes (changes that have yet to be added) using \ngit diff\n\n\nOnce the code is pushed, go to Github to your fork's page and create a pull request by either going into the pull request menu and choosing \"New Pull Request\", or, if you have pushed code recently, a pop-up will appear on the main page prompting you to create a pull request.\n\n\nFrom the pull request page you can add comments to the pull request noting what you have changed, you can review the changed you have made to make sure you haven't included anything unnecessary and then you can submit the request.\n\n\nPlease note that pull requests will be rejected if they contain extraneous changes.\nYou can avoid a lot of issues by configuring git to ignore point out whitespace issues in diffs and to fix when patching with:\n\n\ngit config core.whitespace trailing-space,space-before-tab\ngit config apply.whitespace fix", 
            "title": "Contributing"
        }, 
        {
            "location": "/computer-vision/Contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }, 
        {
            "location": "/computer-vision/Contributing/#adding-a-new-class", 
            "text": "The project is divided into modules. Any class that is specific to a certain module should be stored in that module's directory. Classes that need to be accessed by multiple modules should go in Core.  The class should be declared in a header file of the same name as the class and placed in the appropriate module's include directory.  For example: Suppose we are creating class Foo in module Core  (See  Coding Conventions  for details on formatting)  File: modules/core/include/foo.h  /**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include  bar.h \n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED  The corresponding source file which contains the definitions for the class Foo is placed in the src folder  File: modules/core/src/foo.cpp  /**\n * @file foo.cpp\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include  bar.h \n#include  foo.h \n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}  However we're not done yet. While header files when placed in the proper directory are immediately ready for use, source files must be added to the module's CMakeLists.txt file to be compiled into the module.  File: modules/core/CMakeLists.txt  include_directories(include)\nadd_library(Core src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)  Your source file should be added to the arguments of the add_library function (ideally in retaining alphabetical order for readability)", 
            "title": "Adding a New Class"
        }, 
        {
            "location": "/computer-vision/Contributing/#but-what-if-bar-is-part-of-an-external-library", 
            "text": "If you've forgotten what bar is already notice that it is an external class included in foo.h  The first question to answer is whether or not the use of bar can be avoided. In particular it may provide functionality that is already available in one of the project's current dependencies. Unless it provides substantially improved functionality over what is already available it probably shouldn't be added to the project.  If you determine that bar is a necessary dependency, then it needs to be added to CMakeLists.txt as well. As long as it is only being used in one module, it can be defined in that module's CMakeLists.txt rather than the global CMakeLists.txt.  For simplicity we will assume bar.h is part of the package Bar  File: modules/core/CMakeLists.txt  include_directories(include)\nfind_package(Bar)\nif(Bar_FOUND)\n    include_directories(${Bar_INCLUDE_DIRS})\n    add_library(Core ${Bar_LIBRARIES} src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\nendif()  You may want to research the library you've added online since many external libraries have additional configuration that needs to be added to the CMakeLists or unusual naming conventions for the package.  And we're done.\nNow if you re-run cmake and re-build Foo should be built into the project.", 
            "title": "But what if bar is part of an external library?"
        }, 
        {
            "location": "/computer-vision/Contributing/#contributing-to-master-repository", 
            "text": "To get your code added to master you will, if you haven't done so already, need to fork the project. This can be done by going to the computer-vision page on GitHub and clicking the fork button in the top right.  You then need to make your local code point your fork rather than master.  git remote set-url origin $FORK_URL  Where $FORK_URL is the clone link for your fork  You will also want to set a new remote, called upstream, to reference the master repository so that you can pull changes.  git remote add upstream git@github.com:UWARG/computer-vision.git  or for https  git remote add upstream https://github.com/UWARG/computer-vision.git  this allows upstream changes to be fetched with  git fetch upstream  and merged into the current branch with  git merge upstream/branch_name  Now, you can commit your code and push to the fork with  git add modules/core/src/foo.cpp modules/core/include/foo.h modules/core/CMakeLists.txt\ngit commit -m  Added class Foo \ngit push origin  Note that it is recommended to add files individually rather than adding all at once with  git add -A .  That way you ensure you only commit the files you intend to add.\nYou can also see a list of all unstaged changes (changes that have yet to be added) using  git diff  Once the code is pushed, go to Github to your fork's page and create a pull request by either going into the pull request menu and choosing \"New Pull Request\", or, if you have pushed code recently, a pop-up will appear on the main page prompting you to create a pull request.  From the pull request page you can add comments to the pull request noting what you have changed, you can review the changed you have made to make sure you haven't included anything unnecessary and then you can submit the request.  Please note that pull requests will be rejected if they contain extraneous changes.\nYou can avoid a lot of issues by configuring git to ignore point out whitespace issues in diffs and to fix when patching with:  git config core.whitespace trailing-space,space-before-tab\ngit config apply.whitespace fix", 
            "title": "Contributing to Master Repository"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/", 
            "text": "Using the Warg Computer environment\n\n\n(Note that at the time of this being written the server is still being set up, hence a lot of this guide is both not yet applicable and may change)\n\n\nSetting up an SSH Client\n\n\nBefore you can connect to the WARG Server you will need an SSH client.\n\n\nWindows:\n\n\nThere are several windows SSH clients, one of the more popular ones is PuTTY, which can be downloaded \nhere\n\n\nMac OS X and Linux:\n\n\nSSH should be installed by default and can be accessed by the following terminal command\n\n\nssh user@hostname\n\n\n\n\nGetting an account\n\n\nYou will not be able to connect to the WARG server without an account on the system. You will have to come in personally to the WARG bay to set this up.\n\n\nConnecting to the server\n\n\nTo connect to the WARG server you will need\n\n\nUser:\n     User-name you set up on the WARG server\n\n\nHost-name:\n ip address of the WARG computer\n\n\nPort:\n 22 (The default port, you probably won't need to set this)\n\n\nLinux and OS X\n\n\nOn Linux or OS X this translates to the following command:\n\n\nssh user@ssh.uwarg.com\n\n\n\n\nOptionally you can append -Y to the end of the command to enable graphics forwarding which will allow you to run graphical applications on the server (with the graphics being displayed on your computer)\n\n\nssh user@ssh.uwarg.com -Y\n\n\n\n\nWindows\n\n\nOn Windows, see one of the following tutorials for more info on configuring PuTTY.\n\n\nAn older tutorial that covers the basics\n\n\nhttp://jfitz.com/tips/putty_config.html\n\n\nMore advanced PuTTY usage\n\n\nhttp://support.suso.com/supki/SSH_Tutorial_for_Windows\n\n\nUseful Commands in the Server Environment (feel free to expand this section)\n\n\n(words in ALL_CAPS are arguments)\n\n\nls\n Shows a list of files and directories in your current directory or in a different one by specifying a different directory \nls DIRECTORY\n\n\ncd DIRECTORY\n opens the given directory\n\n\nnano\n Simple command line text editor, can open files with \nnano FILE_NAME\n\n\n(for a more complex editor that is better suited to programming, try \nvim\n or \nemacs\n. \nhere\n is an emacs tutorial and \nhere\n is a vim one. There is also this fun looking interactive vim tutorial \nhere\n)\n\n\nYou can also learn more about any of the commands by appending \n--help\n to a command or by entering \nman COMMAND\n\n\nUseful Graphical Applications\n\n\ngedit\n The Gnome text editor\n\n\nnautilus\n A Linux file manager", 
            "title": "Using the WARG computer environment"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#using-the-warg-computer-environment", 
            "text": "(Note that at the time of this being written the server is still being set up, hence a lot of this guide is both not yet applicable and may change)", 
            "title": "Using the Warg Computer environment"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#setting-up-an-ssh-client", 
            "text": "Before you can connect to the WARG Server you will need an SSH client.", 
            "title": "Setting up an SSH Client"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#windows", 
            "text": "There are several windows SSH clients, one of the more popular ones is PuTTY, which can be downloaded  here", 
            "title": "Windows:"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#mac-os-x-and-linux", 
            "text": "SSH should be installed by default and can be accessed by the following terminal command  ssh user@hostname", 
            "title": "Mac OS X and Linux:"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#getting-an-account", 
            "text": "You will not be able to connect to the WARG server without an account on the system. You will have to come in personally to the WARG bay to set this up.", 
            "title": "Getting an account"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#connecting-to-the-server", 
            "text": "To connect to the WARG server you will need  User:      User-name you set up on the WARG server  Host-name:  ip address of the WARG computer  Port:  22 (The default port, you probably won't need to set this)", 
            "title": "Connecting to the server"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#linux-and-os-x", 
            "text": "On Linux or OS X this translates to the following command:  ssh user@ssh.uwarg.com  Optionally you can append -Y to the end of the command to enable graphics forwarding which will allow you to run graphical applications on the server (with the graphics being displayed on your computer)  ssh user@ssh.uwarg.com -Y", 
            "title": "Linux and OS X"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#windows_1", 
            "text": "On Windows, see one of the following tutorials for more info on configuring PuTTY.  An older tutorial that covers the basics  http://jfitz.com/tips/putty_config.html  More advanced PuTTY usage  http://support.suso.com/supki/SSH_Tutorial_for_Windows", 
            "title": "Windows"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#useful-commands-in-the-server-environment-feel-free-to-expand-this-section", 
            "text": "(words in ALL_CAPS are arguments)  ls  Shows a list of files and directories in your current directory or in a different one by specifying a different directory  ls DIRECTORY  cd DIRECTORY  opens the given directory  nano  Simple command line text editor, can open files with  nano FILE_NAME  (for a more complex editor that is better suited to programming, try  vim  or  emacs .  here  is an emacs tutorial and  here  is a vim one. There is also this fun looking interactive vim tutorial  here )  You can also learn more about any of the commands by appending  --help  to a command or by entering  man COMMAND", 
            "title": "Useful Commands in the Server Environment (feel free to expand this section)"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#useful-graphical-applications", 
            "text": "gedit  The Gnome text editor  nautilus  A Linux file manager", 
            "title": "Useful Graphical Applications"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/", 
            "text": "Writing Tests\n\n\nTesting should be done in a directory inside the submodule called test, which should be included in the module's CMakeLists.txt via add_subdirectory and should have its own CMakeLists.txt.\nFurthermore, large test files should be stored in the global computer-vision/testdata directory so that they can be shared between multiple tests.\nThat is, test directories should have the following structure\n\n\n|-- computer-vision\n    |-- modules\n        |-- MODULE_NAME\n            |-- include\n            |-- src\n            |-- test\n                |-- CMakeLists.txt\n                |-- foo_test.cpp\n                |-- bar_test.cpp\n            |-- CMakeLists.txt\n    |-- testdata\n        |-- image.jpg\n\n\n\n\nTesting should be done using the boost test framework.\n\n\nTutorials provided by boost are found \nhere\n.\n\n\nAPI Reference available \nhere\n\n\nTo test code it should be run inside the \nBOOST_AUTO_TEST_CASE\n and use the boost test macros to verify sanity and results.\nSome available macros include\n\n\nBOOST_WARN(predicate); // produces a warning if predicate is false, does not cause failures\nBOOST_CHECK(predicate); // produces a failure if predicate is false, but continues testing\nBOOST_REQUIRE(predicate); // produces a failure if predicate is false and aborts test suite.\n\n\n\n\nTest heirarchy\n\n\nBoost tests are stored in a heirarchy of nested suites.\nThe global suite for a file can be set with the \nBOOST_TEST_MODULE\n macro.\nYou can define additional suites by encapsulating test cases and suites with \nBOOST_AUTO_TEST_SUITE(SuiteName);\n and \nBOOST_AUTO_TEST_SUITE_END();\n\n\nNote that currently the xsl parser for generating an xUnit compatible XML file does not properly handle nested test suites and only makes use of the suite directly encapsulating the test cases (the suite declared with \nBOOST_TEST_MODULE\n).\nHowever since this is expected to be fixed relatively soon, it is recommended that you use the following format to declare tests.\n\n\nGuidelines for naming test suites and test cases\n\n\nThe global test suite for a file (specified with \nBOOST_TEST_MODULE\n) should correspond to the computer-vision module the tests are part of.\nA test suite should be created for each file with \nBOOST_AUTO_TEST_SUITE\n and should encompass all the tests in the file. Tests contained within a single file should all test a single feature or function of the program. Tests for different features/functions should go in their own file with a separate test suite. The file should also have the same name as the test suite (though test suite names should be camel cased).\n\n\nAdditional test suites can also be created inside test suites at your discretion if a certain suite has a large number of test cases that can be meaningfully subdivided.\n\n\nFor consistency, test suite and test case names should be UpperCamelCase (and test module name should be the full UpperCamelCase version of the module name. e.g. targetid should be TargetIdentification).\n\n\nAlso note that all names should be sufficiently descriptive to be unique in their scope (as well as sufficiently descriptive to convey what is being tested in a particular suite/case). That is, each test suite in a module needs to have a unique name to avoid naming conflicts, but names of test suites inside those suites and names of test cases only need to be unique inside their encapsulating test suite.\n\n\nExample\n\n\nfile: modules/mymodule/test/mysuite.cpp\n\n\n#define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE MyModule\n#include \nboost/test/unit_test.hpp\n\n#include \nfoo.h\n // declares type foo, header is in the core module\n\nBOOST_AUTO_TEST_SUITE(MySuite);\n\nBOOST_AUTO_TEST_CASE(TestName) {\n    foo bar;\n    BOOST_CHECK(foo.baz());\n}\n\nBOOST_AUTO_TEST_SUITE_END();\n\n\n\n\nfile: modules/mymodule/test/CMakeLists.txt\n\n\ninclude_directories(${Core_INCLUDE_DIR})\nadd_executable(mytest test.cpp)\ntarget_link_libraries(mytest Core)\n\n# Tests\nadd_test(\n    NAME \nexample test\n\n    COMMAND mytest --log_format=XML --log_sink=TEST-mytest.xml --log_level=all --report_level=no\n)", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/#writing-tests", 
            "text": "Testing should be done in a directory inside the submodule called test, which should be included in the module's CMakeLists.txt via add_subdirectory and should have its own CMakeLists.txt.\nFurthermore, large test files should be stored in the global computer-vision/testdata directory so that they can be shared between multiple tests.\nThat is, test directories should have the following structure  |-- computer-vision\n    |-- modules\n        |-- MODULE_NAME\n            |-- include\n            |-- src\n            |-- test\n                |-- CMakeLists.txt\n                |-- foo_test.cpp\n                |-- bar_test.cpp\n            |-- CMakeLists.txt\n    |-- testdata\n        |-- image.jpg  Testing should be done using the boost test framework.  Tutorials provided by boost are found  here .  API Reference available  here  To test code it should be run inside the  BOOST_AUTO_TEST_CASE  and use the boost test macros to verify sanity and results.\nSome available macros include  BOOST_WARN(predicate); // produces a warning if predicate is false, does not cause failures\nBOOST_CHECK(predicate); // produces a failure if predicate is false, but continues testing\nBOOST_REQUIRE(predicate); // produces a failure if predicate is false and aborts test suite.", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/#test-heirarchy", 
            "text": "Boost tests are stored in a heirarchy of nested suites.\nThe global suite for a file can be set with the  BOOST_TEST_MODULE  macro.\nYou can define additional suites by encapsulating test cases and suites with  BOOST_AUTO_TEST_SUITE(SuiteName);  and  BOOST_AUTO_TEST_SUITE_END();  Note that currently the xsl parser for generating an xUnit compatible XML file does not properly handle nested test suites and only makes use of the suite directly encapsulating the test cases (the suite declared with  BOOST_TEST_MODULE ).\nHowever since this is expected to be fixed relatively soon, it is recommended that you use the following format to declare tests.", 
            "title": "Test heirarchy"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/#guidelines-for-naming-test-suites-and-test-cases", 
            "text": "The global test suite for a file (specified with  BOOST_TEST_MODULE ) should correspond to the computer-vision module the tests are part of.\nA test suite should be created for each file with  BOOST_AUTO_TEST_SUITE  and should encompass all the tests in the file. Tests contained within a single file should all test a single feature or function of the program. Tests for different features/functions should go in their own file with a separate test suite. The file should also have the same name as the test suite (though test suite names should be camel cased).  Additional test suites can also be created inside test suites at your discretion if a certain suite has a large number of test cases that can be meaningfully subdivided.  For consistency, test suite and test case names should be UpperCamelCase (and test module name should be the full UpperCamelCase version of the module name. e.g. targetid should be TargetIdentification).  Also note that all names should be sufficiently descriptive to be unique in their scope (as well as sufficiently descriptive to convey what is being tested in a particular suite/case). That is, each test suite in a module needs to have a unique name to avoid naming conflicts, but names of test suites inside those suites and names of test cases only need to be unique inside their encapsulating test suite.", 
            "title": "Guidelines for naming test suites and test cases"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/#example", 
            "text": "file: modules/mymodule/test/mysuite.cpp  #define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE MyModule\n#include  boost/test/unit_test.hpp \n#include  foo.h  // declares type foo, header is in the core module\n\nBOOST_AUTO_TEST_SUITE(MySuite);\n\nBOOST_AUTO_TEST_CASE(TestName) {\n    foo bar;\n    BOOST_CHECK(foo.baz());\n}\n\nBOOST_AUTO_TEST_SUITE_END();  file: modules/mymodule/test/CMakeLists.txt  include_directories(${Core_INCLUDE_DIR})\nadd_executable(mytest test.cpp)\ntarget_link_libraries(mytest Core)\n\n# Tests\nadd_test(\n    NAME  example test \n    COMMAND mytest --log_format=XML --log_sink=TEST-mytest.xml --log_level=all --report_level=no\n)", 
            "title": "Example"
        }, 
        {
            "location": "/mechanical/", 
            "text": "Welcome to the Mechanical Docs!\n\n\nTable of Contents\n\n\n\n\nGrabCad\n\n\nCAD Guidelines and Commandments\n\n\n3D Printing Guidelines", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/mechanical/#welcome-to-the-mechanical-docs", 
            "text": "", 
            "title": "Welcome to the Mechanical Docs!"
        }, 
        {
            "location": "/mechanical/#table-of-contents", 
            "text": "GrabCad  CAD Guidelines and Commandments  3D Printing Guidelines", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/mechanical/cad-guidelines/", 
            "text": "WARG CAD Guidelines\n\n\nTo keep things more consistent at WARG, we enforce a set of guidelines on all submitted CAD designs. This only applies to mechanical CAD files (not electrical). Since we use Solidworks for most of our mechanical work, these guidelines mainly apply to it. \n\n\nThe 13 CAD Commandments\n\n\nIn order for your design to be accepted it must adhere to all the commandments listed below. If the part does not you will be notified what modifications need to be made in order for it to be accepted. Once your part is accepted you can begin to manufacturer/make the part. If an assembly of parts is being made all parts and the assembly must be approved before manufacturing/making the assembly.\n\n\n\n\nAll parts (sketches) must be fully defined\n\n\nAll fastening holes (screw, bolt etc.. holes) must be done using hole wizard\n\n\nUse relations to eliminate redundant dimensions\n\n\nParts must be made in MMGS scale\n\n\nParts must use \nWARG\u2019s standard naming convention\n\n\nAssemblies must contain ALL components fully defined and related such that distances are equal\n\n\nAssemblies must have ALL holes concentric with fasteners of required length mated to the holes (check McMaster Carr if you need CAD models of fasteners)\n\n\nNO assembly features\n\n\nWhen making part revisions look at the previous version and identify any filing/drilling/sanding/machining you had to do to the parts to make them fit and ENSURE that the new part is modified so that the changes don\u2019t have to be made again.\n\n\nFillets/Chamfers of equal size must be made in the SAME feature. All fillets/chamfers must be added as features and NOT included in the sketches.\n\n\nEnsure that your assemblies are manufacturable with appropriate tolerances (ie parts have clearance to be assembled and parts don\u2019t have to go through walls/break physics to work).\n\n\nConsider the thickness and dimensions of parts to ensure that they are reasonable. A 3mm and 5mm thickness go a long way.\n\n\nAll of the relevant CAD files should be uploaded and synced on \nGrabCad\n. The design will \nNOT BE REVIEWED\n if it is not on GrabCad. Screenshots and stl files do not suffice.\n\n\n\n\nNOTE\n: \nIf you violate one of these commandments you must notify a team lead with a valid explanation as to the reason for violating the commandment\n\n\nCAD Naming Convention\n\n\nAll CAD files should adhere to the following naming convention (snake upper case):\n\n\nFor regular part files\n\n\nPROJECT_NAME\n__\nSUBASSEMBLY_NAME\n_\nPART##\n_\nPART_NAME\n.SLDPRT\n\n\n\n\neg. \nSPIKE__GIMBAL_03_OUTSIDE_CASE.SLDPRT\n\n\nFor assemblies\n\n\nPROJECT_NAME\n__\nSUBASSEMBLY_NAME\n_00_ASSEMBLY.SLDASM\n\n\n\n\neg. \nSPIKE__GIMBAL_00_ASSEMBLY.SLDASM\n\n\nFor assemblies within assemblies\n\n\nCreate a folder with the same naming convention as the part, and follow the same naming convention inside the folder, prepending the project name.\n\n\nFor example, if the gimbal assembly contains a part camera which itself is also an assembly:\n\n\n\n\nCreate folder named \nGIMBAL_02_CAMERA\n\n\nInside the folder follow the same naming convention, but prepend the original project name at the begining.\n\n\n\n\neg.\n\n\nGIMBAL_00_ASSEMBLY.SLDASM\nGIMBAL_O1_CAMERA\n --\n GIMBAL_CAMERA_00_ASSEMBLY.SLDASM\n --\n GIMBAL_CAMERA_01_GO_PRO.SLDPRT\n\n\n\n\nFor drawings\n\n\nIn the assembly folder create another folder to store drawings.\n\n\nPROJECT_NAME\n_DRAWINGS\n\n\n\n\nFor the actual part files, follow the same naming convention as above, and store them in this folder.\n\n\nRenders\n\n\nCreate a seperate \nRenders\n folder within your project and dump all your renders there. No naming convention here\n\n\nExample\n\n\nProject Name: DATA_RELAY_CASE\n\n\nSub Assemblies: Wooden Case, OrangePi\n\n\nProject Root\n\n\n\n\nSub-assembly", 
            "title": "CAD Guidelines"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#warg-cad-guidelines", 
            "text": "To keep things more consistent at WARG, we enforce a set of guidelines on all submitted CAD designs. This only applies to mechanical CAD files (not electrical). Since we use Solidworks for most of our mechanical work, these guidelines mainly apply to it.", 
            "title": "WARG CAD Guidelines"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#the-13-cad-commandments", 
            "text": "In order for your design to be accepted it must adhere to all the commandments listed below. If the part does not you will be notified what modifications need to be made in order for it to be accepted. Once your part is accepted you can begin to manufacturer/make the part. If an assembly of parts is being made all parts and the assembly must be approved before manufacturing/making the assembly.   All parts (sketches) must be fully defined  All fastening holes (screw, bolt etc.. holes) must be done using hole wizard  Use relations to eliminate redundant dimensions  Parts must be made in MMGS scale  Parts must use  WARG\u2019s standard naming convention  Assemblies must contain ALL components fully defined and related such that distances are equal  Assemblies must have ALL holes concentric with fasteners of required length mated to the holes (check McMaster Carr if you need CAD models of fasteners)  NO assembly features  When making part revisions look at the previous version and identify any filing/drilling/sanding/machining you had to do to the parts to make them fit and ENSURE that the new part is modified so that the changes don\u2019t have to be made again.  Fillets/Chamfers of equal size must be made in the SAME feature. All fillets/chamfers must be added as features and NOT included in the sketches.  Ensure that your assemblies are manufacturable with appropriate tolerances (ie parts have clearance to be assembled and parts don\u2019t have to go through walls/break physics to work).  Consider the thickness and dimensions of parts to ensure that they are reasonable. A 3mm and 5mm thickness go a long way.  All of the relevant CAD files should be uploaded and synced on  GrabCad . The design will  NOT BE REVIEWED  if it is not on GrabCad. Screenshots and stl files do not suffice.   NOTE :  If you violate one of these commandments you must notify a team lead with a valid explanation as to the reason for violating the commandment", 
            "title": "The 13 CAD Commandments"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#cad-naming-convention", 
            "text": "All CAD files should adhere to the following naming convention (snake upper case):", 
            "title": "CAD Naming Convention"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#for-regular-part-files", 
            "text": "PROJECT_NAME __ SUBASSEMBLY_NAME _ PART## _ PART_NAME .SLDPRT  eg.  SPIKE__GIMBAL_03_OUTSIDE_CASE.SLDPRT", 
            "title": "For regular part files"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#for-assemblies", 
            "text": "PROJECT_NAME __ SUBASSEMBLY_NAME _00_ASSEMBLY.SLDASM  eg.  SPIKE__GIMBAL_00_ASSEMBLY.SLDASM", 
            "title": "For assemblies"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#for-assemblies-within-assemblies", 
            "text": "Create a folder with the same naming convention as the part, and follow the same naming convention inside the folder, prepending the project name.  For example, if the gimbal assembly contains a part camera which itself is also an assembly:   Create folder named  GIMBAL_02_CAMERA  Inside the folder follow the same naming convention, but prepend the original project name at the begining.   eg.  GIMBAL_00_ASSEMBLY.SLDASM\nGIMBAL_O1_CAMERA\n --  GIMBAL_CAMERA_00_ASSEMBLY.SLDASM\n --  GIMBAL_CAMERA_01_GO_PRO.SLDPRT", 
            "title": "For assemblies within assemblies"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#for-drawings", 
            "text": "In the assembly folder create another folder to store drawings.  PROJECT_NAME _DRAWINGS  For the actual part files, follow the same naming convention as above, and store them in this folder.", 
            "title": "For drawings"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#renders", 
            "text": "Create a seperate  Renders  folder within your project and dump all your renders there. No naming convention here", 
            "title": "Renders"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#example", 
            "text": "Project Name: DATA_RELAY_CASE  Sub Assemblies: Wooden Case, OrangePi", 
            "title": "Example"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#project-root", 
            "text": "", 
            "title": "Project Root"
        }, 
        {
            "location": "/mechanical/cad-guidelines/#sub-assembly", 
            "text": "", 
            "title": "Sub-assembly"
        }, 
        {
            "location": "/mechanical/3d-printing-guidelines/", 
            "text": "Guide to 3D Printing\n\n\nGeneral guidelines and requirements for 3D printing:\n\n\n\n\nGet your \nWATIMAKE 3D print certification\n.\n\n\nKeep in mind the orientation of the 3D print to maximize strength of the part, minimize support materials, and maximize feature accuracy.\n\n\nConsider the maximum build volume of the printer\n\n\nKeep in mind warping \u2013 the back part of the printer nearer to the extruder is warmer. Maintaining constant temperature will prevent warping due to rapid cooling. Therefore, if certain features are important put them closer to the extruder than the door to maintain a constant environment.\n\n\nConsider splitting large parts into multiple parts and using flanges/mating features to appropriately to attach together.\n\n\nConsider the material your using. ABS is more prone to warping and is no brittle. PLA warps less and is brittle.\n\n\nFilament is not cheap \u2013 consider the amount if infill, you should not be using more than 30% for a structural part.\n\n\nConsider the amount of shells (number of outer layers before infill begins) that you need 4-6 layers is appropriate.", 
            "title": "3D Printing Guidelines"
        }, 
        {
            "location": "/mechanical/3d-printing-guidelines/#guide-to-3d-printing", 
            "text": "General guidelines and requirements for 3D printing:   Get your  WATIMAKE 3D print certification .  Keep in mind the orientation of the 3D print to maximize strength of the part, minimize support materials, and maximize feature accuracy.  Consider the maximum build volume of the printer  Keep in mind warping \u2013 the back part of the printer nearer to the extruder is warmer. Maintaining constant temperature will prevent warping due to rapid cooling. Therefore, if certain features are important put them closer to the extruder than the door to maintain a constant environment.  Consider splitting large parts into multiple parts and using flanges/mating features to appropriately to attach together.  Consider the material your using. ABS is more prone to warping and is no brittle. PLA warps less and is brittle.  Filament is not cheap \u2013 consider the amount if infill, you should not be using more than 30% for a structural part.  Consider the amount of shells (number of outer layers before infill begins) that you need 4-6 layers is appropriate.", 
            "title": "Guide to 3D Printing"
        }, 
        {
            "location": "/mechanical/grabcad/", 
            "text": "GrabCad\n\n\nHere at WARG we use \nGrabCad Workbench\n for all of our CAD file management. It is a service like Google Drive and Github that's specially designed for sharing CAD files.\n\n\nNOTE\n: \nWe require that all CAD files (non-bootcamp) are uploaded to GrabCad. Please Do not directly send screenshots, stl files, or solidworks files directly to team leads or review! Send them the grabcad link instead\n\n\nFeatures\n\n\nGrabCad is completely free, and features:\n\n\n\n\nSyncing CAD files\n\n\nViewing CAD files from within a web browser\n\n\nRevision storage and rollback\n\n\nAttaching comments to files\n\n\n\n\nThat revision storage is a big one. We no longer have to have multiple files delimited by versions. Grabcad lets you view and rollback to previous version of the CAD file, in case something goes wrong.\n\n\nHow it works\n\n\nMuch like Github, GrabCad creates a new revision of the file when it detects a change in the file. GrabCad doesn't sync automatically, and instead waits for you to issue an upload. It does this so that a single file doesnt have hundreds of revisions from every time you've saved the file.\n\n\nHow to get started\n\n\nAfter you've completed the bootcamp, you will be able granted access to the WARG GrabCad.\n\n\nTo do this:\n\n\n\n\nSign up here: \nworkbench.grabcad.com\n\n\nRequest that a team lead send you a GrabCad invite to the WARG group\n\n\nDownload and install the \nGrabCad desktop app", 
            "title": "GrabCad"
        }, 
        {
            "location": "/mechanical/grabcad/#grabcad", 
            "text": "Here at WARG we use  GrabCad Workbench  for all of our CAD file management. It is a service like Google Drive and Github that's specially designed for sharing CAD files.  NOTE :  We require that all CAD files (non-bootcamp) are uploaded to GrabCad. Please Do not directly send screenshots, stl files, or solidworks files directly to team leads or review! Send them the grabcad link instead", 
            "title": "GrabCad"
        }, 
        {
            "location": "/mechanical/grabcad/#features", 
            "text": "GrabCad is completely free, and features:   Syncing CAD files  Viewing CAD files from within a web browser  Revision storage and rollback  Attaching comments to files   That revision storage is a big one. We no longer have to have multiple files delimited by versions. Grabcad lets you view and rollback to previous version of the CAD file, in case something goes wrong.", 
            "title": "Features"
        }, 
        {
            "location": "/mechanical/grabcad/#how-it-works", 
            "text": "Much like Github, GrabCad creates a new revision of the file when it detects a change in the file. GrabCad doesn't sync automatically, and instead waits for you to issue an upload. It does this so that a single file doesnt have hundreds of revisions from every time you've saved the file.", 
            "title": "How it works"
        }, 
        {
            "location": "/mechanical/grabcad/#how-to-get-started", 
            "text": "After you've completed the bootcamp, you will be able granted access to the WARG GrabCad.  To do this:   Sign up here:  workbench.grabcad.com  Request that a team lead send you a GrabCad invite to the WARG group  Download and install the  GrabCad desktop app", 
            "title": "How to get started"
        }, 
        {
            "location": "/picpilot/", 
            "text": "Welcome to the PicPilot wiki!\n\n\nThis site is to document all the functions and required background knowledge about the autopilot system.\n\n\n\n\nIntroduction\n\n\nSetup\n\n\nC\n\n\nProgramming the Device\n\n\nAutopilot System Overview\n\n\nSchematics and Board Design\n\n\nProject Files\n\n\nCoding Convention\n\n\n\n\n\n\nPID Loops\n\n\nPWM I/O\n\n\nUniversal Asynchronous Receive/Transmit (UART)\n\n\nSerial Peripheral Interface (SPI)\n\n\nDirect Memory Access (DMA)\n\n\nInter-Interchip Communication (I2C)\n\n\nDatalink\n\n\nAnalog-to-Digital Converter (ADC)\n\n\nSensors and Peripherals\n\n\nGPS(MEDIATEK-3329)\n\n\nIMU (VectorNav-100)\n\n\nAltimeter (MPL3115A2)\n\n\nXBEE PRO S3B\n\n\nRC Receiever (EzUHF)\n\n\nAirspeed Sensor (To be implemented)\n\n\nUltrasonic Sensor (To be implemented)\n\n\n\n\n\n\nAttitude Control\n\n\nPath Management\n\n\nFAQ - WIP\n\n\n\n\nBackground Reading\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/picpilot/#welcome-to-the-picpilot-wiki", 
            "text": "This site is to document all the functions and required background knowledge about the autopilot system.   Introduction  Setup  C  Programming the Device  Autopilot System Overview  Schematics and Board Design  Project Files  Coding Convention    PID Loops  PWM I/O  Universal Asynchronous Receive/Transmit (UART)  Serial Peripheral Interface (SPI)  Direct Memory Access (DMA)  Inter-Interchip Communication (I2C)  Datalink  Analog-to-Digital Converter (ADC)  Sensors and Peripherals  GPS(MEDIATEK-3329)  IMU (VectorNav-100)  Altimeter (MPL3115A2)  XBEE PRO S3B  RC Receiever (EzUHF)  Airspeed Sensor (To be implemented)  Ultrasonic Sensor (To be implemented)    Attitude Control  Path Management  FAQ - WIP", 
            "title": "Welcome to the PicPilot wiki!"
        }, 
        {
            "location": "/picpilot/#background-reading", 
            "text": "Information on Model Aircraft  General Aerodynamic Principles  Git Help", 
            "title": "Background Reading"
        }
    ]
}