{
    "docs": [
        {
            "location": "/", 
            "text": "WARG Docs\n\n\nThe official source of all your WARG needs. Joking, there's only documentation here. Enjoy!\n\n\n\n\nBootcamps and Competitions\n\n\n\n\nMechanical Bootcamp\n\n\nElectrical Bootcamp\n\n\nComputer Vision Bootcamp\n\n\nR/C Car Competition\n\n\n\n\nProjects\n\n\n\n\nPicPilot Documentation\n\n\nGroundstation Documentation\n\n\nComputer Vision Documentation", 
            "title": "Home"
        }, 
        {
            "location": "/#warg-docs", 
            "text": "The official source of all your WARG needs. Joking, there's only documentation here. Enjoy!", 
            "title": "WARG Docs"
        }, 
        {
            "location": "/#bootcamps-and-competitions", 
            "text": "Mechanical Bootcamp  Electrical Bootcamp  Computer Vision Bootcamp  R/C Car Competition", 
            "title": "Bootcamps and Competitions"
        }, 
        {
            "location": "/#projects", 
            "text": "PicPilot Documentation  Groundstation Documentation  Computer Vision Documentation", 
            "title": "Projects"
        }, 
        {
            "location": "/groundstation/", 
            "text": "Welcome to the Groundstation docs!\n\n\nThe groundstation is the software running on the ground computer communicating to the plane through the \ndata-relay-station\n. This wiki describes everything you need to know about it in order to start contributing.\n\n\nTable of Contents\n\n\n\n\nIntroduction\n\n\nWhat you need to know\n\n\nInstallation\n\n\nTutorial\n\n\nProject Structure\n\n\nContributing\n\n\nDocumenting\n\n\nAdditional Resources", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/groundstation/#welcome-to-the-groundstation-docs", 
            "text": "The groundstation is the software running on the ground computer communicating to the plane through the  data-relay-station . This wiki describes everything you need to know about it in order to start contributing.", 
            "title": "Welcome to the Groundstation docs!"
        }, 
        {
            "location": "/groundstation/#table-of-contents", 
            "text": "Introduction  What you need to know  Installation  Tutorial  Project Structure  Contributing  Documenting  Additional Resources", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/groundstation/introduction/", 
            "text": "Introduction\n\n\nThe groundstation is a desktop application based on \nNW.js\n. This section will explain what NW.js and \nNode.js\n is.\n\n\nCommunication Path\n\n\nThe groundstation talks directly to the \ndata-relay-station\n. The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).\n\n\n\n\nWhat is Javascript and Node.js?\n\n\nAs you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes. \n\n\nEnter \nNode.js\n\n\nNode.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with \npython script.py\n you can run javascript scripts with \nnode script.js\n. It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it. \n\n\nWhat is NW.js?\n\n\nOk, so where does \nNW.js\n fit in all this? Why do we need it if we can already write native applications with node.js and javascript? You can think of NW.js as a GUI framework. Usually when making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.\n\n\nNW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.", 
            "title": "Introduction"
        }, 
        {
            "location": "/groundstation/introduction/#introduction", 
            "text": "The groundstation is a desktop application based on  NW.js . This section will explain what NW.js and  Node.js  is.", 
            "title": "Introduction"
        }, 
        {
            "location": "/groundstation/introduction/#communication-path", 
            "text": "The groundstation talks directly to the  data-relay-station . The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).", 
            "title": "Communication Path"
        }, 
        {
            "location": "/groundstation/introduction/#what-is-javascript-and-nodejs", 
            "text": "As you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes.   Enter  Node.js  Node.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with  python script.py  you can run javascript scripts with  node script.js . It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it.", 
            "title": "What is Javascript and Node.js?"
        }, 
        {
            "location": "/groundstation/introduction/#what-is-nwjs", 
            "text": "Ok, so where does  NW.js  fit in all this? Why do we need it if we can already write native applications with node.js and javascript? You can think of NW.js as a GUI framework. Usually when making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.  NW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.", 
            "title": "What is NW.js?"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/", 
            "text": "What you need to know\n\n\nThis section will help to highlight \nmost\n of what you need to know before you can start developing. \n\n\nJavascript\n\n\nIf you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this \nCodeacademy Javascript Course\n. The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are: \n\n\n\n\nThe significance of var and when and when not to use it\n\n\nThat everything in javascript is an object, including functions\n\n\nThe 3 different ways of declaring javascript objects, and how they are different\n\n\n\n\nNode.js\n\n\nSo you don't need to read all of the gigantic \nNode.js API Documentation\n, though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.\n\n\nNode.js modules\n\n\nSo what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word \nrequire\n being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you. \n\n\nUsually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.\n\n\nSo what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling \nrequire('filelocation/filename)\n. But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.\n\n\nLets take an example comparing traditional methods and using require. \n\n\nUsing Regular Javascript\n\n\nhead\n\n    \nscript\n\n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n    \n/script\n\n    \nscript\n\n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n    \n/script\n\n\n/head\n\n\n\n\n\nThis is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.\n\n\nUsing Node.js Modules\n\n\n//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;\n\n\n\n\n//this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!\n\n\n\n\nYou may have noticed the \nmodule.exports=hello;\n line in the \nhello.js\n module. What this tells node is the result of calling \nrequire\n on the hello.js module will return the variable/function hello. In \napp.js\n we use this module by calling \nvar hello=require('hello')\n. The variable hello now contains whatever the \nhello.js\n module exported, which in this case is a function.\n\n\nYou can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling \nvar\n will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.\n\n\nNode Package Manager (npm)\n\n\nNPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the \nNPM registry\n. \n\n\nThe most important command of npm is \nnpm install \npackagename\n. This will install a package in your project directory. Doing an \nnpm install\n without any parameters at the project root will tell npm to look in your projects \npackage.json\n file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running \nnpm install -g nw\n. This will install the NW.js module globally on your computer, allowing you to use the \nnw\n command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running \nnw\n in the terminal.\n\n\nJavascript Frameworks\n\n\nThe groundstation uses \nBackbone\n and \nMarionette\n as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.\n\n\nYou don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation. \n\n\nLibraries Used\n\n\nOne of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include \nJquery\n for simple dom manipulations, and \nleaflet\n as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the \nLeaflet API Docs\n is pretty useful if you're working with the Map modules.", 
            "title": "What you need to know"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#what-you-need-to-know", 
            "text": "This section will help to highlight  most  of what you need to know before you can start developing.", 
            "title": "What you need to know"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#javascript", 
            "text": "If you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this  Codeacademy Javascript Course . The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are:    The significance of var and when and when not to use it  That everything in javascript is an object, including functions  The 3 different ways of declaring javascript objects, and how they are different", 
            "title": "Javascript"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs", 
            "text": "So you don't need to read all of the gigantic  Node.js API Documentation , though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.", 
            "title": "Node.js"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs-modules", 
            "text": "So what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word  require  being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you.   Usually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.  So what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling  require('filelocation/filename) . But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.  Lets take an example comparing traditional methods and using require.", 
            "title": "Node.js modules"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#using-regular-javascript", 
            "text": "head \n     script \n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n     /script \n     script \n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n     /script  /head   This is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.", 
            "title": "Using Regular Javascript"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#using-nodejs-modules", 
            "text": "//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;  //this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!  You may have noticed the  module.exports=hello;  line in the  hello.js  module. What this tells node is the result of calling  require  on the hello.js module will return the variable/function hello. In  app.js  we use this module by calling  var hello=require('hello') . The variable hello now contains whatever the  hello.js  module exported, which in this case is a function.  You can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling  var  will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.", 
            "title": "Using Node.js Modules"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#node-package-manager-npm", 
            "text": "NPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the  NPM registry .   The most important command of npm is  npm install  packagename . This will install a package in your project directory. Doing an  npm install  without any parameters at the project root will tell npm to look in your projects  package.json  file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running  npm install -g nw . This will install the NW.js module globally on your computer, allowing you to use the  nw  command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running  nw  in the terminal.", 
            "title": "Node Package Manager (npm)"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#javascript-frameworks", 
            "text": "The groundstation uses  Backbone  and  Marionette  as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.  You don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation.", 
            "title": "Javascript Frameworks"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#libraries-used", 
            "text": "One of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include  Jquery  for simple dom manipulations, and  leaflet  as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the  Leaflet API Docs  is pretty useful if you're working with the Map modules.", 
            "title": "Libraries Used"
        }, 
        {
            "location": "/groundstation/installation/", 
            "text": "Installation\n\n\n\n\n\n\nThe first step is cloning the repository. Open up the terminal and run: \n\ngit clone https://github.com/UWARG/WARG-Ground-Station\n\n\n\n\n\n\nThen you need to install Node.js. You can download and install it \nhere\n. Download Node version 5 and above preferably. After you've installed node you should have the \nnode\n command available for you to use in your terminal. Run \nnode help\n to verify that you've successfuly installed node and make sure you're running the right version.\n\n\n\n\n\n\nNow that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run \nnpm install\n to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).\n\n\n\n\n\n\nNow you're ready to start the app up. Run \nnpm start\n to start the application. You should see a window appear of the groundsation.\n\n\n\n\n\n\nNow you need to download the offline satelite files that the application uses for it's map. \nDownload them here.\n. Extract the zip into the \nassets\n folder of the project directory (so you should have a folder called \nsat_tiles\n in the assets folder). \n\n\n\n\n\n\nCongratulations! You should now have the groundstation installed on your computer ready for you to develop on!", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/installation/#installation", 
            "text": "The first step is cloning the repository. Open up the terminal and run:  git clone https://github.com/UWARG/WARG-Ground-Station    Then you need to install Node.js. You can download and install it  here . Download Node version 5 and above preferably. After you've installed node you should have the  node  command available for you to use in your terminal. Run  node help  to verify that you've successfuly installed node and make sure you're running the right version.    Now that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run  npm install  to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).    Now you're ready to start the app up. Run  npm start  to start the application. You should see a window appear of the groundsation.    Now you need to download the offline satelite files that the application uses for it's map.  Download them here. . Extract the zip into the  assets  folder of the project directory (so you should have a folder called  sat_tiles  in the assets folder).     Congratulations! You should now have the groundstation installed on your computer ready for you to develop on!", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/tutorial/", 
            "text": "Groundstation Tutorial\n\n\nThis tutorial will guide you through creating a groundstation window and adding logic to it using the core application modules. \n\n\nInstallation\n\n\nFollow the installation guide \nhere\n to install the groundstation on your computer.\n\n\nEditor\n\n\nYou can use your prefered editor for this application, or an IDE like Webstorm if you prefer.\n\n\nGetting Started\n\n\nTake a look at the \nproject structure\n so you roughly know what each folder of the application is for.\n\n\nCreating a new window\n\n\nTo start create a window, we need to create an html file that will represent our window. In the \nwindow\n folder at the project root, create a file and call it \nnew-window.html\n. Paste this boilerplate code on there:\n\n\n!DOCTYPE html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nUTF-8\n\n    \ntitle\nMy new window\n/title\n\n\n/head\n\n\nbody\n\n    \np\nHello this is my new window!\n/p\n\n\n/body\n\n\n/html\n\n\n\n\n\nAdding a menu item\n\n\nSo all we've done is create a layout file for the new window. Now we've got to \nhave a way of opening the window. To do this we'll add a menu item to our application which will open up our window. \n\n\nOpen up \napp/Menu.js\n. This is the file the application uses to configure it's menu items. At the bottom of the file, add this entry under the window submenu:\n\n\n// ===Window Submenu ===\n    var window_submenu=new gui.Menu();\n\n    //A bunch of code here\n\n    //You need to add this\n  window_submenu.append(new gui.MenuItem({\n    label:'My new window',\n    type:'checkbox',\n    click: function(){\n      gui.Window.open('windows/new-window.html',{\n        focus: true\n      });\n    },\n    key: \nk\n,\n    modifiers: \nctrl-shift\n,\n  }));\n\n\n\n\n\n\nNow lets see what we just did. Calling \nwindow_submenu.append(..)\n appends a menu item to the Window menu of the app. In this case its a \ngui.MenuItem\n which represents a menu item in NW.js applications. The \nlabel\n parameter is the name of the menu item, the \ntype: checkbox\n  indicates that we want the menu item to behave as a checkbox (when you open the window its checked). The \nclick\n parameter indicates the callback funtion to execute when the user has clicked on the menu item. Here, we are calling \ngui.Window.open(...)\n to open up the window layout file we've just created. The \nkey\n and \nmodifiers\n parameters indicate the keyboard shortcuts that may be used to open up the window as well.\n\n\nNow run the app. In the window submenu you should see a new item called \"My new window\". When you click it a new window will appear, with the text 'Hello this is my new window!'. \n\n\nAwesome, you've just added a window to the app. Now lets add more functionality to it with javascript.\n\n\nAdding javascript functionality\n\n\nEvery window you add will require a starting point. A single entry-point module. For the main application it is \napp/App.js\n. For your window it'll be different. You will have to create that entry-point module and load it in the window layout file you just created. This module will then load all of its dependencies (if any) and handle creating the view. \n\n\nTo begin create a file called \nnew-window.js\n inside the \napp/windows/\n folder. Then in \nnew-window.html\n file you created earlier, paste this after the \ntitle\n tag.\n\n\n!-- Our libraries --\n\n\nscript src=\n../app/lib/jquery-2.1.4.js\n/script\n\n\nscript src=\n../app/lib/underscore.js\n/script\n\n\nscript src=\n../app/lib/backbone.js\n/script\n\n\nscript src=\n../app/lib/backbone.marionette.js\n/script\n\n\n\n!-- Our window entry point --\n\n\nscript src=\n../app/windows/new-window.js\n/script\n\n\n\n\n\nSo what are all of these scripts? They are libraries that you will end up using later in the tutorial. The main one we'll use is Marionette, and the rest are dependencies that Marionette requires, such as underscore and jquery.\n\n\nNow lets create an element that we can play around with in our script. Under the \np\n tag add of the \nnew-window.html\n file add this line:\n\n\ndiv id=\nspecial\nOur Special div\n/div\n\n\n\n\n\nWe've assigned an id to this div so that we can reference it later in our javascript. \n\n\nNow that we've got our layout file ready, lets add the functionality in our application entry point. In \nnew-window.js\n, add this line:\n\n\n$(document).ready(function(){\n  $('#special').text('This text was not originally written on the div! Amazing!');\n});\n\n\n\n\nNow lets go to our app and open up the window. You should see this: \n\n\n\n\nIf all went well, you have successfully created an application entry point script for your newly created window. You are now ready to add more complex functionality to it. The next section will talk about debugging your application and implementing Marionette and MVC in your window.\n\n\nDebugging\n\n\nIf your window still says 'Our Special div' that means you've made a mistake. To diagnose what went wrong, you can open up the developer tools console by clicking on the three bars right next to the url bar of the window. It'll tell you if there were any javascript errors or if any files failed to load.\n\n\nCreating the Marionette ItemView\n\n\nSo what we did previously is use jquery directly to manipulate a div in our layout (the view). That was a pretty simple example, however continuing to work on it this way will lead to hard to maintain code, since we're mixing our view logic (ie manipulations) and our application logic together. This is something we should avoid doing, and with the help of Marionette, its pretty easy to do so. \n\n\nTo get started, create a new file called \nnewWindowView.js\n in the \napp/views/\n folder. Copy and paste this boilerplate code:\n\n\n//This is an example Marionette view\n//NOTE: you should not require jquery in your views, as you should only reference the elements inside the view which you can do with the ui property of the view\nvar Template=require('../util/Template');\n/*\ncall your other dependencies here (for example if you need to listen to network events, call this)\nvar Network=require('../Network'); \nthen use the Network object inside your view\n*/\n\nmodule.exports=function(Marionette){\n\n  return Marionette.ItemView.extend({\n    template:Template('newWindowView'), //name of the file in the views folder at the project root\n    className:'newWindowView', //this is the class name the injected div will have (refer to this class in your style sheets)\n\n    ui:{ //any ui elements in the view that you would like to reference within your view logic\n      an_element:\n#an-example-element\n //you can now refer to the jquery wrapped element within the view with this.ui.an_element\n    },\n\n    //your custom jquery events\n    //selector then the name of the callback function\n    events:{\n      \nclick #an-example-element\n: \nclickCallback\n\n    },\n\n    initialize: function(){\n      //called when the view is first initialized (ie new ExampleView())\n    },\n    onRender:function(){\n      //called right after a render is called on the view (view.render())\n    },\n    onBeforeDestroy:function(){\n      //called just before destroy is called on the view\n    },\n    onDestroy:function(){\n      //called right after a destroy is called on the view\n    },\n\n    clickCallback:function(event){ //will be fired when a user clicks on #an-example-element\n\n    }\n  });\n};\n\n\n\n\nThen, in your \nnew-window.html\n file, delete the \np\n and \ndiv\n lines, so that there is nothing in the \nbody\n tag.\n\n\nNow create a new layout file for the view by creating a file called \nnewWindowView.html\n inside the \nviews/\n folder at the project root. Paste this in the file:\n\n\np\nHello I am my own view!\n/p\n\n\n\n\n\nAnd in your \nnew-window.js\n file replace all of the code with this:\n\n\n//our new-window.js file (the window entry point)\nvar windowView=require('./app/views/newWindowView')(Marionette);\n\n$(document).ready(function(){\n  $('body').append((new windowView()).render().$el);\n});\n\n\n\n\nNow open up the groundstation and open up your window again. You should now see this:\n\n\n\n\nExplaning Marionette and ItemViews\n\n\nSo lets do a breakdown of what we just did. \n\n\nLets start of by explaning what an ItemView is. A Marionette itemView represents..a view. The itemView manages all aspects of the view, including rendering, capturing user input, etc.. \n\n\nEach ItemView has to have its own template file, which is the \nnewWindowView.html\n file we created in the \nviews/\n folder. We specify this in our ItemView by setting the \ntemplate\n property. The ItemView will render that template and then our application entry point (\nexample-window.js\n) will append it to the body of our window. Here is a diagram showing what happens:\n\n\n\n\nWhy do it this way?\n\n\nYou may be asking yourself what was the point of doing all the fancy stuff if the end result was the same. What we've just done is seperated our view logic and application logic into different modules. Now, say we want to create a combined window that combines our view with the map. Because all of the logic associated\nwith our view is completely isolated, there is no code that we have re-write. We simply import the views that we're interested in and inject them into our new window. This form of writing applications is called an \nMVC\n pattern, standing for Model View Controller.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/groundstation/tutorial/#groundstation-tutorial", 
            "text": "This tutorial will guide you through creating a groundstation window and adding logic to it using the core application modules.", 
            "title": "Groundstation Tutorial"
        }, 
        {
            "location": "/groundstation/tutorial/#installation", 
            "text": "Follow the installation guide  here  to install the groundstation on your computer.", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/tutorial/#editor", 
            "text": "You can use your prefered editor for this application, or an IDE like Webstorm if you prefer.", 
            "title": "Editor"
        }, 
        {
            "location": "/groundstation/tutorial/#getting-started", 
            "text": "Take a look at the  project structure  so you roughly know what each folder of the application is for.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/groundstation/tutorial/#creating-a-new-window", 
            "text": "To start create a window, we need to create an html file that will represent our window. In the  window  folder at the project root, create a file and call it  new-window.html . Paste this boilerplate code on there:  !DOCTYPE html  html lang= en  head \n     meta charset= UTF-8 \n     title My new window /title  /head  body \n     p Hello this is my new window! /p  /body  /html", 
            "title": "Creating a new window"
        }, 
        {
            "location": "/groundstation/tutorial/#adding-a-menu-item", 
            "text": "So all we've done is create a layout file for the new window. Now we've got to \nhave a way of opening the window. To do this we'll add a menu item to our application which will open up our window.   Open up  app/Menu.js . This is the file the application uses to configure it's menu items. At the bottom of the file, add this entry under the window submenu:  // ===Window Submenu ===\n    var window_submenu=new gui.Menu();\n\n    //A bunch of code here\n\n    //You need to add this\n  window_submenu.append(new gui.MenuItem({\n    label:'My new window',\n    type:'checkbox',\n    click: function(){\n      gui.Window.open('windows/new-window.html',{\n        focus: true\n      });\n    },\n    key:  k ,\n    modifiers:  ctrl-shift ,\n  }));  Now lets see what we just did. Calling  window_submenu.append(..)  appends a menu item to the Window menu of the app. In this case its a  gui.MenuItem  which represents a menu item in NW.js applications. The  label  parameter is the name of the menu item, the  type: checkbox   indicates that we want the menu item to behave as a checkbox (when you open the window its checked). The  click  parameter indicates the callback funtion to execute when the user has clicked on the menu item. Here, we are calling  gui.Window.open(...)  to open up the window layout file we've just created. The  key  and  modifiers  parameters indicate the keyboard shortcuts that may be used to open up the window as well.  Now run the app. In the window submenu you should see a new item called \"My new window\". When you click it a new window will appear, with the text 'Hello this is my new window!'.   Awesome, you've just added a window to the app. Now lets add more functionality to it with javascript.", 
            "title": "Adding a menu item"
        }, 
        {
            "location": "/groundstation/tutorial/#adding-javascript-functionality", 
            "text": "Every window you add will require a starting point. A single entry-point module. For the main application it is  app/App.js . For your window it'll be different. You will have to create that entry-point module and load it in the window layout file you just created. This module will then load all of its dependencies (if any) and handle creating the view.   To begin create a file called  new-window.js  inside the  app/windows/  folder. Then in  new-window.html  file you created earlier, paste this after the  title  tag.  !-- Our libraries --  script src= ../app/lib/jquery-2.1.4.js /script  script src= ../app/lib/underscore.js /script  script src= ../app/lib/backbone.js /script  script src= ../app/lib/backbone.marionette.js /script  !-- Our window entry point --  script src= ../app/windows/new-window.js /script   So what are all of these scripts? They are libraries that you will end up using later in the tutorial. The main one we'll use is Marionette, and the rest are dependencies that Marionette requires, such as underscore and jquery.  Now lets create an element that we can play around with in our script. Under the  p  tag add of the  new-window.html  file add this line:  div id= special Our Special div /div   We've assigned an id to this div so that we can reference it later in our javascript.   Now that we've got our layout file ready, lets add the functionality in our application entry point. In  new-window.js , add this line:  $(document).ready(function(){\n  $('#special').text('This text was not originally written on the div! Amazing!');\n});  Now lets go to our app and open up the window. You should see this:    If all went well, you have successfully created an application entry point script for your newly created window. You are now ready to add more complex functionality to it. The next section will talk about debugging your application and implementing Marionette and MVC in your window.", 
            "title": "Adding javascript functionality"
        }, 
        {
            "location": "/groundstation/tutorial/#debugging", 
            "text": "If your window still says 'Our Special div' that means you've made a mistake. To diagnose what went wrong, you can open up the developer tools console by clicking on the three bars right next to the url bar of the window. It'll tell you if there were any javascript errors or if any files failed to load.", 
            "title": "Debugging"
        }, 
        {
            "location": "/groundstation/tutorial/#creating-the-marionette-itemview", 
            "text": "So what we did previously is use jquery directly to manipulate a div in our layout (the view). That was a pretty simple example, however continuing to work on it this way will lead to hard to maintain code, since we're mixing our view logic (ie manipulations) and our application logic together. This is something we should avoid doing, and with the help of Marionette, its pretty easy to do so.   To get started, create a new file called  newWindowView.js  in the  app/views/  folder. Copy and paste this boilerplate code:  //This is an example Marionette view\n//NOTE: you should not require jquery in your views, as you should only reference the elements inside the view which you can do with the ui property of the view\nvar Template=require('../util/Template');\n/*\ncall your other dependencies here (for example if you need to listen to network events, call this)\nvar Network=require('../Network'); \nthen use the Network object inside your view\n*/\n\nmodule.exports=function(Marionette){\n\n  return Marionette.ItemView.extend({\n    template:Template('newWindowView'), //name of the file in the views folder at the project root\n    className:'newWindowView', //this is the class name the injected div will have (refer to this class in your style sheets)\n\n    ui:{ //any ui elements in the view that you would like to reference within your view logic\n      an_element: #an-example-element  //you can now refer to the jquery wrapped element within the view with this.ui.an_element\n    },\n\n    //your custom jquery events\n    //selector then the name of the callback function\n    events:{\n       click #an-example-element :  clickCallback \n    },\n\n    initialize: function(){\n      //called when the view is first initialized (ie new ExampleView())\n    },\n    onRender:function(){\n      //called right after a render is called on the view (view.render())\n    },\n    onBeforeDestroy:function(){\n      //called just before destroy is called on the view\n    },\n    onDestroy:function(){\n      //called right after a destroy is called on the view\n    },\n\n    clickCallback:function(event){ //will be fired when a user clicks on #an-example-element\n\n    }\n  });\n};  Then, in your  new-window.html  file, delete the  p  and  div  lines, so that there is nothing in the  body  tag.  Now create a new layout file for the view by creating a file called  newWindowView.html  inside the  views/  folder at the project root. Paste this in the file:  p Hello I am my own view! /p   And in your  new-window.js  file replace all of the code with this:  //our new-window.js file (the window entry point)\nvar windowView=require('./app/views/newWindowView')(Marionette);\n\n$(document).ready(function(){\n  $('body').append((new windowView()).render().$el);\n});  Now open up the groundstation and open up your window again. You should now see this:", 
            "title": "Creating the Marionette ItemView"
        }, 
        {
            "location": "/groundstation/tutorial/#explaning-marionette-and-itemviews", 
            "text": "So lets do a breakdown of what we just did.   Lets start of by explaning what an ItemView is. A Marionette itemView represents..a view. The itemView manages all aspects of the view, including rendering, capturing user input, etc..   Each ItemView has to have its own template file, which is the  newWindowView.html  file we created in the  views/  folder. We specify this in our ItemView by setting the  template  property. The ItemView will render that template and then our application entry point ( example-window.js ) will append it to the body of our window. Here is a diagram showing what happens:", 
            "title": "Explaning Marionette and ItemViews"
        }, 
        {
            "location": "/groundstation/tutorial/#why-do-it-this-way", 
            "text": "You may be asking yourself what was the point of doing all the fancy stuff if the end result was the same. What we've just done is seperated our view logic and application logic into different modules. Now, say we want to create a combined window that combines our view with the map. Because all of the logic associated\nwith our view is completely isolated, there is no code that we have re-write. We simply import the views that we're interested in and inject them into our new window. This form of writing applications is called an  MVC  pattern, standing for Model View Controller.", 
            "title": "Why do it this way?"
        }, 
        {
            "location": "/groundstation/project-structure/", 
            "text": "Project Structure\n\n\nThis is the project folder structure. Not that there are\nmore folders than listed here, however these are the most relevant.\n\n\n/\n    app/\n        connections/\n        lib/\n        map/\n        models/\n        util/\n        views/\n        windows/\n    assets/\n        fonts/\n        images/\n        simulation/\n        stl/\n    build/\n    config/\n    logs/\n    node_modules/\n    styles/\n        lib/\n        views/\n    views/\n    index.html\n    package.json\n\n\n\n\napp/\n\n\nThis is where all of the applications javascript files are located. It is the heart and soul of the groundstation.\n\n\napp/lib\n\n\nAll javascript libraries go here, including jquery, marionette, leaflet, etc..\n\n\napp/views\n\n\nApplication logic that's responsible for views. Every single view has its own file here.\n\n\nassets/\n\n\nAny binary assets are stored here\n\n\nbuild/\n\n\nThe output of running \nnpm run build\n, which creates an executable of the groundstation for every operating system.\n\n\nconfig/\n\n\nThe groundstation config files are stored here. These config files are then dynamically loaded, stored, and persisted across the application lifecycle.\n\n\nlogs/\n\n\nGroundstation log output. \n\n\nlogs/data_entries/\n\n\nOutput of the logs from the Data Entry Window\n\n\nnode_modules/\n\n\nAll of the node modules installed by running \nnpm install\n are stored in here. You don't really need to be concerned about this directory.\n\n\nstyles/\n\n\nCSS directory. This is where styles go. Everything in here is a .css file.\n\n\nviews/\n\n\nTemplates for the views of the app. Everything in here is .html files.\n\n\nindex.html\n\n\nThis is the starting point of the application. This file is loaded, which in turn loads the necessary javascript files required to make the application run.\n\n\npackage.json\n\n\nThis file describes the application, including any dependencies that it requires. You can read more about this file \nhere\n.", 
            "title": "Project Structure"
        }, 
        {
            "location": "/groundstation/project-structure/#project-structure", 
            "text": "This is the project folder structure. Not that there are\nmore folders than listed here, however these are the most relevant.  /\n    app/\n        connections/\n        lib/\n        map/\n        models/\n        util/\n        views/\n        windows/\n    assets/\n        fonts/\n        images/\n        simulation/\n        stl/\n    build/\n    config/\n    logs/\n    node_modules/\n    styles/\n        lib/\n        views/\n    views/\n    index.html\n    package.json", 
            "title": "Project Structure"
        }, 
        {
            "location": "/groundstation/project-structure/#app", 
            "text": "This is where all of the applications javascript files are located. It is the heart and soul of the groundstation.", 
            "title": "app/"
        }, 
        {
            "location": "/groundstation/project-structure/#applib", 
            "text": "All javascript libraries go here, including jquery, marionette, leaflet, etc..", 
            "title": "app/lib"
        }, 
        {
            "location": "/groundstation/project-structure/#appviews", 
            "text": "Application logic that's responsible for views. Every single view has its own file here.", 
            "title": "app/views"
        }, 
        {
            "location": "/groundstation/project-structure/#assets", 
            "text": "Any binary assets are stored here", 
            "title": "assets/"
        }, 
        {
            "location": "/groundstation/project-structure/#build", 
            "text": "The output of running  npm run build , which creates an executable of the groundstation for every operating system.", 
            "title": "build/"
        }, 
        {
            "location": "/groundstation/project-structure/#config", 
            "text": "The groundstation config files are stored here. These config files are then dynamically loaded, stored, and persisted across the application lifecycle.", 
            "title": "config/"
        }, 
        {
            "location": "/groundstation/project-structure/#logs", 
            "text": "Groundstation log output.", 
            "title": "logs/"
        }, 
        {
            "location": "/groundstation/project-structure/#logsdata_entries", 
            "text": "Output of the logs from the Data Entry Window", 
            "title": "logs/data_entries/"
        }, 
        {
            "location": "/groundstation/project-structure/#node_modules", 
            "text": "All of the node modules installed by running  npm install  are stored in here. You don't really need to be concerned about this directory.", 
            "title": "node_modules/"
        }, 
        {
            "location": "/groundstation/project-structure/#styles", 
            "text": "CSS directory. This is where styles go. Everything in here is a .css file.", 
            "title": "styles/"
        }, 
        {
            "location": "/groundstation/project-structure/#views", 
            "text": "Templates for the views of the app. Everything in here is .html files.", 
            "title": "views/"
        }, 
        {
            "location": "/groundstation/project-structure/#indexhtml", 
            "text": "This is the starting point of the application. This file is loaded, which in turn loads the necessary javascript files required to make the application run.", 
            "title": "index.html"
        }, 
        {
            "location": "/groundstation/project-structure/#packagejson", 
            "text": "This file describes the application, including any dependencies that it requires. You can read more about this file  here .", 
            "title": "package.json"
        }, 
        {
            "location": "/groundstation/contributing/", 
            "text": "Contributing\n\n\nIn order to contribute to the groundstation you must know how to use git. Check out our tutorial \nhere\n to learn how to use it.\nFollow the guidelines here if you want to contribute to the groundstation.\n\n\nGetting yourself a task\n\n\nIn order to qualify yourself to work on the groundstation, you must complete the groundstation bootcamp. The bootcamp should give you a good\nunderstanding of the underlying structure of the groundstation, and help you get familiar with the code.\n\n\nAfterwords, talk to the responsible team lead, and they will assign you a task on \nasana\n.\n\n\nBranches\n\n\nIf you are working on a feature or adding anything to the groundstation, \nbranch off of master\n first, and then start working on your task.\n\nDO NOT WORK ON MASTER\n. You are making your life harder if you do so, since you'll have to transfer your changes to a different branch before\nyou can make a pull request.\n\n\nPlease name your branches in the following format: \n{type_of_change}-{your_name}-{title_of_task}\n\n\ntype_of_change\n is either a \nfeature\n or a \nbug\n, depending on the context of your task. For \ntitle_of_task\n, just name it something relevant.\nAs an example, say a really cool developer named Serge is working on adding a PID graph to the groundstation. The branch name would be in the form of:\n\nfeature-serge-pid-graph\n.\n\n\nCoding Conventions\n\n\nVariable names in lower case with underscores as seperators. eg \nthis_is_a_variable\n\n\nFunction names in camel case. For example: \nfunctionNameHere()\n\n\nConstants in all capitals seperated by underscores. eg. \nTHIS_IS_A_CONSTANT\n\n\nModule and class names in capital camel case. For example: \nThisIsAModule\n\n\nFor file names, look at the file names in the folder and follow them. \n\n\nAs a rule of thumb, when in doubt, look at the existing code and follow the same pattern.\n\n\nDocumentating your code\n\n\nMost times your code should be verbose enough that you shouldn't need too many comments. However times may arise when your\nlogic gets too complicated, so use your judgement as a developer and comment your code where you think it is necessary. Imagine\ntrying to read the code you're writing 5 years from now, and think of how easily you'd understand it.\n\n\nNote that if you're creating any sort of function, class, object, or module, \nYOU MUST DOCUMENT IT WITH JSDOC SYNTAX!\n. More information can be found in\nthe \ndocumenting section\n. Your code will not be merged in if this is not done.\n\n\nPull Requests\n\n\nAfter you finish implementing your feature, open up a pull request on github. Let the responsible team lead know and they will code review your changes.\nUntil the pull request is merged in, your task is not complete.\n\n\nYOU MUST OPEN UP PULL REQUESTS. \nNEVER\n PUSH DIRECTLY TO THE MASTER BRANCH ON GITHUB!", 
            "title": "Contributing"
        }, 
        {
            "location": "/groundstation/contributing/#contributing", 
            "text": "In order to contribute to the groundstation you must know how to use git. Check out our tutorial  here  to learn how to use it.\nFollow the guidelines here if you want to contribute to the groundstation.", 
            "title": "Contributing"
        }, 
        {
            "location": "/groundstation/contributing/#getting-yourself-a-task", 
            "text": "In order to qualify yourself to work on the groundstation, you must complete the groundstation bootcamp. The bootcamp should give you a good\nunderstanding of the underlying structure of the groundstation, and help you get familiar with the code.  Afterwords, talk to the responsible team lead, and they will assign you a task on  asana .", 
            "title": "Getting yourself a task"
        }, 
        {
            "location": "/groundstation/contributing/#branches", 
            "text": "If you are working on a feature or adding anything to the groundstation,  branch off of master  first, and then start working on your task. DO NOT WORK ON MASTER . You are making your life harder if you do so, since you'll have to transfer your changes to a different branch before\nyou can make a pull request.  Please name your branches in the following format:  {type_of_change}-{your_name}-{title_of_task}  type_of_change  is either a  feature  or a  bug , depending on the context of your task. For  title_of_task , just name it something relevant.\nAs an example, say a really cool developer named Serge is working on adding a PID graph to the groundstation. The branch name would be in the form of: feature-serge-pid-graph .", 
            "title": "Branches"
        }, 
        {
            "location": "/groundstation/contributing/#coding-conventions", 
            "text": "Variable names in lower case with underscores as seperators. eg  this_is_a_variable  Function names in camel case. For example:  functionNameHere()  Constants in all capitals seperated by underscores. eg.  THIS_IS_A_CONSTANT  Module and class names in capital camel case. For example:  ThisIsAModule  For file names, look at the file names in the folder and follow them.   As a rule of thumb, when in doubt, look at the existing code and follow the same pattern.", 
            "title": "Coding Conventions"
        }, 
        {
            "location": "/groundstation/contributing/#documentating-your-code", 
            "text": "Most times your code should be verbose enough that you shouldn't need too many comments. However times may arise when your\nlogic gets too complicated, so use your judgement as a developer and comment your code where you think it is necessary. Imagine\ntrying to read the code you're writing 5 years from now, and think of how easily you'd understand it.  Note that if you're creating any sort of function, class, object, or module,  YOU MUST DOCUMENT IT WITH JSDOC SYNTAX! . More information can be found in\nthe  documenting section . Your code will not be merged in if this is not done.", 
            "title": "Documentating your code"
        }, 
        {
            "location": "/groundstation/contributing/#pull-requests", 
            "text": "After you finish implementing your feature, open up a pull request on github. Let the responsible team lead know and they will code review your changes.\nUntil the pull request is merged in, your task is not complete.  YOU MUST OPEN UP PULL REQUESTS.  NEVER  PUSH DIRECTLY TO THE MASTER BRANCH ON GITHUB!", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/groundstation/documenting/", 
            "text": "Documenting\n\n\nThe ground station uses \njsdocs\n for its documentation purposes.\n\n\nIf you're familiar with JavaDoc or PHPDoc, then its very similar. Essentially you add comments\nto your code using a double star comment in the form of \n/** your comment */\n and the jsdoc \ninterpreter generates nice well-described documentation based on your source code files.\n\n\nA good tutorial of what it is, why we use it, and how to use it can be found here: \nhttp://speakingjs.com/es5/ch29.html\n.\n\n\nYou are required to document the necessary part of your code with this format.\n\n\nJSDoc Reference\n\n\n\n\n\n\n\n\nBlock\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@abstract\n\u02d9(synonyms: @virtual)\n\n\nThis member must be implemented (or overridden) by the inheritor.\n\n\n\n\n\n\n@author\n\n\nIdentify the author of an item.\n\n\n\n\n\n\n@callback\n\n\nDocument a callback function.\n\n\n\n\n\n\n@class\n (synonyms: @constructor)\n\n\nThis function is intended to be called with the \"new\" keyword.\n\n\n\n\n\n\n@classdesc\n\n\nUse the following text to describe the entire class.\n\n\n\n\n\n\n@constant\n (synonyms: @const)\n\n\nDocument an object as a constant.\n\n\n\n\n\n\n@constructs\n\n\nThis function member will be the constructor for the previous class.\n\n\n\n\n\n\n@copyright\n\n\nDocument some copyright information.\n\n\n\n\n\n\n@default\n (synonyms: @defaultvalue)\n\n\nDocument the default value.\n\n\n\n\n\n\n@deprecated\n\n\nDocument that this is no longer the preferred way.\n\n\n\n\n\n\n@description\n (synonyms: @desc)\n\n\nDescribe a symbol.\n\n\n\n\n\n\n@enum\n\n\nDocument a collection of related properties.\n\n\n\n\n\n\n@event\n\n\nDocument an event.\n\n\n\n\n\n\n@example\n\n\nProvide an example of how to use a documented item.\n\n\n\n\n\n\n@exports\n\n\nIdentify the member that is exported by a JavaScript module.\n\n\n\n\n\n\n@external\n (synonyms: @host)\n\n\nIdentifies an external class or module.\n\n\n\n\n\n\n@file\n (synonyms: @fileoverview or @overview)\n\n\nDescribe a file.\n\n\n\n\n\n\n@fires\n (synonyms: @emits)\n\n\nDescribe the events this method may fire.\n\n\n\n\n\n\n@function\n (synonyms: @funco or @method)\n\n\nDescribe a function or method.\n\n\n\n\n\n\n@global\n\n\nDocument a global object.\n\n\n\n\n\n\n@ignore\n\n\nOmit a symbol from the documentation.\n\n\n\n\n\n\n@implements\n\n\nThis symbol implements an interface.\n\n\n\n\n\n\n@inheritdoc\n\n\nIndicate that a symbol should inherit its parent's documentation.\n\n\n\n\n\n\n@instance\n\n\nDocument an instance member.\n\n\n\n\n\n\n@interface\n\n\nThis symbol is an interface that others can implement.\n\n\n\n\n\n\n@lends\n\n\nDocument properties on an object literal as if they belonged to a symbol with a given name.\n\n\n\n\n\n\n@license\n\n\nIdentify the license that applies to this code.\n\n\n\n\n\n\n@listens\n\n\nList the events that a symbol listens for.\n\n\n\n\n\n\n@member\n (synonyms: @var)\n\n\nDocument a member.\n\n\n\n\n\n\n@mixin\n\n\nDocument a mixin object.\n\n\n\n\n\n\n@module\n\n\nDocument a JavaScript module.\n\n\n\n\n\n\n@name\n\n\nDocument the name of an object.\n\n\n\n\n\n\n@namespace\n\n\nDocument a namespace object.\n\n\n\n\n\n\n@override\n\n\nIndicate that a symbol overrides its parent.\n\n\n\n\n\n\n@param\n (synonyms: @arg or @argument)\n\n\nDocument the parameter to a function.\n\n\n\n\n\n\n@property\n (synonyms: @prop)\n\n\nDocument a property of an object.\n\n\n\n\n\n\n@protected\n\n\nThis symbol is meant to be protected.\n\n\n\n\n\n\n@public\n\n\nThis symbol is meant to be public.\n\n\n\n\n\n\n@readonly\n\n\nThis symbol is meant to be read-only.\n\n\n\n\n\n\n@requires\n\n\nThis file requires a JavaScript module.\n\n\n\n\n\n\n@returns\n (synonyms: @return)\n\n\nDocument the return value of a function.\n\n\n\n\n\n\n@see\n\n\nRefer to some other documentation for more information.\n\n\n\n\n\n\n@static\n\n\nDocument a static member.\n\n\n\n\n\n\n@summary\n\n\nA shorter version of the full description.\n\n\n\n\n\n\n@this\n\n\nWhat does the 'this' keyword refer to here?\n\n\n\n\n\n\n@throws\n (synonyms: @exception)\n\n\nDescribe what errors could be thrown.\n\n\n\n\n\n\n@todo\n\n\nDocument tasks to be completed.\n\n\n\n\n\n\n@tutorial\n\n\nInsert a link to an included tutorial file.\n\n\n\n\n\n\n@type\n\n\nDocument the type of an object.\n\n\n\n\n\n\n@typedef\n\n\nDocument a custom type.", 
            "title": "Documenting"
        }, 
        {
            "location": "/groundstation/documenting/#documenting", 
            "text": "The ground station uses  jsdocs  for its documentation purposes.  If you're familiar with JavaDoc or PHPDoc, then its very similar. Essentially you add comments\nto your code using a double star comment in the form of  /** your comment */  and the jsdoc \ninterpreter generates nice well-described documentation based on your source code files.  A good tutorial of what it is, why we use it, and how to use it can be found here:  http://speakingjs.com/es5/ch29.html .  You are required to document the necessary part of your code with this format.", 
            "title": "Documenting"
        }, 
        {
            "location": "/groundstation/documenting/#jsdoc-reference", 
            "text": "Block  Description      @abstract \u02d9(synonyms: @virtual)  This member must be implemented (or overridden) by the inheritor.    @author  Identify the author of an item.    @callback  Document a callback function.    @class  (synonyms: @constructor)  This function is intended to be called with the \"new\" keyword.    @classdesc  Use the following text to describe the entire class.    @constant  (synonyms: @const)  Document an object as a constant.    @constructs  This function member will be the constructor for the previous class.    @copyright  Document some copyright information.    @default  (synonyms: @defaultvalue)  Document the default value.    @deprecated  Document that this is no longer the preferred way.    @description  (synonyms: @desc)  Describe a symbol.    @enum  Document a collection of related properties.    @event  Document an event.    @example  Provide an example of how to use a documented item.    @exports  Identify the member that is exported by a JavaScript module.    @external  (synonyms: @host)  Identifies an external class or module.    @file  (synonyms: @fileoverview or @overview)  Describe a file.    @fires  (synonyms: @emits)  Describe the events this method may fire.    @function  (synonyms: @funco or @method)  Describe a function or method.    @global  Document a global object.    @ignore  Omit a symbol from the documentation.    @implements  This symbol implements an interface.    @inheritdoc  Indicate that a symbol should inherit its parent's documentation.    @instance  Document an instance member.    @interface  This symbol is an interface that others can implement.    @lends  Document properties on an object literal as if they belonged to a symbol with a given name.    @license  Identify the license that applies to this code.    @listens  List the events that a symbol listens for.    @member  (synonyms: @var)  Document a member.    @mixin  Document a mixin object.    @module  Document a JavaScript module.    @name  Document the name of an object.    @namespace  Document a namespace object.    @override  Indicate that a symbol overrides its parent.    @param  (synonyms: @arg or @argument)  Document the parameter to a function.    @property  (synonyms: @prop)  Document a property of an object.    @protected  This symbol is meant to be protected.    @public  This symbol is meant to be public.    @readonly  This symbol is meant to be read-only.    @requires  This file requires a JavaScript module.    @returns  (synonyms: @return)  Document the return value of a function.    @see  Refer to some other documentation for more information.    @static  Document a static member.    @summary  A shorter version of the full description.    @this  What does the 'this' keyword refer to here?    @throws  (synonyms: @exception)  Describe what errors could be thrown.    @todo  Document tasks to be completed.    @tutorial  Insert a link to an included tutorial file.    @type  Document the type of an object.    @typedef  Document a custom type.", 
            "title": "JSDoc Reference"
        }, 
        {
            "location": "/groundstation/resources/", 
            "text": "Additional Resources\n\n\nThe following is a list of helpful resources that you can use in case you get stuck:\n\n\nDocumentation:\n\n\n\n\nJavascript Documentation\n\n\nNW.js Documentation\n\n\nNode.js Documentation\n\n\nMarionette Documentation\n\n\nBackbone Documentation\n\n\nUnderscore Documentation\n\n\nJquery Documentation\n\n\n\n\nTutorials\n\n\n\n\nCodeAcademy Javascript course\n\n\nCodeAcademy HTML \n CSS course\n\n\nCodeAcademy jQuery course\n\n\n\n\nHelp\n\n\nTheres a huge community around javascript and node.js. 99% of the issues you'll encounter you can resolve by a simple google or stack overflow search.\n\n\nCommon problems\n\n\nQ: A module or library or something is complaining about \nwindow\n or \ndocument\n being undefined.\n\n\nA: \nRead this section about NW.js contexts\n\n\nTips\n\n\n\n\nIf you're using windows and want a much better terminal, use \ncmder\n\n\nIf you want to consolidate all of the documentation sources together, there's a really good site called \nDevDocs.io", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/groundstation/resources/#additional-resources", 
            "text": "The following is a list of helpful resources that you can use in case you get stuck:", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/groundstation/resources/#documentation", 
            "text": "Javascript Documentation  NW.js Documentation  Node.js Documentation  Marionette Documentation  Backbone Documentation  Underscore Documentation  Jquery Documentation", 
            "title": "Documentation:"
        }, 
        {
            "location": "/groundstation/resources/#tutorials", 
            "text": "CodeAcademy Javascript course  CodeAcademy HTML   CSS course  CodeAcademy jQuery course", 
            "title": "Tutorials"
        }, 
        {
            "location": "/groundstation/resources/#help", 
            "text": "Theres a huge community around javascript and node.js. 99% of the issues you'll encounter you can resolve by a simple google or stack overflow search.", 
            "title": "Help"
        }, 
        {
            "location": "/groundstation/resources/#common-problems", 
            "text": "Q: A module or library or something is complaining about  window  or  document  being undefined.  A:  Read this section about NW.js contexts", 
            "title": "Common problems"
        }, 
        {
            "location": "/groundstation/resources/#tips", 
            "text": "If you're using windows and want a much better terminal, use  cmder  If you want to consolidate all of the documentation sources together, there's a really good site called  DevDocs.io", 
            "title": "Tips"
        }, 
        {
            "location": "/picpilot/", 
            "text": "Welcome to the PicPilot wiki!\n\n\nThis site is to document all the functions and required background knowledge about the autopilot system.\n\n\n\n\nIntroduction\n\n\nSetup\n\n\nC\n\n\nProgramming the Device\n\n\nAutopilot System Overview\n\n\nSchematics and Board Design\n\n\nProject Files\n\n\nCoding Convention\n\n\n\n\n\n\nPID Loops\n\n\nPWM I/O\n\n\nUniversal Asynchronous Receive/Transmit (UART)\n\n\nSerial Peripheral Interface (SPI)\n\n\nDirect Memory Access (DMA)\n\n\nInter-Interchip Communication (I2C)\n\n\nDatalink\n\n\nAnalog-to-Digital Converter (ADC)\n\n\nSensors and Peripherals\n\n\nGPS(MEDIATEK-3329)\n\n\nIMU (VectorNav-100)\n\n\nAltimeter (MPL3115A2)\n\n\nXBEE PRO S3B\n\n\nRC Receiever (EzUHF)\n\n\nAirspeed Sensor (To be implemented)\n\n\nUltrasonic Sensor (To be implemented)\n\n\n\n\n\n\nAttitude Control\n\n\nPath Management\n\n\nFAQ - WIP\n\n\n\n\nBackground Reading\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/picpilot/#welcome-to-the-picpilot-wiki", 
            "text": "This site is to document all the functions and required background knowledge about the autopilot system.   Introduction  Setup  C  Programming the Device  Autopilot System Overview  Schematics and Board Design  Project Files  Coding Convention    PID Loops  PWM I/O  Universal Asynchronous Receive/Transmit (UART)  Serial Peripheral Interface (SPI)  Direct Memory Access (DMA)  Inter-Interchip Communication (I2C)  Datalink  Analog-to-Digital Converter (ADC)  Sensors and Peripherals  GPS(MEDIATEK-3329)  IMU (VectorNav-100)  Altimeter (MPL3115A2)  XBEE PRO S3B  RC Receiever (EzUHF)  Airspeed Sensor (To be implemented)  Ultrasonic Sensor (To be implemented)    Attitude Control  Path Management  FAQ - WIP", 
            "title": "Welcome to the PicPilot wiki!"
        }, 
        {
            "location": "/picpilot/#background-reading", 
            "text": "Information on Model Aircraft  General Aerodynamic Principles  Git Help", 
            "title": "Background Reading"
        }, 
        {
            "location": "/picpilot/introduction/", 
            "text": "Introduction\n\n\nThe PICpilot is a software package meant to control fixed-wing aircraft and numerous \"copters\", among other vehicles. It requires the usage of a specific type of digital signal microcontroller. This microcontroller is produced by \nMicrochip\n. The microcontroller that is currently supported is the \ndspic33fj256gp710A\n. However, many other similar models can be easily adapted for support.\n\n\nThis software is designed to be used with two communicating microcontrollers (essential double cores). Due to the atypical nature of the software, it is recommended to view the board schematics \nhere\n. The schematics are also included in another section of this document.\n\n\nThe two processors are allocated to two individual tasks. The chip which is responsible for attitude management is often referred to as the \"main\" chip. It is responsible for making corrections to the planes orientation in space, which involves pitch, roll, yaw, heading, throttle, and altitude. It also manages a few additional tasks involving relaying communication with the ground station. The second processor is often referred to as the \"Path Manager\". This chip controls the where the plane should fly (path), and the transitions in altitude and heading between each waypoint (specific GPS coordinates). It also controls the GPS and altitude sensors. These two chips work asynchronously from one another in order to automate the plane.\n\n\nSetup\n\n\nTo get started, you will need three things:\n\n A Git Client - https://github.com/\n\n MPLAB XC16 Compiler (16-bit) - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2\n* (Optional) MPLAB X IDE - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2\n\n\nGithub Setup\n\n\nA similar powerpoint presentation can be found here:\nhttps://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing\n\n\nIf you are not using the GUI skip this section.\n\n\n\n\nSetup a \nGithub\n Account\n\n\nSelect \"Set up Git\"\n\n\nSelect \"Download GitHub for \n\"\n\n\nSelect \"Run\" and continue through the installation process\n\n\nOnce the installation is complete, launch the application.\n\n\nLog in\n\n\nFind the Git Bash shell and type in the following commands:\n\n\ngit config global user.name \"YOUR USERNAME HERE\"\n\n\ngit config global user.email \"YOUR EMAIL HERE\"\n\nThese set the default name and email you use when committing to GitHub.\n\n\nAt this point you will need to let one of the WARG team leads know your username, so that you can be added to the repository member's list.\n\n\nYou should then be able to clone the project using the clone button, or the project URL.  \n\n\n\n\nYou should now have the code. \n\n\nMPLAB Setup\n\n\nYou now need the libraries and compilers, as well as the optional MPLAB X IDE, in order to develop code.\n\n\nCompiler\n\n\n\n\nDownload the \ncompiler\n. You want the MPLAB XC16 Compiler V1.21 or newer. Unzip the file once it is completed.\n\n\nAccept the license agreement.\n\n\nSelect \"Install Compiler\".\n\n\nSelect \"Install MPLAB XC16 C Compiler on this computer.\n\n\nLeave the activation key blank. Confirm \"Yes\" when the dialog prompts you about using the free version.\n\n\nSelect \"Run the compiler in free mode\".\n\n\nSelect the installation directory.\n\n\n\n\nRun and finish the installation.\n\n\n\n\n\n\nNote whenever you make a new project, make sure the right compiler is selected, otherwise there will be a lot of indicated syntax errors (red underlines).\n\n\n\n\n\n\nIDE (The fancy word editor that lets you do some code-shenanigans)\n\n\n\n\nDownload the \nIDE Package\n. You want the MPLAB X IDE V2.10 or newer. Unzip the file once it is completed.\n\n\nProceed through the installation process (select installation directory, accept license agreement).\n\n\n\n\nGitHub Usage\n\n\nIf you don't know how to use Git or you need a reference, \nGitImmersion\n is a great website.\n\n\nGUI Usage:\n\n\n\n\nMake sure you have correctly set your default storage location in the Options menu.  \n\n\n\n\nSaving Files (Committing and Pushing)\n  \n\n\n\n\nSelect your Project\n\n\nSelect the files that are supposed to be committed.\n\n\nWrite a commit message, that gives a general overview about each change completed in this update.\n\n\nHit \"Commit\".\n\n\nOnce you are ready to sync the changes, hit the sync button (top of the window).\n\n\n\n\nReading Files from the Server (Pulling)\n\n* Simply click the sync button at top of the window.\n\n\nGeneral Syntax (Git Bash):\n\n\n\n\ngit add \nFilename\n or git add .\n stages the file for commit.\n\n\ngit status\n displays all changes being made.\n\n\ngit commit -m \"\nCommit message here\n\"\n makes the change.\n\n\ngit push\n sends the change to the server\n\n\ngit pull\n retrieves the latest change from the server.\n\n\ngit checkout \nHASH\n retrieves a SPECIFIC version from the server.\n\n\ngit checkout -b \nBranch Name\n creates a new branch.\n\n\ngit merge master\n merges the current branch with the latest code.\n\n\n\n\nGeneral Concepts:\n\n\n\n\nWhen making small changes it is okay to commit to the master branch.\n\n\nWhen making large changes (that take multiple days to complete), always make a branch, so that others can work concurrently without compiling broken code.\n\n\nAlways build your code before committing (To make sure it isn't broken).\n\n\nTry and get rid of warnings if possible.\n\n\n\n\nC (Programming Language)\n\n\nThe language being used in this project is C. If you are familiar with C++, the concepts are very similar. C is a low level programming language. This means that it does not have a large amount of \"built-in\" functionality, therefore learning C is quite straight forward.\n\n\nThe compiler used for this project is listed above. It is a modified version of the GCC Compiler.\n\n\nA set of well maintained tutorials can be found here: \nhttp://www.cprogramming.com/tutorial/c/lesson1.html\n\n\nTopics that one should be familiar with include (in order of importance):\n\n\n\n\nIf statements\n\n\nLooping\n\n\nFunctions\n\n\nVariable types and how they work\n\n\nArrays\n\n\nPointers\n\n\nStructures, Unions\n\n\n\n\nUnrelated topics:\n\n\n\n\nPrintf (There is no GUI)\n\n\nFile I/O (All I/O operations are specific to the chip)\n\n\n\n\nKnowledge of common data structures (binary trees, linked lists, etc.) is beneficial, but not mandatory.\n\n\nProgramming the Device\n\n\nIn order to program the device, you must have setup your account according to the Setup section. You should also refer to the Schematics and Board Design section for the ports required to complete the programming process. You will require an ICD 3 or a similar programming device.\n\n\nWhen using the MPLAB X GUI the process to program the device is as follows:\n\n\n-\n  1. Ensure the project you wish to program is the main project.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Click the \"Make and Program Device\" button in the top toolbar. Optionally, you can also press the debug button to use the debugging features of MPLAB X.\n\n\nWhen using your own editor and compiling from the command line:\n\n\n-\n  1. Have the binary file ready for programming.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Open the MPLAB IPE interface.\n  4. Select your chip model.\n  5. For the source option, browse to your binary file.\n  6. Press program and wait. Then optionally also use the verify option (recommended).\n\n\nIf you are using both chips of the PICpilot, ensure you correctly set the chip identifier pre-compiler in the main.h file, and ensure you program both chips.\n\n\nAutopilot System Overview\n\n\nThe autopilot system is meant to be adaptable to any aircraft including fixed-wing and multi-rotor aircraft (still WIP). This document mostly covers the software design of the system, although there are a few hardware notes made in this section and the next.\n\n\nFirst of all, the flowchart block diagram of the system is presented below:\n\n\n\n\nFrom this diagram you can see how the software combined with the hardware interacts to provide the final resulting UAV behaviour.\n\n\nThere are three chips. The main one is most commonly referred to as the attitude manager. It is also the communication manager, and the Master chip for all interchip communication. The other chip is referred to as the path manager. The third one has the dedicated task of managing the mechanical \"safety\" relays which ensure that a safety pilot can always regain control of the aircraft.\n\n\nThere are four sensors used in the original design of the aircraft. A GPS (Global Positioning System), IMU (Inertial Measurement Unit), Altimeter, and a camera are all part of the system. Additionally, 2 wireless interfaces are included in the design. A wireless Xbee transmitter/receiver provides telemetry data, whereas an additional (Ultra-high frequency [UHF]) receiver is used to attain control from a standard RC controller.\n\n\nThe outputs from the system include pictures and potentially video, telemetry data, and a functioning aircraft (with moving flaps, elevators, rudder, and ailerons).\n\n\nThis document only covers the PICpilot, however a system overview of a previously fully assembled system will be described in this section. In the past, the PICpilot has been expanded into a larger and more sophisticated system as seen below.\n\n\n\n\nSchematics and Board Design\n\n\nThe following schematic was last used at the time of the writing this document. The following schematic was last updated in 2011. You can check out the board schematics \nhere\n. They may also be available within the Github repository. You will require \nDiptrace\n in order to view the files. You can use the free version or use WARG's \"Pro\" license.\n\n\n\n\nThis board has 2 dspic33fj256710a chips. This is the PCB for the board. This is the labelled version:\n\n\n\n\n\n\n\n\nMicrocontroller 1 -\u0093 Attitude/Communication Manager\n\n\n\n\n\n\nMicrocontroller 2 -\u0093 Path Manager\n\n\n\n\n\n\nInput PWM\n\n\n\n\n\n\nOutput PWM\n\n\n\n\n\n\nOutput PWM Safety Relay\n\n\n\n\n\n\nOutput PWM Safety Relay Microcontroller\n\n\n\n\n\n\nOutput PWM Safety Relay Microcontroller Programming Port\n\n\n\n\n\n\nMicrocontroller 2 Programming Port\n\n\n\n\n\n\nSPI2 Port - VectorNav-100\n\n\n\n\n\n\nSPI2 Ports -\u0093 GPS\n\n\n\n\n\n\nSwitching Power Supply 1\n\n\n\n\n\n\nSwitching Power Supply 2\n\n\n\n\n\n\nVoltage Regulator\n\n\n\n\n\n\nSPI2 Port -\u0093 Used as a power source for the altimeter\n\n\n\n\n\n\nUART1 Port -\u0093 Debug\n\n\n\n\n\n\nUART2 Port -\u0093 Wireless Transmitter (Xbee)\n\n\n\n\n\n\nSPI2 Port -\u0093 Altimeter\n\n\n\n\n\n\nUART1 Port -\u0093 Debug\n\n\n\n\n\n\nUART2 Port -\u0093 Unused\n\n\n\n\n\n\nMicrocontroller 2 Programming Port\n\n\n\n\n\n\nPWM input/output -\u0093 Sonar\n\n\n\n\n\n\nThe important pins are listed below:\n\n\n\n\nThe schematics for the board are below:\n\n\n\n\n\n\n\n\n\n\nProject files\n\n\nAll the project files are hosted on Github. However, for convenience they are listed below (accurate at the time of writing of this document):\n\n\n\n\nAttitudeManager.c\n\n\nAttitudeManager.h\n\n\ncameraManager.c\n\n\ncameraManager.h\n\n\nClock.c\n\n\nClock.h\n\n\ncommands.h\n\n\ndebug.c\n\n\ndebug.h\n\n\ndelay.c\n\n\ndelay.h\n\n\nfmath.c\n\n\nfmath.h\n\n\nFullInitialize.c\n\n\nFullInitialize.h\n\n\nI2C.c\n\n\nI2C.h\n\n\nInputCapture.c\n\n\nInputCapture.h\n\n\nInterchipDMA.c\n\n\nInterchipDMA.h\n\n\nlcd.h\n\n\nmain.c\n\n\nmain.h\n\n\nMPL3115A2.c\n\n\nMPL3115A2.h\n\n\nnet.h\n\n\nnet_common.c\n\n\nnet_inbound.c\n\n\nnet_outbound.c\n\n\nOrientationControl.c\n\n\nOrientationControl.h\n\n\nOutputCompare.c\n\n\nOutputCompare.h\n\n\nPathManager.h\n\n\nPathManager.c\n\n\nPWM.c\n\n\nPWM.h\n\n\nSPI.c\n\n\nStartupErrorCodes.c\n\n\nStartupErrorCodes.h\n\n\nStringUtils.c\n\n\nStringUtils.h\n\n\nUART1.c\n\n\nUART1.h\n\n\nUART2.c\n\n\nUART2.h\n\n\nVN_lib.c\n\n\nVN_lib.h\n\n\nVN_math.c\n\n\nVN_math.h\n\n\nVN_type.h\n\n\nVN_user.c\n\n\nVN_user.h\n\n\nVN100.c\n\n\nVN100.h\n\n\nvoltageSensor.c\n\n\nvoltageSensor.h\n\n\n\n\nCoding Convention\n\n\nThe coding convention form this project follows the standard coding convention for the C language.\n\n\nThe rule-set for the coding format is not extremely specific. However, there are a few rules of thumb to be aware of. The rules of thumb are:\n\n\n\n\nNaming convention\n -\u0093 Use \ncamelCase\n notation for variables. Use capitals and \nunder_score_case\n for constants.\n\n\nIndentation Style\n -\u0093 Use tabs/indents to show the program structure.\n\n\nCommenting -\u0093 Be thorough with comments. Include a header at the beginning of every file describing the file, the author, the file name, and the date of creation. For headers, include comments describing any constants, and for each function prototype include the function name, function inputs and outputs, and a description of its functionality.\n\n\nNever hard-code values\n. Any constants should be defined together so that they can be easily changed through iterations of the code.", 
            "title": "Introduction"
        }, 
        {
            "location": "/picpilot/introduction/#introduction", 
            "text": "The PICpilot is a software package meant to control fixed-wing aircraft and numerous \"copters\", among other vehicles. It requires the usage of a specific type of digital signal microcontroller. This microcontroller is produced by  Microchip . The microcontroller that is currently supported is the  dspic33fj256gp710A . However, many other similar models can be easily adapted for support.  This software is designed to be used with two communicating microcontrollers (essential double cores). Due to the atypical nature of the software, it is recommended to view the board schematics  here . The schematics are also included in another section of this document.  The two processors are allocated to two individual tasks. The chip which is responsible for attitude management is often referred to as the \"main\" chip. It is responsible for making corrections to the planes orientation in space, which involves pitch, roll, yaw, heading, throttle, and altitude. It also manages a few additional tasks involving relaying communication with the ground station. The second processor is often referred to as the \"Path Manager\". This chip controls the where the plane should fly (path), and the transitions in altitude and heading between each waypoint (specific GPS coordinates). It also controls the GPS and altitude sensors. These two chips work asynchronously from one another in order to automate the plane.", 
            "title": "Introduction"
        }, 
        {
            "location": "/picpilot/introduction/#setup", 
            "text": "To get started, you will need three things:  A Git Client - https://github.com/  MPLAB XC16 Compiler (16-bit) - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2\n* (Optional) MPLAB X IDE - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2", 
            "title": "Setup"
        }, 
        {
            "location": "/picpilot/introduction/#github-setup", 
            "text": "A similar powerpoint presentation can be found here: https://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing  If you are not using the GUI skip this section.   Setup a  Github  Account  Select \"Set up Git\"  Select \"Download GitHub for  \"  Select \"Run\" and continue through the installation process  Once the installation is complete, launch the application.  Log in  Find the Git Bash shell and type in the following commands:  git config global user.name \"YOUR USERNAME HERE\"  git config global user.email \"YOUR EMAIL HERE\" \nThese set the default name and email you use when committing to GitHub.  At this point you will need to let one of the WARG team leads know your username, so that you can be added to the repository member's list.  You should then be able to clone the project using the clone button, or the project URL.     You should now have the code.", 
            "title": "Github Setup"
        }, 
        {
            "location": "/picpilot/introduction/#mplab-setup", 
            "text": "You now need the libraries and compilers, as well as the optional MPLAB X IDE, in order to develop code.", 
            "title": "MPLAB Setup"
        }, 
        {
            "location": "/picpilot/introduction/#compiler", 
            "text": "Download the  compiler . You want the MPLAB XC16 Compiler V1.21 or newer. Unzip the file once it is completed.  Accept the license agreement.  Select \"Install Compiler\".  Select \"Install MPLAB XC16 C Compiler on this computer.  Leave the activation key blank. Confirm \"Yes\" when the dialog prompts you about using the free version.  Select \"Run the compiler in free mode\".  Select the installation directory.   Run and finish the installation.    Note whenever you make a new project, make sure the right compiler is selected, otherwise there will be a lot of indicated syntax errors (red underlines).", 
            "title": "Compiler"
        }, 
        {
            "location": "/picpilot/introduction/#ide-the-fancy-word-editor-that-lets-you-do-some-code-shenanigans", 
            "text": "Download the  IDE Package . You want the MPLAB X IDE V2.10 or newer. Unzip the file once it is completed.  Proceed through the installation process (select installation directory, accept license agreement).", 
            "title": "IDE (The fancy word editor that lets you do some code-shenanigans)"
        }, 
        {
            "location": "/picpilot/introduction/#github-usage", 
            "text": "If you don't know how to use Git or you need a reference,  GitImmersion  is a great website.", 
            "title": "GitHub Usage"
        }, 
        {
            "location": "/picpilot/introduction/#gui-usage", 
            "text": "Make sure you have correctly set your default storage location in the Options menu.     Saving Files (Committing and Pushing)      Select your Project  Select the files that are supposed to be committed.  Write a commit message, that gives a general overview about each change completed in this update.  Hit \"Commit\".  Once you are ready to sync the changes, hit the sync button (top of the window).   Reading Files from the Server (Pulling) \n* Simply click the sync button at top of the window.", 
            "title": "GUI Usage:"
        }, 
        {
            "location": "/picpilot/introduction/#general-syntax-git-bash", 
            "text": "git add  Filename  or git add .  stages the file for commit.  git status  displays all changes being made.  git commit -m \" Commit message here \"  makes the change.  git push  sends the change to the server  git pull  retrieves the latest change from the server.  git checkout  HASH  retrieves a SPECIFIC version from the server.  git checkout -b  Branch Name  creates a new branch.  git merge master  merges the current branch with the latest code.", 
            "title": "General Syntax (Git Bash):"
        }, 
        {
            "location": "/picpilot/introduction/#general-concepts", 
            "text": "When making small changes it is okay to commit to the master branch.  When making large changes (that take multiple days to complete), always make a branch, so that others can work concurrently without compiling broken code.  Always build your code before committing (To make sure it isn't broken).  Try and get rid of warnings if possible.", 
            "title": "General Concepts:"
        }, 
        {
            "location": "/picpilot/introduction/#c-programming-language", 
            "text": "The language being used in this project is C. If you are familiar with C++, the concepts are very similar. C is a low level programming language. This means that it does not have a large amount of \"built-in\" functionality, therefore learning C is quite straight forward.  The compiler used for this project is listed above. It is a modified version of the GCC Compiler.  A set of well maintained tutorials can be found here:  http://www.cprogramming.com/tutorial/c/lesson1.html  Topics that one should be familiar with include (in order of importance):   If statements  Looping  Functions  Variable types and how they work  Arrays  Pointers  Structures, Unions   Unrelated topics:   Printf (There is no GUI)  File I/O (All I/O operations are specific to the chip)   Knowledge of common data structures (binary trees, linked lists, etc.) is beneficial, but not mandatory.", 
            "title": "C (Programming Language)"
        }, 
        {
            "location": "/picpilot/introduction/#programming-the-device", 
            "text": "In order to program the device, you must have setup your account according to the Setup section. You should also refer to the Schematics and Board Design section for the ports required to complete the programming process. You will require an ICD 3 or a similar programming device.  When using the MPLAB X GUI the process to program the device is as follows:  -\n  1. Ensure the project you wish to program is the main project.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Click the \"Make and Program Device\" button in the top toolbar. Optionally, you can also press the debug button to use the debugging features of MPLAB X.  When using your own editor and compiling from the command line:  -\n  1. Have the binary file ready for programming.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Open the MPLAB IPE interface.\n  4. Select your chip model.\n  5. For the source option, browse to your binary file.\n  6. Press program and wait. Then optionally also use the verify option (recommended).  If you are using both chips of the PICpilot, ensure you correctly set the chip identifier pre-compiler in the main.h file, and ensure you program both chips.", 
            "title": "Programming the Device"
        }, 
        {
            "location": "/picpilot/introduction/#autopilot-system-overview", 
            "text": "The autopilot system is meant to be adaptable to any aircraft including fixed-wing and multi-rotor aircraft (still WIP). This document mostly covers the software design of the system, although there are a few hardware notes made in this section and the next.  First of all, the flowchart block diagram of the system is presented below:   From this diagram you can see how the software combined with the hardware interacts to provide the final resulting UAV behaviour.  There are three chips. The main one is most commonly referred to as the attitude manager. It is also the communication manager, and the Master chip for all interchip communication. The other chip is referred to as the path manager. The third one has the dedicated task of managing the mechanical \"safety\" relays which ensure that a safety pilot can always regain control of the aircraft.  There are four sensors used in the original design of the aircraft. A GPS (Global Positioning System), IMU (Inertial Measurement Unit), Altimeter, and a camera are all part of the system. Additionally, 2 wireless interfaces are included in the design. A wireless Xbee transmitter/receiver provides telemetry data, whereas an additional (Ultra-high frequency [UHF]) receiver is used to attain control from a standard RC controller.  The outputs from the system include pictures and potentially video, telemetry data, and a functioning aircraft (with moving flaps, elevators, rudder, and ailerons).  This document only covers the PICpilot, however a system overview of a previously fully assembled system will be described in this section. In the past, the PICpilot has been expanded into a larger and more sophisticated system as seen below.", 
            "title": "Autopilot System Overview"
        }, 
        {
            "location": "/picpilot/introduction/#schematics-and-board-design", 
            "text": "The following schematic was last used at the time of the writing this document. The following schematic was last updated in 2011. You can check out the board schematics  here . They may also be available within the Github repository. You will require  Diptrace  in order to view the files. You can use the free version or use WARG's \"Pro\" license.   This board has 2 dspic33fj256710a chips. This is the PCB for the board. This is the labelled version:     Microcontroller 1 -\u0093 Attitude/Communication Manager    Microcontroller 2 -\u0093 Path Manager    Input PWM    Output PWM    Output PWM Safety Relay    Output PWM Safety Relay Microcontroller    Output PWM Safety Relay Microcontroller Programming Port    Microcontroller 2 Programming Port    SPI2 Port - VectorNav-100    SPI2 Ports -\u0093 GPS    Switching Power Supply 1    Switching Power Supply 2    Voltage Regulator    SPI2 Port -\u0093 Used as a power source for the altimeter    UART1 Port -\u0093 Debug    UART2 Port -\u0093 Wireless Transmitter (Xbee)    SPI2 Port -\u0093 Altimeter    UART1 Port -\u0093 Debug    UART2 Port -\u0093 Unused    Microcontroller 2 Programming Port    PWM input/output -\u0093 Sonar    The important pins are listed below:   The schematics for the board are below:", 
            "title": "Schematics and Board Design"
        }, 
        {
            "location": "/picpilot/introduction/#project-files", 
            "text": "All the project files are hosted on Github. However, for convenience they are listed below (accurate at the time of writing of this document):   AttitudeManager.c  AttitudeManager.h  cameraManager.c  cameraManager.h  Clock.c  Clock.h  commands.h  debug.c  debug.h  delay.c  delay.h  fmath.c  fmath.h  FullInitialize.c  FullInitialize.h  I2C.c  I2C.h  InputCapture.c  InputCapture.h  InterchipDMA.c  InterchipDMA.h  lcd.h  main.c  main.h  MPL3115A2.c  MPL3115A2.h  net.h  net_common.c  net_inbound.c  net_outbound.c  OrientationControl.c  OrientationControl.h  OutputCompare.c  OutputCompare.h  PathManager.h  PathManager.c  PWM.c  PWM.h  SPI.c  StartupErrorCodes.c  StartupErrorCodes.h  StringUtils.c  StringUtils.h  UART1.c  UART1.h  UART2.c  UART2.h  VN_lib.c  VN_lib.h  VN_math.c  VN_math.h  VN_type.h  VN_user.c  VN_user.h  VN100.c  VN100.h  voltageSensor.c  voltageSensor.h", 
            "title": "Project files"
        }, 
        {
            "location": "/picpilot/introduction/#coding-convention", 
            "text": "The coding convention form this project follows the standard coding convention for the C language.  The rule-set for the coding format is not extremely specific. However, there are a few rules of thumb to be aware of. The rules of thumb are:   Naming convention  -\u0093 Use  camelCase  notation for variables. Use capitals and  under_score_case  for constants.  Indentation Style  -\u0093 Use tabs/indents to show the program structure.  Commenting -\u0093 Be thorough with comments. Include a header at the beginning of every file describing the file, the author, the file name, and the date of creation. For headers, include comments describing any constants, and for each function prototype include the function name, function inputs and outputs, and a description of its functionality.  Never hard-code values . Any constants should be defined together so that they can be easily changed through iterations of the code.", 
            "title": "Coding Convention"
        }, 
        {
            "location": "/picpilot/pid-loops/", 
            "text": "PID Loops\n\n\nPID Loops are vital to the functionality of the PICpilot Autopilot software. UAV systems (especially fixed-wing) are difficult to characterize through a mathematical model. Hence, a control algorithm, such as a PID loop, simplifies the process. It does so by making small changes to the system at regular intervals. The algorithm tracks changes in the past (short term and long term) and the present to be adaptive to future conditions. For instance, if a sudden disturbance is introduced into the system, differential control will compensate and attempt to stabilize the system.\n\n\nThe letters \"PID\" stand for:\n\n\n\n\n\n\nProportional Control \u2013 This stabilizes any instantaneous changes to the system\n\n\n\n\n\n\nIntegral Control \u2013 This stabilizes and reduces long-term error in the system\n\n\n\n\n\n\nDerivative Control \u2013 This stabilizes abrupt changes (large derivative values).\n\n\n\n\n\n\nPI systems are usually more common than PID systems. Nonetheless, a common PID system would look like this:\n\n\n\n\nA common PID control loop\n\n\nIn a PID system, the input, r(t), is compared with the output, y(t), in the time domain. The subtraction between these two values yields the error, e(t). The error is then fed into the PID modules. Note each module contains a constant Kd, Kp, Ki. These are scaling factors. They determine the proportions in which each module adds together.\n\n\nFor the proportional module, the error is simply multiplied by a factor.\n\n\nFor the integral module, the error is integrated over time, before being multiplied by its corresponding factor.\n\n\nFor the derivative module, the error is differentiated at each time step, before being multiplied by its corresponding factor.\n\n\nThese three values are added together to determine u(t), which controls the system (plane, quadcopter, etc.). This can be expressed through the following code segment:\n\n\nint controlSignal = (int)(HEADING_ROLL_SCALE_FACTOR * ((dValue * kd_gain[HEADING]) + (error * kp_gain[HEADING]) + (sum_gain[HEADING] * ki_gain[HEADING])));\n\n\nWhere \nHEADING_ROLL_SCALE _FACTOR\n is a dimensionless scale factor.\n\n\nWhere \ndValue\n is the derivative.\n\n\nWhere \nsum_gain\n is the integral summation over time.\n\n\nWhere \nerror\n is the setpoint minus the output.\n\n\nWhere \nkd_gain\n is the derivative gain.\n\n\nWhere \nkp_gain\n is the proportional gain.\n\n\nWhere \nki_gain\n is the integral gain.\n\n\nNote that abrupt changes would affect the derivative term, gradual drift would affect the integral term, and anything in between would affect the proportional term.\n\n\nThe PID model used in the PICpilot is slightly different. Some modules are rearranged, and a hierarchy of PID loops is present.\n\n\nRate Control\n\n\nRate control is the basis of most aerial aircraft. The flaps on the wings of a plane control the rate at which it turns or rotates, but not the actual angle of the aircraft. For instance, if the flaps on a fixed wing aircraft were fully deflected, the aircraft would continuously spin out of control. It will not stop at a certain angle. In that sense, you control the \nrate of angular rotation\n, also known as the derivative. Likewise, the sensors on the aircraft (gyroscopes), measure the rate of rotation (derivative). This provides an interesting PID system. This PID loop only contains the derivative term. Hence the name \"rate control\".  The rate control diagram looks like this:\n\n\n\n\nRate control PID loop\n\n\nThe equation that relates the input with the output is:\n\n\nControl Signal = (dx \u2013 dy) * Kd\n\n\nControl Signal = de * Kd\n\n\nRate Control - In The Code\n\n\nRate Control takes place at the end of the program execution cycle. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function that completes the calculation is called:\n\n\nint controlSignal(float setpoint, float output, unsigned char type)\n\n\nThis function is responsible for the angular rates of the plane. It contains the differential equations that are part of the PID control system. It calculates the derivative term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg/s or rad/s). The units depend on the value of SERVO_SCALE_FACTOR which can be changed for various units. The original value was degrees per second.\n\n\nAngular Control\n\n\nOnce the roll, pitch, and yaw of the aircraft are empirically controlled (using the rate control code), the roll, pitch, and yaw can then be controlled in terms of angles. In other words, this PI controller allows the aircraft to be commanded to maintain a certain angle in the air, such as a 30 degree bank angle. This allows the aircraft to be controlled by the autopilot to turn, as well as alter its altitude.\n\n\nAn Inertial Measurement Unit (IMU) provides the sensory information required to control the plane in this manner. The IMU usually uses a Kalman filter and state estimation (using integration) to determine the position of the unit.\n\n\nThe resulting angular control PI loop incorporates the rate control loop from the section above. The angular control diagram looks like this:\n\n\n\n\nAngular Control PID Loop\n\n\nThe equations that relate r(t) and dx(t) are:\n\n\ndx(t) = (r \u2013 y) * Kp + Ki * integral(r-y,dt)\n\n\ndx(t) = e * Kp + Ki * integral(e,dt)\n\n\nAngular Control \u2013 In The Code\n\n\nAngular control code takes place right before the rate control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:\n\n\nint controlSignalAngles(float setpoint, float output, unsigned char type, float SERVO_SCALE_FACTOR_ANGLES)\n\n\nThis function is responsible for the orientation of the plane. It contains the equations that model a PID control system. It calculates the proportional and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg or rad), where the units depend on the value of SERVO_SCALE_FACTOR_ANGLES which can be changed for various units.\n\n\nHeading Control\n\n\nOnce rudimentary control of the aircraft is attained using the angular control loop and the rate control loop, the position of the aircraft can be controlled. As a result, the next control loop controls the heading of the aircraft. For instance, the plane can be directed at a 30 degree magnetic heading, and it will maintain that heading for as long as is required.\n\n\nThe measurements come from an external GPS sensor. The sensor measurements can also come from other sources, but they need to be in units of degrees. Currently, the calculations are done in degrees.\n\n\nThis control system uses the commonly recognized PID loop structure:\n\n\n\n\nHeading Control PID Loop\n\n\nThe equations that relate r(t) and h(t) are:\n\n\nr(t) = Kd * d(h \u2013 \u03b8)/dt + (h \u2013 \u03b8) * Kp + Ki * integral(h \u2013 \u03b8,dt)\n\n\nr(t) = Kd * de/dt + e * Kp + Ki * integral(e,dt)\n\n\nHeading Control \u2013 In The Code\n\n\nHeading control code takes place right before the angular control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:\n\n\nint controlSignalHeading(int setpoint, int output)\n\n\nThis function is responsible for steering the plane in the correct direction. It contains the equations that model a PID control system. It calculates the derivative, proportional, and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (currently in degrees).\n\n\nThis function completes a comparison between the setpoint and the output, and then decides if it should turn left or right. When the setpoint and the output are subtracted, the resulting error is set to be between -180 and +180, where -180 degrees indicates the requirement to bank left and +180 degrees indicates the requirement to bank right.\n\n\nThe remainder of the PID control is the same. An integrator, derivative, and proportional term is present.\n\n\nAltitude and Throttle Control\n\n\nAltitude and Throttle control are two separate control loops. However, they are highly dependent on one another. For instance, if the throttle is increased, the plane has a natural tendency to gain altitude. Likewise, if the throttle is decreased, the plane has a natural tendency to lose altitude. Likewise, the opposite is true; if the plane gains or losses altitude, the airspeed of the aircraft changes.\n\n\nBoth altitude and throttle control is established by the use of PID loops. Currently, altitude uses the \nproportional\n and _derivative _terms, whereas, throttle uses only the _proportional _term. You can determine this by looking at the gain settings for each PID loop (if the gain is zero, the respective PID term is unused).\n\n\nGenerally, the throttle control should be regulated using an airspeed sensor, in order to keep the airspeed constant. However, in cases where there is no airspeed sensor (such as in SPIKE), altitude is used directly to calculate both the throttle and the pitch angle (to change the altitude). This directly affects airspeed and altitude, and if properly tuned is quite effective. This is the appropriate PID diagram for a non-airspeed sensor setup:\n\n\n\n\nAltitude and Throttle Control PID Loop \u2013 No airspeed sensor\n\n\n\n\nAltitude and Throttle Control PID Loop \u2013 Airspeed sensor\n\n\nAltitude and Throttle Control \u2013 In The Code\n\n\nIn the PIC pilot software, altitude control is dependent on a PID loop. Currently, the integral term is implemented, but unused. On the other hand, the throttle control only uses the proportional term and the integral term. The derivative term is negligible. Currently, the integral term is unused (for SPIKE) and thus only the proportional term is used. The function responsible for the PID control of the altitude is:\n\n\nint controlSignalAltitude(int sp_Altitude,int gps_Altitude);\n\n\nThis function is responsible for the altitude control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of meters above the initial starting point.\n\n\nThe two parameters used to call the function are the setpoint (sp_Altitude) and the sensor output (gps_Altitude). These are then used to calculate the corresponding error.\n\n\nThe function responsible for the PID control of the throttle is:\n\n\nint controlSignalThrottle(int setpoint, int output);\n\n\nThis function is responsible for the throttle control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of percentage from no throttle (0%) to full throttle (100%).\n\n\nThe two parameters used to call the function are the setpoint and the sensor output. These are then used to calculate the corresponding error.\n\n\nTotal PID Control Overview\n\n\nThe total control diagram can be approximated with the flow chart below:\n\n\n\n\nTuning PID Loops\n\n\nAs explained above, PID loops keep unstable systems stable via input through (primarily) electronic means. In order to do so, one must analyze the transfer functions of the system and determine PID control gains, or more practically develop these gains from empirically testing the system.\n\n\nThe empirical method which WARG employs in the PID tuning is called the \nZieger-Nichols Method\n. This method involves a tuning procedure with the assistance of the following chart:\n\n\n\n\n\n\n\n\nControl Type\n\n\nKp\n\n\nKi\n\n\nKd\n\n\n\n\n\n\n\n\n\n\nP\n\n\n0.5Ku\n\n\n-\n\n\n-\n\n\n\n\n\n\nPI\n\n\n0.45Ku\n\n\n1.2Kp/Tu\n\n\n-\n\n\n\n\n\n\nPD\n\n\n0.8Ku\n\n\n-\n\n\nKpTu/8\n\n\n\n\n\n\nClassic PID\n\n\n0.6Ku\n\n\n2Kp/Tu\n\n\nKpTu/8\n\n\n\n\n\n\nPessen Integral Rule\n\n\n0.7Ku\n\n\n2.5Kp/Tu\n\n\n3KpTu/20\n\n\n\n\n\n\nSome Overshoot\n\n\n0.33Ku\n\n\n2Kp/Tu\n\n\nKpTu/3\n\n\n\n\n\n\nNo Overshoot\n\n\n0.2Ku\n\n\n2Kp/Tu\n\n\nKpTu/3\n\n\n\n\n\n\n\n\nAs a general rule, flying a vehicle requires minimal overshoot and maximum disturbance rejection. The \"Some Overshoot\" control type is unwanted in aerial applications.\n\n\nThe tuning procedure is as follows:\n\n\n\n\nBegin with roll. Increase the proportional gain until the plane oscillates with a constant period and amplitude.\n\n\nRetrieve the data, plot it in excel and determine the period of oscillation (Tu\u00ad). The proportional gain at which the vehicle began to oscillate is the Ultimate Gain (Ku). Use the above chart to determine the appropriate gain values.\n\n\nReset all the gains. Repeat steps 1 and 2 for pitch and yaw (if need be).\n\n\nRepeat steps 1 and 2, but with all the calculated gains running on the system. This step will fine tune all the values since pitch, roll, and yaw are interdependent. You will only need to repeat this step, whenever making changes to the PID setup or any crucial component on the system itself.", 
            "title": "PID Loops"
        }, 
        {
            "location": "/picpilot/pid-loops/#pid-loops", 
            "text": "PID Loops are vital to the functionality of the PICpilot Autopilot software. UAV systems (especially fixed-wing) are difficult to characterize through a mathematical model. Hence, a control algorithm, such as a PID loop, simplifies the process. It does so by making small changes to the system at regular intervals. The algorithm tracks changes in the past (short term and long term) and the present to be adaptive to future conditions. For instance, if a sudden disturbance is introduced into the system, differential control will compensate and attempt to stabilize the system.  The letters \"PID\" stand for:    Proportional Control \u2013 This stabilizes any instantaneous changes to the system    Integral Control \u2013 This stabilizes and reduces long-term error in the system    Derivative Control \u2013 This stabilizes abrupt changes (large derivative values).    PI systems are usually more common than PID systems. Nonetheless, a common PID system would look like this:   A common PID control loop  In a PID system, the input, r(t), is compared with the output, y(t), in the time domain. The subtraction between these two values yields the error, e(t). The error is then fed into the PID modules. Note each module contains a constant Kd, Kp, Ki. These are scaling factors. They determine the proportions in which each module adds together.  For the proportional module, the error is simply multiplied by a factor.  For the integral module, the error is integrated over time, before being multiplied by its corresponding factor.  For the derivative module, the error is differentiated at each time step, before being multiplied by its corresponding factor.  These three values are added together to determine u(t), which controls the system (plane, quadcopter, etc.). This can be expressed through the following code segment:  int controlSignal = (int)(HEADING_ROLL_SCALE_FACTOR * ((dValue * kd_gain[HEADING]) + (error * kp_gain[HEADING]) + (sum_gain[HEADING] * ki_gain[HEADING])));  Where  HEADING_ROLL_SCALE _FACTOR  is a dimensionless scale factor.  Where  dValue  is the derivative.  Where  sum_gain  is the integral summation over time.  Where  error  is the setpoint minus the output.  Where  kd_gain  is the derivative gain.  Where  kp_gain  is the proportional gain.  Where  ki_gain  is the integral gain.  Note that abrupt changes would affect the derivative term, gradual drift would affect the integral term, and anything in between would affect the proportional term.  The PID model used in the PICpilot is slightly different. Some modules are rearranged, and a hierarchy of PID loops is present.", 
            "title": "PID Loops"
        }, 
        {
            "location": "/picpilot/pid-loops/#rate-control", 
            "text": "Rate control is the basis of most aerial aircraft. The flaps on the wings of a plane control the rate at which it turns or rotates, but not the actual angle of the aircraft. For instance, if the flaps on a fixed wing aircraft were fully deflected, the aircraft would continuously spin out of control. It will not stop at a certain angle. In that sense, you control the  rate of angular rotation , also known as the derivative. Likewise, the sensors on the aircraft (gyroscopes), measure the rate of rotation (derivative). This provides an interesting PID system. This PID loop only contains the derivative term. Hence the name \"rate control\".  The rate control diagram looks like this:   Rate control PID loop  The equation that relates the input with the output is:  Control Signal = (dx \u2013 dy) * Kd  Control Signal = de * Kd", 
            "title": "Rate Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#rate-control-in-the-code", 
            "text": "Rate Control takes place at the end of the program execution cycle. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function that completes the calculation is called:  int controlSignal(float setpoint, float output, unsigned char type)  This function is responsible for the angular rates of the plane. It contains the differential equations that are part of the PID control system. It calculates the derivative term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg/s or rad/s). The units depend on the value of SERVO_SCALE_FACTOR which can be changed for various units. The original value was degrees per second.", 
            "title": "Rate Control - In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#angular-control", 
            "text": "Once the roll, pitch, and yaw of the aircraft are empirically controlled (using the rate control code), the roll, pitch, and yaw can then be controlled in terms of angles. In other words, this PI controller allows the aircraft to be commanded to maintain a certain angle in the air, such as a 30 degree bank angle. This allows the aircraft to be controlled by the autopilot to turn, as well as alter its altitude.  An Inertial Measurement Unit (IMU) provides the sensory information required to control the plane in this manner. The IMU usually uses a Kalman filter and state estimation (using integration) to determine the position of the unit.  The resulting angular control PI loop incorporates the rate control loop from the section above. The angular control diagram looks like this:   Angular Control PID Loop  The equations that relate r(t) and dx(t) are:  dx(t) = (r \u2013 y) * Kp + Ki * integral(r-y,dt)  dx(t) = e * Kp + Ki * integral(e,dt)", 
            "title": "Angular Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#angular-control-in-the-code", 
            "text": "Angular control code takes place right before the rate control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:  int controlSignalAngles(float setpoint, float output, unsigned char type, float SERVO_SCALE_FACTOR_ANGLES)  This function is responsible for the orientation of the plane. It contains the equations that model a PID control system. It calculates the proportional and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg or rad), where the units depend on the value of SERVO_SCALE_FACTOR_ANGLES which can be changed for various units.", 
            "title": "Angular Control \u2013 In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#heading-control", 
            "text": "Once rudimentary control of the aircraft is attained using the angular control loop and the rate control loop, the position of the aircraft can be controlled. As a result, the next control loop controls the heading of the aircraft. For instance, the plane can be directed at a 30 degree magnetic heading, and it will maintain that heading for as long as is required.  The measurements come from an external GPS sensor. The sensor measurements can also come from other sources, but they need to be in units of degrees. Currently, the calculations are done in degrees.  This control system uses the commonly recognized PID loop structure:   Heading Control PID Loop  The equations that relate r(t) and h(t) are:  r(t) = Kd * d(h \u2013 \u03b8)/dt + (h \u2013 \u03b8) * Kp + Ki * integral(h \u2013 \u03b8,dt)  r(t) = Kd * de/dt + e * Kp + Ki * integral(e,dt)", 
            "title": "Heading Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#heading-control-in-the-code", 
            "text": "Heading control code takes place right before the angular control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:  int controlSignalHeading(int setpoint, int output)  This function is responsible for steering the plane in the correct direction. It contains the equations that model a PID control system. It calculates the derivative, proportional, and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (currently in degrees).  This function completes a comparison between the setpoint and the output, and then decides if it should turn left or right. When the setpoint and the output are subtracted, the resulting error is set to be between -180 and +180, where -180 degrees indicates the requirement to bank left and +180 degrees indicates the requirement to bank right.  The remainder of the PID control is the same. An integrator, derivative, and proportional term is present.", 
            "title": "Heading Control \u2013 In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#altitude-and-throttle-control", 
            "text": "Altitude and Throttle control are two separate control loops. However, they are highly dependent on one another. For instance, if the throttle is increased, the plane has a natural tendency to gain altitude. Likewise, if the throttle is decreased, the plane has a natural tendency to lose altitude. Likewise, the opposite is true; if the plane gains or losses altitude, the airspeed of the aircraft changes.  Both altitude and throttle control is established by the use of PID loops. Currently, altitude uses the  proportional  and _derivative _terms, whereas, throttle uses only the _proportional _term. You can determine this by looking at the gain settings for each PID loop (if the gain is zero, the respective PID term is unused).  Generally, the throttle control should be regulated using an airspeed sensor, in order to keep the airspeed constant. However, in cases where there is no airspeed sensor (such as in SPIKE), altitude is used directly to calculate both the throttle and the pitch angle (to change the altitude). This directly affects airspeed and altitude, and if properly tuned is quite effective. This is the appropriate PID diagram for a non-airspeed sensor setup:   Altitude and Throttle Control PID Loop \u2013 No airspeed sensor   Altitude and Throttle Control PID Loop \u2013 Airspeed sensor", 
            "title": "Altitude and Throttle Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#altitude-and-throttle-control-in-the-code", 
            "text": "In the PIC pilot software, altitude control is dependent on a PID loop. Currently, the integral term is implemented, but unused. On the other hand, the throttle control only uses the proportional term and the integral term. The derivative term is negligible. Currently, the integral term is unused (for SPIKE) and thus only the proportional term is used. The function responsible for the PID control of the altitude is:  int controlSignalAltitude(int sp_Altitude,int gps_Altitude);  This function is responsible for the altitude control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of meters above the initial starting point.  The two parameters used to call the function are the setpoint (sp_Altitude) and the sensor output (gps_Altitude). These are then used to calculate the corresponding error.  The function responsible for the PID control of the throttle is:  int controlSignalThrottle(int setpoint, int output);  This function is responsible for the throttle control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of percentage from no throttle (0%) to full throttle (100%).  The two parameters used to call the function are the setpoint and the sensor output. These are then used to calculate the corresponding error.", 
            "title": "Altitude and Throttle Control \u2013 In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#total-pid-control-overview", 
            "text": "The total control diagram can be approximated with the flow chart below:", 
            "title": "Total PID Control Overview"
        }, 
        {
            "location": "/picpilot/pid-loops/#tuning-pid-loops", 
            "text": "As explained above, PID loops keep unstable systems stable via input through (primarily) electronic means. In order to do so, one must analyze the transfer functions of the system and determine PID control gains, or more practically develop these gains from empirically testing the system.  The empirical method which WARG employs in the PID tuning is called the  Zieger-Nichols Method . This method involves a tuning procedure with the assistance of the following chart:     Control Type  Kp  Ki  Kd      P  0.5Ku  -  -    PI  0.45Ku  1.2Kp/Tu  -    PD  0.8Ku  -  KpTu/8    Classic PID  0.6Ku  2Kp/Tu  KpTu/8    Pessen Integral Rule  0.7Ku  2.5Kp/Tu  3KpTu/20    Some Overshoot  0.33Ku  2Kp/Tu  KpTu/3    No Overshoot  0.2Ku  2Kp/Tu  KpTu/3     As a general rule, flying a vehicle requires minimal overshoot and maximum disturbance rejection. The \"Some Overshoot\" control type is unwanted in aerial applications.  The tuning procedure is as follows:   Begin with roll. Increase the proportional gain until the plane oscillates with a constant period and amplitude.  Retrieve the data, plot it in excel and determine the period of oscillation (Tu\u00ad). The proportional gain at which the vehicle began to oscillate is the Ultimate Gain (Ku). Use the above chart to determine the appropriate gain values.  Reset all the gains. Repeat steps 1 and 2 for pitch and yaw (if need be).  Repeat steps 1 and 2, but with all the calculated gains running on the system. This step will fine tune all the values since pitch, roll, and yaw are interdependent. You will only need to repeat this step, whenever making changes to the PID setup or any crucial component on the system itself.", 
            "title": "Tuning PID Loops"
        }, 
        {
            "location": "/picpilot/pwm-io/", 
            "text": "PWM and IO\n\n\nPWM stands for Pulse Width Modulation. This means that digital or analog data is encoded through the use of square wave electrical signals, where the width of the square wave determines the value of the data. For instance, in UAVs, a larger square wave will add more throttle, whereas a smaller square wave will add less throttle. The same concepts apply to the ailerons, flaps, rudder, and elevators. A PWM signal can be plotted on a voltage - time plot to attain the following graph:\n\n\n\n\nFor this application, the most common pulse width for a square wave is 1.5 milliseconds. This value represents the zero position for all control surfaces. The maximum value for the square wave is 2 milliseconds. The minimum value is 1 millisecond. Likewise, when using throttle, a 1 millisecond square wave is 0% throttle, and a 2 millisecond square wave is 100% throttle. For instance, here is a diagram of 3 consecutive pulses, which command the plane to throttle to 100%, followed by 50%, followed by 0%:\n\n\n\n\nThe duty cycle or period specifies the frequency of the pulses. For servo motors, the period is 22.5 milliseconds. This means that one square wave should be detected every 22.5 milliseconds. If the period is unreasonably short, or unreasonably long, the servo motor may seize, until the data is corrected. The allowable error range varies between speed controllers, but it is generally very forgiving (from experience). In general, make sure the period is more than 12 milliseconds and less than 25 milliseconds.\n\n\nThese PWM signals can be used to convey information as input and output to a digital signal controller (DSC). The input is often referred to as \"Input Capture\". The output is often referred to as \"Output Capture\". Each wire connection can handle one channel. The current implementation of the PICpilot supports 8 input channels and 8 output channels. Out of the 8 input channels, 6 are currently used. Out of the 8 output channels, 6 are currently used. The roll, pitch, throttle, yaw and the autopilot on/off channels are the most critical in order for the UAV to work. This encompasses 9 channels in total (5 inputs, 4 outputs).\n\n\nHardware\n\n\nThe dspic33fj256gp710a chip supports 16 channels (8 inputs and 8 outputs):\n\n\n\n\n\n\n\n\nChannel\n\n\nFunction\n\n\nPin/Port\n\n\nInput/Output\n\n\n\n\n\n\n\n\n\n\n1\n\n\nRoll\n\n\n68/RD8\n\n\nInput\n\n\n\n\n\n\n2\n\n\nPitch\n\n\n69/RD9\n\n\nInput\n\n\n\n\n\n\n3\n\n\nThrottle\n\n\n70/RD10\n\n\nInput\n\n\n\n\n\n\n4\n\n\nYaw\n\n\n71/RD11\n\n\nInput\n\n\n\n\n\n\n5\n\n\nUHF Switch\n\n\n79/RD12\n\n\nInput\n\n\n\n\n\n\n6\n\n\nN/A\n\n\n80/RD13\n\n\nInput\n\n\n\n\n\n\n7\n\n\nN/A\n\n\n47/RD14\n\n\nInput\n\n\n\n\n\n\n8\n\n\nAutopilot On/Off\n\n\n48/RD15\n\n\nInput\n\n\n\n\n\n\n1\n\n\nRoll\n\n\n72/RD0\n\n\nOutput\n\n\n\n\n\n\n2\n\n\nPitch\n\n\n76/RD1\n\n\nOutput\n\n\n\n\n\n\n3\n\n\nThrottle\n\n\n77/RD2\n\n\nOutput\n\n\n\n\n\n\n4\n\n\nYaw\n\n\n78/RD3\n\n\nOutput\n\n\n\n\n\n\n5\n\n\nCamera Shutter\n\n\n81/RD4\n\n\nOutput\n\n\n\n\n\n\n6\n\n\nCamera Gimbal\n\n\n82/RD5\n\n\nOutput\n\n\n\n\n\n\n7\n\n\nN/A\n\n\n83/RD6\n\n\nOutput\n\n\n\n\n\n\n8\n\n\nN/A\n\n\n84/RD7\n\n\nOutput\n\n\n\n\n\n\n\n\nEach pin has corresponding registers to determine the configuration for each pin. The input capture settings that can be configured include the clock source (for timing and comparison), edge detection (trigger on rising, falling or both), and interrupts (every event, or every 2, 3, or 4). For output compare, the settings that can be configured include the clock source, pulse type (single, continuous, high/low initialization).\n\n\nFor detailed hardware specifications see the Microchip website: \ndspic33fj256gp710A\n\n\nIn the Code\n\n\nThree files are in charge of controlling all the PWM signals. InputCapture.c, which contains all the functions used to manage input capture, OutputCompare.C, which contains all the functions used to manage output compare. Finally, PWM.c links these files together.\n\n\nPWM.c combines both input capture and output compare into a simple interface that is easy to manage and consistent to use. It then applies scaling factors to the arbitrary timer units, which map the Input Capture and Output Capture values to variables that range between -100 and 100.\n\n\nPWM.c contains 7 functions:\n\n\n\n\n\n\n\n\nFunction Name\n\n\nInput Variables\n\n\nOutput\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\ninitPWM\n\n\ninputChannels, outputChannels\n\n\nNone.\n\n\nThis function MUST be called before any other functions used below.The variables must be in binary representation. For example, channel 1, 2, and 5 enabled is: 0b00010011\n\n\n\n\n\n\nPWMInputCalibration\n\n\nchannel, signalScaleFactor, signalOffset\n\n\nNone.\n\n\nCalibrates the input from the controller so that the range outputs from -100 to 100.\n\n\n\n\n\n\nPWMOutputCalibration\n\n\nchannel, signalScaleFactor, signalOffset\n\n\nNone.\n\n\nCalibrates the output from the controller so that the range outputs from -100 to 100.\n\n\n\n\n\n\ngetPWM\n\n\nchannel\n\n\nInteger\n\n\nReturns the value (scaled) from the input of a certain channel.\n\n\n\n\n\n\ngetPWMArray\n\n\nNone.\n\n\nNone.\n\n\nReturns the value (scaled) from the input of all channels.\n\n\n\n\n\n\nsetPWM\n\n\nchannel, pwm\n\n\nNone.\n\n\nSets a certain output compare channel to a certain value according to the pwm range between -100 and 100.\n\n\n\n\n\n\nsetPWMArray\n\n\nocArray\n\n\nNone.\n\n\nSets all output compare channels to values stored in an array. These should be between -100 and 100.\n\n\n\n\n\n\n\n\nFor future use, the calibration functions should be coordinated with the ground station, in order to be able to calibrate the controller/plane sensitivities and limits \"on the go\".\n\n\nIt should be noted that the initialization procedure is necessary for the PWM IO functions to work.\n\n\nFor input capture, the settings that are initialized include (for channel 1):\n\n\n   IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module\n\n   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base\n\n   IC1CONbits.ICI = 0b11; // Interrupt on every capture event\n\n   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising and Falling edge\n\n   // Enable Capture Interrupt And Timer2\n\n   IPC0bits.IC1IP = 7; // Setup IC1 interrupt priority level - Highest\n\n   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag\n\n   IEC0bits.IC1IE = 1; // Enable IC1 interrupt\n\n\n\nThe initialization procedure selects a timer, setting for frequency of capture events, interrupt frequency, as well as other interrupt settings.\n\n\nFor output capture, the settings that are initialized include (for channel 1):\n\n\n// Initialize Output Compare Module\n\nOC1CONbits.OCM = 0b000; // Disable Output Compare Module\n\nOC1R = MIDDLE\\_PWM; // Write the duty cycle for the first PWM pulse = 1.5ms/4688\n\nOC1RS = MIDDLE\\_PWM; // Write the duty cycle for the second PWM pulse] = 1.5ms/4688\n\nOC1CONbits.OCTSEL = 0; // Select Timer 2 as output compare time base\n\nOC1CONbits.OCM = 0b110; // Select the Output Compare mode (without fault protection)\n\n\n\nThe initialization procedure selects a timer, initial duty cycle (this changes after the first program cycle), and output compare mode.\n\n\nLikewise, since both IC and OC use \ntimer2\n. An initialization of this component is also required:\n\n\nT2CONbits.TON = 0; // Disable Timer\n\nT2CONbits.TCS = 0; // Select internal instruction cycle clock\n\nT2CONbits.TGATE = 0; // Disable Gated Timer mode\n\nT2CONbits.TCKPS = 0b01; // Select 1:8 Prescaler\n\nTMR2 = 0x00; // Clear timer register\n\nsetPeriod(20);\n\nIPC1bits.T2IP = 0x01; // Set Timer 2 Interrupt Priority Level - Lowest\n\nIFS0bits.T2IF = 0; // Clear Timer 2 Interrupt Flag\n\nIEC0bits.T2IE = 1; // Enable Timer 2 interrupt\n\nT2CONbits.TON = 1; // Start Timer\n\n\n\nThe initialization procedure selects the clock source (internal instruction clock), selects a scaling amount (determined via oscilloscope measurements), sets the period of the pulse cycle (20ms), and enables the Timer2  interrupt (this is not used for PWM signals, it is used to keep track of the runtime of the chip).", 
            "title": "PWM and IO"
        }, 
        {
            "location": "/picpilot/pwm-io/#pwm-and-io", 
            "text": "PWM stands for Pulse Width Modulation. This means that digital or analog data is encoded through the use of square wave electrical signals, where the width of the square wave determines the value of the data. For instance, in UAVs, a larger square wave will add more throttle, whereas a smaller square wave will add less throttle. The same concepts apply to the ailerons, flaps, rudder, and elevators. A PWM signal can be plotted on a voltage - time plot to attain the following graph:   For this application, the most common pulse width for a square wave is 1.5 milliseconds. This value represents the zero position for all control surfaces. The maximum value for the square wave is 2 milliseconds. The minimum value is 1 millisecond. Likewise, when using throttle, a 1 millisecond square wave is 0% throttle, and a 2 millisecond square wave is 100% throttle. For instance, here is a diagram of 3 consecutive pulses, which command the plane to throttle to 100%, followed by 50%, followed by 0%:   The duty cycle or period specifies the frequency of the pulses. For servo motors, the period is 22.5 milliseconds. This means that one square wave should be detected every 22.5 milliseconds. If the period is unreasonably short, or unreasonably long, the servo motor may seize, until the data is corrected. The allowable error range varies between speed controllers, but it is generally very forgiving (from experience). In general, make sure the period is more than 12 milliseconds and less than 25 milliseconds.  These PWM signals can be used to convey information as input and output to a digital signal controller (DSC). The input is often referred to as \"Input Capture\". The output is often referred to as \"Output Capture\". Each wire connection can handle one channel. The current implementation of the PICpilot supports 8 input channels and 8 output channels. Out of the 8 input channels, 6 are currently used. Out of the 8 output channels, 6 are currently used. The roll, pitch, throttle, yaw and the autopilot on/off channels are the most critical in order for the UAV to work. This encompasses 9 channels in total (5 inputs, 4 outputs).", 
            "title": "PWM and IO"
        }, 
        {
            "location": "/picpilot/pwm-io/#hardware", 
            "text": "The dspic33fj256gp710a chip supports 16 channels (8 inputs and 8 outputs):     Channel  Function  Pin/Port  Input/Output      1  Roll  68/RD8  Input    2  Pitch  69/RD9  Input    3  Throttle  70/RD10  Input    4  Yaw  71/RD11  Input    5  UHF Switch  79/RD12  Input    6  N/A  80/RD13  Input    7  N/A  47/RD14  Input    8  Autopilot On/Off  48/RD15  Input    1  Roll  72/RD0  Output    2  Pitch  76/RD1  Output    3  Throttle  77/RD2  Output    4  Yaw  78/RD3  Output    5  Camera Shutter  81/RD4  Output    6  Camera Gimbal  82/RD5  Output    7  N/A  83/RD6  Output    8  N/A  84/RD7  Output     Each pin has corresponding registers to determine the configuration for each pin. The input capture settings that can be configured include the clock source (for timing and comparison), edge detection (trigger on rising, falling or both), and interrupts (every event, or every 2, 3, or 4). For output compare, the settings that can be configured include the clock source, pulse type (single, continuous, high/low initialization).  For detailed hardware specifications see the Microchip website:  dspic33fj256gp710A  In the Code  Three files are in charge of controlling all the PWM signals. InputCapture.c, which contains all the functions used to manage input capture, OutputCompare.C, which contains all the functions used to manage output compare. Finally, PWM.c links these files together.  PWM.c combines both input capture and output compare into a simple interface that is easy to manage and consistent to use. It then applies scaling factors to the arbitrary timer units, which map the Input Capture and Output Capture values to variables that range between -100 and 100.  PWM.c contains 7 functions:     Function Name  Input Variables  Output  Notes      initPWM  inputChannels, outputChannels  None.  This function MUST be called before any other functions used below.The variables must be in binary representation. For example, channel 1, 2, and 5 enabled is: 0b00010011    PWMInputCalibration  channel, signalScaleFactor, signalOffset  None.  Calibrates the input from the controller so that the range outputs from -100 to 100.    PWMOutputCalibration  channel, signalScaleFactor, signalOffset  None.  Calibrates the output from the controller so that the range outputs from -100 to 100.    getPWM  channel  Integer  Returns the value (scaled) from the input of a certain channel.    getPWMArray  None.  None.  Returns the value (scaled) from the input of all channels.    setPWM  channel, pwm  None.  Sets a certain output compare channel to a certain value according to the pwm range between -100 and 100.    setPWMArray  ocArray  None.  Sets all output compare channels to values stored in an array. These should be between -100 and 100.     For future use, the calibration functions should be coordinated with the ground station, in order to be able to calibrate the controller/plane sensitivities and limits \"on the go\".  It should be noted that the initialization procedure is necessary for the PWM IO functions to work.  For input capture, the settings that are initialized include (for channel 1):     IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module\n\n   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base\n\n   IC1CONbits.ICI = 0b11; // Interrupt on every capture event\n\n   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising and Falling edge\n\n   // Enable Capture Interrupt And Timer2\n\n   IPC0bits.IC1IP = 7; // Setup IC1 interrupt priority level - Highest\n\n   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag\n\n   IEC0bits.IC1IE = 1; // Enable IC1 interrupt  The initialization procedure selects a timer, setting for frequency of capture events, interrupt frequency, as well as other interrupt settings.  For output capture, the settings that are initialized include (for channel 1):  // Initialize Output Compare Module\n\nOC1CONbits.OCM = 0b000; // Disable Output Compare Module\n\nOC1R = MIDDLE\\_PWM; // Write the duty cycle for the first PWM pulse = 1.5ms/4688\n\nOC1RS = MIDDLE\\_PWM; // Write the duty cycle for the second PWM pulse] = 1.5ms/4688\n\nOC1CONbits.OCTSEL = 0; // Select Timer 2 as output compare time base\n\nOC1CONbits.OCM = 0b110; // Select the Output Compare mode (without fault protection)  The initialization procedure selects a timer, initial duty cycle (this changes after the first program cycle), and output compare mode.  Likewise, since both IC and OC use  timer2 . An initialization of this component is also required:  T2CONbits.TON = 0; // Disable Timer\n\nT2CONbits.TCS = 0; // Select internal instruction cycle clock\n\nT2CONbits.TGATE = 0; // Disable Gated Timer mode\n\nT2CONbits.TCKPS = 0b01; // Select 1:8 Prescaler\n\nTMR2 = 0x00; // Clear timer register\n\nsetPeriod(20);\n\nIPC1bits.T2IP = 0x01; // Set Timer 2 Interrupt Priority Level - Lowest\n\nIFS0bits.T2IF = 0; // Clear Timer 2 Interrupt Flag\n\nIEC0bits.T2IE = 1; // Enable Timer 2 interrupt\n\nT2CONbits.TON = 1; // Start Timer  The initialization procedure selects the clock source (internal instruction clock), selects a scaling amount (determined via oscilloscope measurements), sets the period of the pulse cycle (20ms), and enables the Timer2  interrupt (this is not used for PWM signals, it is used to keep track of the runtime of the chip).", 
            "title": "Hardware"
        }, 
        {
            "location": "/picpilot/uart/", 
            "text": "UART\n\n\nUART stands for Universal Asynchronous Receive Transmit. It is a protocol for chips to be able to communicate between on another. It is a serial form of communication, where each bit of data is transmitted along the same connection. The minimum hardware requirements look like this:\n\n\n\n\nNote that Tx represents the transmit port, Rx represents the receive port, and the GND represents the required ground connection.\n\n\nUART is convenient due to its simplicity. Note that the interface does not have a clock line or any special signalling channels. Most other methods of communication require a pulsing clock to determine the rate at which data is transferred from one component to another. UART is \"asynchronous\" and therefore the bits on the transfer line and the receive line do not need to be transmitted at the same instance in time. Instead, both chips have a predefined rate at which they transfer binary information to one another. This predefined rate is often determined by the user, or sometimes (very rarely) restricted by the manufacturer. This rate is referred to as the \nbaud rate\n. It is very similar to a bit rate.\n\n\nAs a side note (don't worry if you are confused), Bit rate is the number of \nbits_transferred per second. Baud rate is the number of _symbols\n transferred per second. A bit can be 0 or 1. A symbol carries different amounts of information in different technologies. For instance, in certain communication protocols, there can be 64 possible values for a single symbol. 64 values required 6 bits to be represented. Therefore, the baud rate is 6 times less than the bit rate.\n\n\nFor the UART communication protocol, the baud rate is equivalent to the bit rate, although \"baud\" is the correct terminology.\n\n\nAlthough UART can be used in both 8 bit mode and 16 bit mode, the PICpilot uses the 8 bit mode of communication as displayed below.\n\n\n\n\nFirst a start bit is sent\n\n\nThe message is then relayed in series\n\n\nThe stop bit(s) are then sent. (There can be 1 or 2 stop bits)\n\n\n\n\nThe stop and end bits indicate the beginning and the end of communication.\n\n\n\n\n\n\n\n\nBit number\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n\n\n\n\n\n\n\n\n\n\nStart bit\n\n\n5\u20138 data bits\n\n\nStop bit(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStart\n\n\nData 0\n\n\nData 1\n\n\nData 2\n\n\nData 3\n\n\nData 4\n\n\nData 5\n\n\nData 6\n\n\nData 7\n\n\nStop\n\n\n\n\n\n\n\n\n\n\n\n\nThe most common settings for the UART protocol include 8 data bits, no parity, 1 stop bit, and no flow control. Remember to make sure that the baud rate matches up, and NEVER connect Tx to Tx or Rx to Rx.\n\n\nIn case you do not know, parity is a special bit used to check the integrity of the data sent. It indicates whether or not the sum of the 8 bits must be odd or even. If this result does not match the parity bit, the microcontroller would know that the information is garbled.\n\n\nSecondly, flow control requires additional pins, where each peripheral signals the other one before it transmits and receives. This ensures that both chips are ready to communicate.\n\n\nThirdly, the terms full duplex and half duplex refer to a chip being able to multitask. Full duplex indicates that both chips send and receive at the same time. Half duplex indicates that only one chip sends and receives at a time. Usually, some type of flow control is required for half duplex systems.\n\n\nThis form of communication is used for two purposes on the PICpilot. It is used for the data link, as well as the debugging interface. The settings are listed below.\n\n\nIn the code\n\n\nEach dspic33fj256gp710a has two UART interfaces. They are labeled UART1 and UART2. In the code, two corresponding files are present: UART1.c and UART2.c (as well as their header files). UART1 and UART2 have nearly the same configuration settings, but with slight discrepancies. UART1 is used for debugging purposes. UART2 is used for the wireless transmitter (datalink).\n\n\nFor detailed register maps and specifications of the UART interface, see the \ndspic33fj256gp710A\n datasheet.\n\n\nThe most important settings are listed below.\n\n\nUART1\n\n\nU1MODEbits.UEN = 0;\n\nU1MODEbits.PDSEL = 0b00;\n\nU1MODEbits.STSEL = 0;\n\nU1BRG = 1;\n\nIPC7 = 0x4400;\n\nIFS0bits.U1TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC0bits.U1TXIE = 0;        // Enable Transmit Interrupts\n\nIFS0bits.U1RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC0bits.U1RXIE = 0;        // Enable Recieve Interrupts\n\nU1MODEbits.UARTEN = 1;        //Enable UART\n\nU1STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nU1MODEbits.UEN\n\n\n0\n\n\nEnables the Rx and Tx pins and disables the CTS and RTS pins.\n\n\n\n\n\n\nU1MODEbits.PDSEL\n\n\n0\n\n\nConfigures 8 bit messages with no parity bits.\n\n\n\n\n\n\nU1MODEbits.STSEL\n\n\n0\n\n\nConfigures 1 stop bit.\n\n\n\n\n\n\nU1BRG\n\n\n1\n\n\nSets the Baud Rate to 115200 Baud.\n\n\n\n\n\n\nIPC7\n\n\n17408\n\n\nSets the priority level for UART interrupts.\n\n\n\n\n\n\nIFS0bits.U1TXIF\n\n\n0\n\n\nClears the transmit interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the transmit interrupt event.\n\n\n\n\n\n\nIFS0bits.U1RXIF\n\n\n0\n\n\nClears the receive interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the receive interrupt event.\n\n\n\n\n\n\nU1MODEbits.UARTEN\n\n\n1\n\n\nTurns UART on.\n\n\n\n\n\n\nU1STAbits.UTXEN\n\n\n1\n\n\nAllows transmission (Tx) to take place.\n\n\n\n\n\n\n\n\nUART2\n\n\nU2MODEbits.UEN = 0;\n\nU2MODEbits.PDSEL = 0b00;\n\nU2MODEbits.STSEL = 0;\n\nU2BRG = 5;\n\nIPC7 = 0x4400;\n\nIFS1bits.U2TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC1bits.U2TXIE = 0;        // Enable Transmit Interrupts\n\nIFS1bits.U2RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC1bits.U2RXIE = 0;        // Enable Recieve Interrupts\n\nU2MODEbits.UARTEN = 1;        //Enable UART\n\nU2STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nU1MODEbits.UEN\n\n\n0\n\n\nEnables the Rx and Tx pins and disables the CTS and RTS pins.\n\n\n\n\n\n\nU1MODEbits.PDSEL\n\n\n0\n\n\nConfigures 8 bit messages with no parity bits.\n\n\n\n\n\n\nU1MODEbits.STSEL\n\n\n0\n\n\nConfigures 1 stop bit.\n\n\n\n\n\n\nU1BRG\n\n\n5\n\n\nSets the Baud Rate to 38400 Baud.\n\n\n\n\n\n\nIPC7\n\n\n17408\n\n\nSets the priority level for UART interrupts.\n\n\n\n\n\n\nIFS0bits.U1TXIF\n\n\n0\n\n\nClears the transmit interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the transmit interrupt event.\n\n\n\n\n\n\nIFS0bits.U1RXIF\n\n\n0\n\n\nClears the receive interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the receive interrupt event.\n\n\n\n\n\n\nU1MODEbits.UARTEN\n\n\n1\n\n\nTurns UART on.\n\n\n\n\n\n\nU1STAbits.UTXEN\n\n\n1\n\n\nAllows transmission (Tx) to take place.\n\n\n\n\n\n\n\n\nNote that the only difference between the data link (UART2) and the debugging interface (UART1), is the rate at which information is sent (baud rate).", 
            "title": "UART"
        }, 
        {
            "location": "/picpilot/uart/#uart", 
            "text": "UART stands for Universal Asynchronous Receive Transmit. It is a protocol for chips to be able to communicate between on another. It is a serial form of communication, where each bit of data is transmitted along the same connection. The minimum hardware requirements look like this:   Note that Tx represents the transmit port, Rx represents the receive port, and the GND represents the required ground connection.  UART is convenient due to its simplicity. Note that the interface does not have a clock line or any special signalling channels. Most other methods of communication require a pulsing clock to determine the rate at which data is transferred from one component to another. UART is \"asynchronous\" and therefore the bits on the transfer line and the receive line do not need to be transmitted at the same instance in time. Instead, both chips have a predefined rate at which they transfer binary information to one another. This predefined rate is often determined by the user, or sometimes (very rarely) restricted by the manufacturer. This rate is referred to as the  baud rate . It is very similar to a bit rate.  As a side note (don't worry if you are confused), Bit rate is the number of  bits_transferred per second. Baud rate is the number of _symbols  transferred per second. A bit can be 0 or 1. A symbol carries different amounts of information in different technologies. For instance, in certain communication protocols, there can be 64 possible values for a single symbol. 64 values required 6 bits to be represented. Therefore, the baud rate is 6 times less than the bit rate.  For the UART communication protocol, the baud rate is equivalent to the bit rate, although \"baud\" is the correct terminology.  Although UART can be used in both 8 bit mode and 16 bit mode, the PICpilot uses the 8 bit mode of communication as displayed below.   First a start bit is sent  The message is then relayed in series  The stop bit(s) are then sent. (There can be 1 or 2 stop bits)   The stop and end bits indicate the beginning and the end of communication.     Bit number  1  2  3  4  5  6  7  8  9  10  11       Start bit  5\u20138 data bits  Stop bit(s)             Start  Data 0  Data 1  Data 2  Data 3  Data 4  Data 5  Data 6  Data 7  Stop       The most common settings for the UART protocol include 8 data bits, no parity, 1 stop bit, and no flow control. Remember to make sure that the baud rate matches up, and NEVER connect Tx to Tx or Rx to Rx.  In case you do not know, parity is a special bit used to check the integrity of the data sent. It indicates whether or not the sum of the 8 bits must be odd or even. If this result does not match the parity bit, the microcontroller would know that the information is garbled.  Secondly, flow control requires additional pins, where each peripheral signals the other one before it transmits and receives. This ensures that both chips are ready to communicate.  Thirdly, the terms full duplex and half duplex refer to a chip being able to multitask. Full duplex indicates that both chips send and receive at the same time. Half duplex indicates that only one chip sends and receives at a time. Usually, some type of flow control is required for half duplex systems.  This form of communication is used for two purposes on the PICpilot. It is used for the data link, as well as the debugging interface. The settings are listed below.", 
            "title": "UART"
        }, 
        {
            "location": "/picpilot/uart/#in-the-code", 
            "text": "Each dspic33fj256gp710a has two UART interfaces. They are labeled UART1 and UART2. In the code, two corresponding files are present: UART1.c and UART2.c (as well as their header files). UART1 and UART2 have nearly the same configuration settings, but with slight discrepancies. UART1 is used for debugging purposes. UART2 is used for the wireless transmitter (datalink).  For detailed register maps and specifications of the UART interface, see the  dspic33fj256gp710A  datasheet.  The most important settings are listed below.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/uart/#uart1", 
            "text": "U1MODEbits.UEN = 0;\n\nU1MODEbits.PDSEL = 0b00;\n\nU1MODEbits.STSEL = 0;\n\nU1BRG = 1;\n\nIPC7 = 0x4400;\n\nIFS0bits.U1TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC0bits.U1TXIE = 0;        // Enable Transmit Interrupts\n\nIFS0bits.U1RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC0bits.U1RXIE = 0;        // Enable Recieve Interrupts\n\nU1MODEbits.UARTEN = 1;        //Enable UART\n\nU1STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.     Register  Value  Function      U1MODEbits.UEN  0  Enables the Rx and Tx pins and disables the CTS and RTS pins.    U1MODEbits.PDSEL  0  Configures 8 bit messages with no parity bits.    U1MODEbits.STSEL  0  Configures 1 stop bit.    U1BRG  1  Sets the Baud Rate to 115200 Baud.    IPC7  17408  Sets the priority level for UART interrupts.    IFS0bits.U1TXIF  0  Clears the transmit interrupt flag.    IEC0bits.U1TXIE  0  Enables the transmit interrupt event.    IFS0bits.U1RXIF  0  Clears the receive interrupt flag.    IEC0bits.U1TXIE  0  Enables the receive interrupt event.    U1MODEbits.UARTEN  1  Turns UART on.    U1STAbits.UTXEN  1  Allows transmission (Tx) to take place.", 
            "title": "UART1"
        }, 
        {
            "location": "/picpilot/uart/#uart2", 
            "text": "U2MODEbits.UEN = 0;\n\nU2MODEbits.PDSEL = 0b00;\n\nU2MODEbits.STSEL = 0;\n\nU2BRG = 5;\n\nIPC7 = 0x4400;\n\nIFS1bits.U2TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC1bits.U2TXIE = 0;        // Enable Transmit Interrupts\n\nIFS1bits.U2RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC1bits.U2RXIE = 0;        // Enable Recieve Interrupts\n\nU2MODEbits.UARTEN = 1;        //Enable UART\n\nU2STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.     Register  Value  Function      U1MODEbits.UEN  0  Enables the Rx and Tx pins and disables the CTS and RTS pins.    U1MODEbits.PDSEL  0  Configures 8 bit messages with no parity bits.    U1MODEbits.STSEL  0  Configures 1 stop bit.    U1BRG  5  Sets the Baud Rate to 38400 Baud.    IPC7  17408  Sets the priority level for UART interrupts.    IFS0bits.U1TXIF  0  Clears the transmit interrupt flag.    IEC0bits.U1TXIE  0  Enables the transmit interrupt event.    IFS0bits.U1RXIF  0  Clears the receive interrupt flag.    IEC0bits.U1TXIE  0  Enables the receive interrupt event.    U1MODEbits.UARTEN  1  Turns UART on.    U1STAbits.UTXEN  1  Allows transmission (Tx) to take place.     Note that the only difference between the data link (UART2) and the debugging interface (UART1), is the rate at which information is sent (baud rate).", 
            "title": "UART2"
        }, 
        {
            "location": "/picpilot/spi/", 
            "text": "SPI\n\n\nSPI stands for Serial Peripheral Interface. It is similar to UART, with the exception that it is a \nsynchronous\n method of communication. Once again, SPI is a protocol for chips to be able to communicate between on another through serial connections (data on a single wire). It always operates in full duplex mode. This means that both chips \nalways\n transmit and receive at the same time. The minimum hardware requirements include a clock line (SCLK), a Master Out/Slave In (MOSI), a Master In/Slave Out (MISO), and a Slave Select (SS). The Master Out/In and Slave In/Out refer to the transmit and receive pins on both chips. The connections should looks like this:\n\n\n\n\nNote that there is a \"Master\" and a \"Slave\". The master always initiates communication. The slave always responds first. The SCLK (clock) line counts pulses, which are synchronized to the data bits on the MOSI and MISO lines. The SS (Slave Select) line is used to notify an external chip that communication is taking place. This enables multiple chips to be connected on the same data and clock lines. This is depicted here:\n\n\n\n\nIn the PICpilot, there is never more than one slave per data port. In other words, one does not have to worry about scenarios (multiple slaves) such as the one depicted above.\n\n\nThe SPI interface transfers 8 bits per packet. The protocol is straight forward:\n\n\n\n\nThe start condition is initiated. The clock starts and the (selected) slave prepares to read and the master prepares to write.\n\n\nOn the next 8 clock pulses, the slave and master both exchange data (read and write)\n\n\nAfter transmission, the stop condition is set. This occurs when the clock stops (high or low depending on the settings).\n\n\n\n\nThe PIC microcontroller specifications depict the SPI interface as follows:\n\n\n\n\nUnlike UART, there is no parity bits, start bits, or stop bits. The beginning and the end of the message are commonly referred to as the \nStart Condition\n and the \nStop Condition\n, because they don't actually refer to any bits, but instead they refer to the signal of multiple lines (CLK, SS).\n\n\nIn the PICpilot, SPI is used for communication with the GPS, VectorNav (IMU), and the two individual cores (CPU/Microcontrollers). The GPS uses SPI2, the VectorNav uses SPI2, and the crosstalk between chips uses SPI1.\n\n\nIn the code\n\n\nEach dspic33fj256gp710a has two SPI interfaces. They are labeled SPI1 and SPI2. In the code, you won't find any SPI files present. The initialization functions are embedded in the corresponding peripheral files. The SPI1 configuration can be found on both chips, in the file, InterchipDMA.c, as well as the corresponding .h file. The function in those files is init_SPI1. In addition, on the secondary chip (in other words, the path management chip), the SPI2 (GPS) interface is also enabled in the InterchipDMA.c file, as well as the header file. The function is called init_SPI2.\n\n\nThe SPI2 configuration on the main chip (or more precisely, the attitude management chip) can be found in the VN100.c file, as well as the corresponding header file. The function name is VN100_initSPI. It initializes SPI2.\n\n\nThis table summarizes the configuration:\n\n\n\n\n\n\n\n\n\n\nSPI1\n\n\nSPI2\n\n\nSPI2\n\n\n\n\n\n\n\n\n\n\nUse\n\n\nInterchip Communication\n\n\nGPS Communication\n\n\nVectorNav Communication\n\n\n\n\n\n\nChip\n\n\nBoth chips\n\n\nSecondary (Path Managing) Chip\n\n\nPrimary (Attitude Managing) Chip\n\n\n\n\n\n\nFunction\n\n\nIn InterchipDMA.c,Init_SPI1()\n\n\nIn InterchipDMA.c,Init_SPI2()\n\n\nIn VN100.c,VN100_initSPI()\n\n\n\n\n\n\n\n\nFor detailed register maps and specifications of the SPI interface, see the \ndspic33fj256gp710A\n datasheet.\n\n\nThe most important settings are listed below.\n\n\nSPI1 \u2013 DMA and SPI2 - GPS\n\n\n//Set interrupts\n\nIFS0bits.SPI1IF = 0;\n\nIEC0bits.SPI1IE = 1;\n\nIPC2bits.SPI1IP = 4;\n\nSPI1BUF = 0;\n\n//SPI clock controlled by this module\n\nSPI1CON1bits.DISSCK = 0;\n\n//Output pins are controlled by this module\n\nSPI1CON1bits.DISSDO = 0;\n\n//16/8 bit communication mode (1/0)\n\nSPI1CON1bits.MODE16 = 1; //16\n\n//Master mode(1)/Slave mode(0)\n\nSPI1CON1bits.MSTEN = 0; //Slave\n\n//Enable Slave Select\n\nSPI1CON1bits.SSEN = 0;\n\n//Sample Phase (end/middle)\n\nSPI1CON1bits.SMP = 0; //Sample the input at the middle of the square wave\n\n//Clock Edge Select\n\nSPI1CON1bits.CKE = 0; //Output data changes from idle state to active clock state (1 is the opposite)\n\n//Clock Polarity\n\nSPI1CON1bits.CKP = 0; //Idle clock state is low, active clock state is high\n\n//Enable SPI\n\nSPI1STATbits.SPIEN = 1;\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nIFS0bits.SPI1IF\n\n\n0\n\n\nThis is the interrupt flag for the SPI1 interface.\n\n\n\n\n\n\nIEC0bits.SPI1IE\n\n\n1 (0 for GPS)\n\n\nThis is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur.\n\n\n\n\n\n\nIPC2bits.SPI1IP\n\n\n4 (0 for GPS)\n\n\nThis determines the priority of every interrupt that occurs from the SPI1 interface.\n\n\n\n\n\n\nSPI1BUF\n\n\n0\n\n\nThis is the buffer that is used for sending and receiving data. This is buffer is for both reading and writing.\n\n\n\n\n\n\nSPI1CON1bits.DISSCK\n\n\n0\n\n\nThis bit allows the SPI1 module to control the clock.\n\n\n\n\n\n\nSPI1CON1bits.DISSDO\n\n\n0\n\n\nThis bit allows the SPI1 module to convert the usual GPIO pins into SPI1 pins.\n\n\n\n\n\n\nSPI1CON1bits.MODE16\n\n\n1\n\n\nThis allows 16 bits to be transmitted per message.\n\n\n\n\n\n\nSPI1CON1bits.MSTEN\n\n\n0 or 1\n\n\nThis determines if the chip is the master (attitude manager) or the slave (path manager).\n\n\n\n\n\n\nSPI1CON1bits.SSEN\n\n\n0\n\n\nThis value enables the slave select pin.\n\n\n\n\n\n\nSPI1CON1bits.SMP\n\n\n0\n\n\nThis determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.\n\n\n\n\n\n\nSPI1CON1bits.CKE\n\n\n0\n\n\nThis bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.\n\n\n\n\n\n\nSPI1CON1bits.CKP\n\n\n0\n\n\nDetermines the clock polarity. 0 means that active clock state is high, idle state is low. 1 is the opposite.\n\n\n\n\n\n\nSPI1STATbits.SPIEN\n\n\n1\n\n\nEnables the entire SPI module.\n\n\n\n\n\n\n\n\nSPI2 - VectorNav\n\n\nThe VectorNav SPI configuration is very similar. The differences are listed below:\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nIEC0bits.SPI2IE\n\n\n0\n\n\nThis is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur. The interrupt is disabled here.\n\n\n\n\n\n\nSPI2CON1bits.MODE16\n\n\n0\n\n\nThis allows 8 bits to be transmitted per message.\n\n\n\n\n\n\nSPI2CON1bits.MSTEN\n\n\n1\n\n\nThis determines that the chip is the master and the VectorNav is the slave.\n\n\n\n\n\n\nSPI2CON1bits.SSEN\n\n\n0\n\n\nThis value enables the slave select pin.\n\n\n\n\n\n\nSPI2CON1bits.SMP\n\n\n0\n\n\nThis determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.\n\n\n\n\n\n\nSPI2CON1bits.CKE\n\n\n0\n\n\nThis bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.\n\n\n\n\n\n\nSPI2CON1bits.CKP\n\n\n1\n\n\nDetermines the clock polarity. 1 means that active clock state is low, idle state is high. 0 is the opposite.\n\n\n\n\n\n\nSPI2CON1bits.PPRE\n\n\n2\n\n\nPrescales the clock. It reduces the clock frequency at a 4:1 ratio.\n\n\n\n\n\n\nSPI2CON1bits.SPRE\n\n\n6\n\n\nThe secondary prescaler, prescales the output frequency from the primary prescaler. This one is set to reduce the frequency at a ratio of 2:1.", 
            "title": "SPI"
        }, 
        {
            "location": "/picpilot/spi/#spi", 
            "text": "SPI stands for Serial Peripheral Interface. It is similar to UART, with the exception that it is a  synchronous  method of communication. Once again, SPI is a protocol for chips to be able to communicate between on another through serial connections (data on a single wire). It always operates in full duplex mode. This means that both chips  always  transmit and receive at the same time. The minimum hardware requirements include a clock line (SCLK), a Master Out/Slave In (MOSI), a Master In/Slave Out (MISO), and a Slave Select (SS). The Master Out/In and Slave In/Out refer to the transmit and receive pins on both chips. The connections should looks like this:   Note that there is a \"Master\" and a \"Slave\". The master always initiates communication. The slave always responds first. The SCLK (clock) line counts pulses, which are synchronized to the data bits on the MOSI and MISO lines. The SS (Slave Select) line is used to notify an external chip that communication is taking place. This enables multiple chips to be connected on the same data and clock lines. This is depicted here:   In the PICpilot, there is never more than one slave per data port. In other words, one does not have to worry about scenarios (multiple slaves) such as the one depicted above.  The SPI interface transfers 8 bits per packet. The protocol is straight forward:   The start condition is initiated. The clock starts and the (selected) slave prepares to read and the master prepares to write.  On the next 8 clock pulses, the slave and master both exchange data (read and write)  After transmission, the stop condition is set. This occurs when the clock stops (high or low depending on the settings).   The PIC microcontroller specifications depict the SPI interface as follows:   Unlike UART, there is no parity bits, start bits, or stop bits. The beginning and the end of the message are commonly referred to as the  Start Condition  and the  Stop Condition , because they don't actually refer to any bits, but instead they refer to the signal of multiple lines (CLK, SS).  In the PICpilot, SPI is used for communication with the GPS, VectorNav (IMU), and the two individual cores (CPU/Microcontrollers). The GPS uses SPI2, the VectorNav uses SPI2, and the crosstalk between chips uses SPI1.", 
            "title": "SPI"
        }, 
        {
            "location": "/picpilot/spi/#in-the-code", 
            "text": "Each dspic33fj256gp710a has two SPI interfaces. They are labeled SPI1 and SPI2. In the code, you won't find any SPI files present. The initialization functions are embedded in the corresponding peripheral files. The SPI1 configuration can be found on both chips, in the file, InterchipDMA.c, as well as the corresponding .h file. The function in those files is init_SPI1. In addition, on the secondary chip (in other words, the path management chip), the SPI2 (GPS) interface is also enabled in the InterchipDMA.c file, as well as the header file. The function is called init_SPI2.  The SPI2 configuration on the main chip (or more precisely, the attitude management chip) can be found in the VN100.c file, as well as the corresponding header file. The function name is VN100_initSPI. It initializes SPI2.  This table summarizes the configuration:      SPI1  SPI2  SPI2      Use  Interchip Communication  GPS Communication  VectorNav Communication    Chip  Both chips  Secondary (Path Managing) Chip  Primary (Attitude Managing) Chip    Function  In InterchipDMA.c,Init_SPI1()  In InterchipDMA.c,Init_SPI2()  In VN100.c,VN100_initSPI()     For detailed register maps and specifications of the SPI interface, see the  dspic33fj256gp710A  datasheet.  The most important settings are listed below.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/spi/#spi1-dma-and-spi2-gps", 
            "text": "//Set interrupts\n\nIFS0bits.SPI1IF = 0;\n\nIEC0bits.SPI1IE = 1;\n\nIPC2bits.SPI1IP = 4;\n\nSPI1BUF = 0;\n\n//SPI clock controlled by this module\n\nSPI1CON1bits.DISSCK = 0;\n\n//Output pins are controlled by this module\n\nSPI1CON1bits.DISSDO = 0;\n\n//16/8 bit communication mode (1/0)\n\nSPI1CON1bits.MODE16 = 1; //16\n\n//Master mode(1)/Slave mode(0)\n\nSPI1CON1bits.MSTEN = 0; //Slave\n\n//Enable Slave Select\n\nSPI1CON1bits.SSEN = 0;\n\n//Sample Phase (end/middle)\n\nSPI1CON1bits.SMP = 0; //Sample the input at the middle of the square wave\n\n//Clock Edge Select\n\nSPI1CON1bits.CKE = 0; //Output data changes from idle state to active clock state (1 is the opposite)\n\n//Clock Polarity\n\nSPI1CON1bits.CKP = 0; //Idle clock state is low, active clock state is high\n\n//Enable SPI\n\nSPI1STATbits.SPIEN = 1;     Register  Value  Function      IFS0bits.SPI1IF  0  This is the interrupt flag for the SPI1 interface.    IEC0bits.SPI1IE  1 (0 for GPS)  This is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur.    IPC2bits.SPI1IP  4 (0 for GPS)  This determines the priority of every interrupt that occurs from the SPI1 interface.    SPI1BUF  0  This is the buffer that is used for sending and receiving data. This is buffer is for both reading and writing.    SPI1CON1bits.DISSCK  0  This bit allows the SPI1 module to control the clock.    SPI1CON1bits.DISSDO  0  This bit allows the SPI1 module to convert the usual GPIO pins into SPI1 pins.    SPI1CON1bits.MODE16  1  This allows 16 bits to be transmitted per message.    SPI1CON1bits.MSTEN  0 or 1  This determines if the chip is the master (attitude manager) or the slave (path manager).    SPI1CON1bits.SSEN  0  This value enables the slave select pin.    SPI1CON1bits.SMP  0  This determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.    SPI1CON1bits.CKE  0  This bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.    SPI1CON1bits.CKP  0  Determines the clock polarity. 0 means that active clock state is high, idle state is low. 1 is the opposite.    SPI1STATbits.SPIEN  1  Enables the entire SPI module.", 
            "title": "SPI1 \u2013 DMA and SPI2 - GPS"
        }, 
        {
            "location": "/picpilot/spi/#spi2-vectornav", 
            "text": "The VectorNav SPI configuration is very similar. The differences are listed below:     Register  Value  Function      IEC0bits.SPI2IE  0  This is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur. The interrupt is disabled here.    SPI2CON1bits.MODE16  0  This allows 8 bits to be transmitted per message.    SPI2CON1bits.MSTEN  1  This determines that the chip is the master and the VectorNav is the slave.    SPI2CON1bits.SSEN  0  This value enables the slave select pin.    SPI2CON1bits.SMP  0  This determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.    SPI2CON1bits.CKE  0  This bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.    SPI2CON1bits.CKP  1  Determines the clock polarity. 1 means that active clock state is low, idle state is high. 0 is the opposite.    SPI2CON1bits.PPRE  2  Prescales the clock. It reduces the clock frequency at a 4:1 ratio.    SPI2CON1bits.SPRE  6  The secondary prescaler, prescales the output frequency from the primary prescaler. This one is set to reduce the frequency at a ratio of 2:1.", 
            "title": "SPI2 - VectorNav"
        }, 
        {
            "location": "/picpilot/direct-memory-access/", 
            "text": "Direct Memory Access\n\n\nDirect Memory Access (or DMA), is a microcontroller feature, which allows peripheral interfaces to directly access memory, completely bypassing the CPU. The CPU only needs to setup the transfer of data. The rest of the process is done without it.\n\n\nDMA is a commonly used in graphic, network, and sound cards. More importantly, it is used in multi-core processors, which is essentially the usage of DMA in the PICpilot.\n\n\nOne DMA cycle follows this procedure:\n\n\n\n\nIn the PICpilot, the only peripheral that uses DMA is the SPI interface, although many other ones are supported.\n\n\nWhen a DMA transfer occurs, first a peripheral makes a request to the DMA controller (based on a predefined channel number). The request causes the DMA controller to read or write to a preconfigured peripheral address. Once this is completed, the DMA controller writes the data to the DPSRAM location (this is RAM dedicated to the DMA controller) or reads from it. The direction in which this transfer occurs depends on the register value corresponding to the predefined settings of the DMA controller.\n\n\nIn the PICpilot, the Direct Memory Access module is constantly active through the SPI1 module. This means that the data transmission is continuous between both chips. Essentially, when this process is continuous it provides a way to share global variables between two physical microcontrollers simultaneously. This is how path data gets transmitted to the attitude manager. The path data is made global between the two chips.\n\n\nIt should be noted that DMA is also used between the path manager chip and the GPS.\n\n\nOn the PIC microcontroller, the DMA must only be initialized. The DMA controller continues operation automatically without direct processor input. The code to initialize the interface is below.\n\n\nIn the code\n\n\nIn order to transfer data using DMA, both chips must have been initialized. In the PICpilot, only the DMA interface is initialized for data transfer between the GPS and the Path Management Chip (PM Chip), as well as the PM Chip and the Attitude Management Chip (AM Chip). Both of these connections are enabled using SPI (see previous section).\n\n\nThe GPS continuously sends data as soon as it is plugged in. It sends data in the following data format:\n\n\ntypedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;\n\n\n\nIn order to properly configure this connection the following code is used:\n\n\nGPSData gpsData __attribute__((space(dma)));\n\n/*\n\n *\n\n */\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){\n\n    newGPSDataAvailable = 1;\n\n    IFS1bits.DMA2IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA2(){\n\n    IFS1bits.DMA2IF = 0;\n\n    IEC1bits.DMA2IE = 1;\n\n    DMA2CONbits.AMODE = 0b00; //Register Indirect Mode\n\n    DMA2CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA2CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA2CONbits.SIZE = 1; //Transfer bytes (8 bits)\n\n    DMA2STA = __builtin_dmaoffset(\ngpsData); //Primary Transfer Buffer\n\n    DMA2PAD = (volatile unsigned int) \nSPI2BUF; //Peripheral Address\n\n    DMA2CNT = sizeof(GPSData) - 1; //+1 for checksum //DMA Transfer Count Length\n\n    DMA2REQ = 0b0100001; //IRQ code for SPI2\n\n    DMA2CONbits.CHEN = 1; //Enable the channel\n\n}\n\n\n\nNote how a block of memory (\"GPSData\") is reserved for the incoming data from the GPS unit.  The register values are configured as follows:\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nDMA2CONbits.AMODE\n\n\n0\n\n\nThis enables Register Indirect with Post Increment Mode. This enables data to be stored in chunks one after another (incremented locations).\n\n\n\n\n\n\nDMA2CONbits.DIR\n\n\n0\n\n\nThis indicates the direction that data travels on the bus. In this case, the data is always \nincoming\n. Therefore, it is copied from the SPI interface to the DSPRAM.\n\n\n\n\n\n\nDMA2CONbits.MODE\n\n\n0\n\n\nThis indicates if the transfer occurs a single time, or continuously, and whether a ping pong buffer should be used. It is currently enabled for continuous usage without a ping pong buffer.\n\n\n\n\n\n\nDMA2CONbits.SIZE\n\n\n1\n\n\nIndicates if each DMA transfer is 8 bits or 16 bits. In this case, it is 8 bits.\n\n\n\n\n\n\nDMA2STA\n\n\ngpsData with an added DMA offset\n\n\nThis indicates where the primary buffer is located. This memory block was initialized at the beginning of the above code snippet, where \"space(dma)\" is called.\n\n\n\n\n\n\nDMA2PAD\n\n\nSPI2BUF\n\n\nThis stores the referenced location from where the data is obtained. (This DMA channel will use the SPI2 buffer to get the data).\n\n\n\n\n\n\nDMA2CNT\n\n\nNumber of bytes in GPSData - 1\n\n\nThis is a counter variable, which indicates the number of transfers that need to be completed per DMA request.\n\n\n\n\n\n\nDMA2REQ\n\n\n0b0100001\n\n\nThis is the IRQ (Interrupt Request) code for the SPI2 interface. This allows the peripheral to send an interrupt request to the DMA controller instead of the CPU.\n\n\n\n\n\n\nDMA2CONbits.CHEN\n\n\n1\n\n\nEnables the DMA channel.\n\n\n\n\n\n\n\n\nOn the other hand, the setup between the PM chip and the AM chip is slightly different. These two chips communicate with each other simultaneously through the SPI1 interface. The code controlling the initialization found in InterchipDMA.c/.h.\n\n\nThe data being sent to the PM chip from the AM chip is in the form of:\n\n\ntypedef struct _AMData {\n\n    WaypointWrapper waypoint;\n\n    float pathGain;\n\n    float orbitGain;\n\n    float calibrationHeight;\n\n    char command;\n\n    char checksum;\n\n} AMData;\n\n\n\nVice-versa, the data being sent to the AM chip from the PM chip is in the form of:\n\n\ntypedef struct _PMData {\n\n    float time;     //4 Bytes   -  hhmmss.ssss\n\n    long double latitude;  //8 Bytes - ddd.mmmmmm\n\n    long double longitude; //8 Bytes - ddd.mmmmmm\n\n    float speed;    //KM/H\n\n    float altitude;\n\n    int sp_Altitude; // Meters\n\n    int heading;  //Degrees\n\n    int sp_Heading; //Degrees\n\n    char satellites;    //1 Byte\n\n    char positionFix;   //0 = No GPS, 1 = GPS fix, 2 = DGSP Fix\n\n    char targetWaypoint;\n\n    char batteryLevel;\n\n } PMData;\n\n\n\nThe initialization process is extremely similar for both chips (PM and AM). Each chip requires a DMA channel to read the incoming data, as well as to write the outgoing data. As a result, both the AM chip and the PM chip have the same setup with a few different variables names:\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){\n\n#if !PATH_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n#endif\n\n    newDataAvailable = 1;\n\n    IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA1Interrupt(void){\n\n    IFS0bits.DMA1IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA0(){\n\n    IFS0bits.DMA0IF = 0;\n\n    IEC0bits.DMA0IE = 1;\n\n    IPC1bits.DMA0IP = 7; //Highest Priority\n\n    DMACS0 = 0; //Clear any IO error flags\n\n    DMA0CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA0CONbits.AMODE = 0b00; //With post increment mode\n\n    DMA0CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA0CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA0STA = __builtin_dmaoffset(\namData); //Primary Transfer Buffer\n\n#else\n\n    DMA0STA = __builtin_dmaoffset(\npmData); //Primary Transfer Buffer\n\n#endif\n\n    DMA0PAD = (volatile unsigned int) \nSPI1BUF; //Peripheral Address\n\n    DMA0CNT = PATH_MANAGER?(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1):(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA0REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA0CONbits.CHEN = 1; //Enable the channel\n\n}\n\nvoid init_DMA1(){\n\n    IFS0bits.DMA1IF = 0;\n\n    IEC0bits.DMA1IE = 1;\n\n    IPC3bits.DMA1IP = 7;\n\n    DMACS1 = 0; //Clear any IO error flags\n\n    DMA1CONbits.DIR = 1; //Transfer from DSPRAM to SPI\n\n    DMA1CONbits.AMODE = 0b00; //Without post increment mode\n\n    DMA1CONbits.MODE = 0b00; //Transfer continuously, ping ponging between buffers\n\n    DMA1CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA1STA = __builtin_dmaoffset(\npmData); //Primary Transfer Buffer\n\n#else\n\n    DMA1STA = __builtin_dmaoffset(\namData); //Primary Transfer Buffer\n\n#endif\n\n    DMA1PAD = (volatile unsigned int) \nSPI1BUF; //Peripheral Address\n\n    DMA1CNT = PATH_MANAGER?(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1):(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA1REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA1CONbits.CHEN = 1; //Enable the channel\n\n}\n\n\n\nThe above code is very similar to the first example with the GPS. The differences include the direction of data transfer, the buffer variables, the IRQ codes, as well as the 16 bit mode interfacing.\n\n\nAlso, in order to initialize transfer, the SPI master must send the first packet. This is evident in the DMA0 interrupt routine:\n\n\n#if !PATH\\_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n #endif\n\n\n\nA DMA request is forced by setting the DMA1REQbits.FORCE bit to 1. The following sets of data do not need to be forced, they happen automatically (since continuous mode was enabled).", 
            "title": "Direct Memory Access"
        }, 
        {
            "location": "/picpilot/direct-memory-access/#direct-memory-access", 
            "text": "Direct Memory Access (or DMA), is a microcontroller feature, which allows peripheral interfaces to directly access memory, completely bypassing the CPU. The CPU only needs to setup the transfer of data. The rest of the process is done without it.  DMA is a commonly used in graphic, network, and sound cards. More importantly, it is used in multi-core processors, which is essentially the usage of DMA in the PICpilot.  One DMA cycle follows this procedure:   In the PICpilot, the only peripheral that uses DMA is the SPI interface, although many other ones are supported.  When a DMA transfer occurs, first a peripheral makes a request to the DMA controller (based on a predefined channel number). The request causes the DMA controller to read or write to a preconfigured peripheral address. Once this is completed, the DMA controller writes the data to the DPSRAM location (this is RAM dedicated to the DMA controller) or reads from it. The direction in which this transfer occurs depends on the register value corresponding to the predefined settings of the DMA controller.  In the PICpilot, the Direct Memory Access module is constantly active through the SPI1 module. This means that the data transmission is continuous between both chips. Essentially, when this process is continuous it provides a way to share global variables between two physical microcontrollers simultaneously. This is how path data gets transmitted to the attitude manager. The path data is made global between the two chips.  It should be noted that DMA is also used between the path manager chip and the GPS.  On the PIC microcontroller, the DMA must only be initialized. The DMA controller continues operation automatically without direct processor input. The code to initialize the interface is below.", 
            "title": "Direct Memory Access"
        }, 
        {
            "location": "/picpilot/direct-memory-access/#in-the-code", 
            "text": "In order to transfer data using DMA, both chips must have been initialized. In the PICpilot, only the DMA interface is initialized for data transfer between the GPS and the Path Management Chip (PM Chip), as well as the PM Chip and the Attitude Management Chip (AM Chip). Both of these connections are enabled using SPI (see previous section).  The GPS continuously sends data as soon as it is plugged in. It sends data in the following data format:  typedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;  In order to properly configure this connection the following code is used:  GPSData gpsData __attribute__((space(dma)));\n\n/*\n\n *\n\n */\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){\n\n    newGPSDataAvailable = 1;\n\n    IFS1bits.DMA2IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA2(){\n\n    IFS1bits.DMA2IF = 0;\n\n    IEC1bits.DMA2IE = 1;\n\n    DMA2CONbits.AMODE = 0b00; //Register Indirect Mode\n\n    DMA2CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA2CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA2CONbits.SIZE = 1; //Transfer bytes (8 bits)\n\n    DMA2STA = __builtin_dmaoffset( gpsData); //Primary Transfer Buffer\n\n    DMA2PAD = (volatile unsigned int)  SPI2BUF; //Peripheral Address\n\n    DMA2CNT = sizeof(GPSData) - 1; //+1 for checksum //DMA Transfer Count Length\n\n    DMA2REQ = 0b0100001; //IRQ code for SPI2\n\n    DMA2CONbits.CHEN = 1; //Enable the channel\n\n}  Note how a block of memory (\"GPSData\") is reserved for the incoming data from the GPS unit.  The register values are configured as follows:     Register  Value  Function      DMA2CONbits.AMODE  0  This enables Register Indirect with Post Increment Mode. This enables data to be stored in chunks one after another (incremented locations).    DMA2CONbits.DIR  0  This indicates the direction that data travels on the bus. In this case, the data is always  incoming . Therefore, it is copied from the SPI interface to the DSPRAM.    DMA2CONbits.MODE  0  This indicates if the transfer occurs a single time, or continuously, and whether a ping pong buffer should be used. It is currently enabled for continuous usage without a ping pong buffer.    DMA2CONbits.SIZE  1  Indicates if each DMA transfer is 8 bits or 16 bits. In this case, it is 8 bits.    DMA2STA  gpsData with an added DMA offset  This indicates where the primary buffer is located. This memory block was initialized at the beginning of the above code snippet, where \"space(dma)\" is called.    DMA2PAD  SPI2BUF  This stores the referenced location from where the data is obtained. (This DMA channel will use the SPI2 buffer to get the data).    DMA2CNT  Number of bytes in GPSData - 1  This is a counter variable, which indicates the number of transfers that need to be completed per DMA request.    DMA2REQ  0b0100001  This is the IRQ (Interrupt Request) code for the SPI2 interface. This allows the peripheral to send an interrupt request to the DMA controller instead of the CPU.    DMA2CONbits.CHEN  1  Enables the DMA channel.     On the other hand, the setup between the PM chip and the AM chip is slightly different. These two chips communicate with each other simultaneously through the SPI1 interface. The code controlling the initialization found in InterchipDMA.c/.h.  The data being sent to the PM chip from the AM chip is in the form of:  typedef struct _AMData {\n\n    WaypointWrapper waypoint;\n\n    float pathGain;\n\n    float orbitGain;\n\n    float calibrationHeight;\n\n    char command;\n\n    char checksum;\n\n} AMData;  Vice-versa, the data being sent to the AM chip from the PM chip is in the form of:  typedef struct _PMData {\n\n    float time;     //4 Bytes   -  hhmmss.ssss\n\n    long double latitude;  //8 Bytes - ddd.mmmmmm\n\n    long double longitude; //8 Bytes - ddd.mmmmmm\n\n    float speed;    //KM/H\n\n    float altitude;\n\n    int sp_Altitude; // Meters\n\n    int heading;  //Degrees\n\n    int sp_Heading; //Degrees\n\n    char satellites;    //1 Byte\n\n    char positionFix;   //0 = No GPS, 1 = GPS fix, 2 = DGSP Fix\n\n    char targetWaypoint;\n\n    char batteryLevel;\n\n } PMData;  The initialization process is extremely similar for both chips (PM and AM). Each chip requires a DMA channel to read the incoming data, as well as to write the outgoing data. As a result, both the AM chip and the PM chip have the same setup with a few different variables names:  void __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){\n\n#if !PATH_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n#endif\n\n    newDataAvailable = 1;\n\n    IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA1Interrupt(void){\n\n    IFS0bits.DMA1IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA0(){\n\n    IFS0bits.DMA0IF = 0;\n\n    IEC0bits.DMA0IE = 1;\n\n    IPC1bits.DMA0IP = 7; //Highest Priority\n\n    DMACS0 = 0; //Clear any IO error flags\n\n    DMA0CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA0CONbits.AMODE = 0b00; //With post increment mode\n\n    DMA0CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA0CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA0STA = __builtin_dmaoffset( amData); //Primary Transfer Buffer\n\n#else\n\n    DMA0STA = __builtin_dmaoffset( pmData); //Primary Transfer Buffer\n\n#endif\n\n    DMA0PAD = (volatile unsigned int)  SPI1BUF; //Peripheral Address\n\n    DMA0CNT = PATH_MANAGER?(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1):(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA0REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA0CONbits.CHEN = 1; //Enable the channel\n\n}\n\nvoid init_DMA1(){\n\n    IFS0bits.DMA1IF = 0;\n\n    IEC0bits.DMA1IE = 1;\n\n    IPC3bits.DMA1IP = 7;\n\n    DMACS1 = 0; //Clear any IO error flags\n\n    DMA1CONbits.DIR = 1; //Transfer from DSPRAM to SPI\n\n    DMA1CONbits.AMODE = 0b00; //Without post increment mode\n\n    DMA1CONbits.MODE = 0b00; //Transfer continuously, ping ponging between buffers\n\n    DMA1CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA1STA = __builtin_dmaoffset( pmData); //Primary Transfer Buffer\n\n#else\n\n    DMA1STA = __builtin_dmaoffset( amData); //Primary Transfer Buffer\n\n#endif\n\n    DMA1PAD = (volatile unsigned int)  SPI1BUF; //Peripheral Address\n\n    DMA1CNT = PATH_MANAGER?(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1):(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA1REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA1CONbits.CHEN = 1; //Enable the channel\n\n}  The above code is very similar to the first example with the GPS. The differences include the direction of data transfer, the buffer variables, the IRQ codes, as well as the 16 bit mode interfacing.  Also, in order to initialize transfer, the SPI master must send the first packet. This is evident in the DMA0 interrupt routine:  #if !PATH\\_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n #endif  A DMA request is forced by setting the DMA1REQbits.FORCE bit to 1. The following sets of data do not need to be forced, they happen automatically (since continuous mode was enabled).", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/i2c/", 
            "text": "I2C\n\n\nI2C stands for Inter-Integrated Circuit. It is pronounced \"I-two-C\" or \"I-squared-C\". It is similar to SPI, with the exception that it does not require a slave select line. All communication takes place on one data line, and one clock line. I2C is a \nsynchronous\n method of communication, indicating that a clock line is present. Once again, I2C is a protocol for chips to be able to communicate between one another through serial connections (data on a single wire). It cannot operate in full duplex mode, unlike SPI. This means that both chips take turns transmitting and receiving and cannot do so at the same time. The minimum hardware requirements include a clock line (SCL), a data line (SDA), and both lines connected to Vdd via a pull-up resistor. The connections should looks like this:\n\n\n\n\nThis protocol is extremely simple from a hardware point of view. However, it is significantly slower than SPI, which is the main disadvantage. If you require high speed communication, I2C is not the best choice.\n\n\nIn a similar fashion to SPI, I2C also has Master and Slave devices. I2C protocol dictates that the master must always initialize communication.\n\n\nThere are two types of messages that a master device can send. It can be a read or a write message. Both messages are similar in structure; however, the read message requires the slave to respond, whereas the write message does not.\n\n\nThe write message is structured in the following order:\n\n\n\n\nStart condition is specified on SDA and SCL (depends on the settings but typically involves the master pulling the data line low, shortly followed by the clock line being pulled low)\n\n\nAn 8-bit message is then sent, which contains a 7-bit (unique) identifying address, which determines what slave will engage in the data transfer. The 8th bit of the message is a read or write bit. When the bit is low (0), this indicates a write. When the bit is high (1), this indicates a read. In this scenario, we express the write bit (0).\n\n\nThe master waits for an acknowledgment from the slave. The acknowledgment is the slave pulling the data line low (0), while the master listens. If the acknowledgment is not received, there is likely a problem with the device or the connection.\n\n\nAt this point data is written 8 bits at a time, until the stop condition is expressed by the master. After each bit, the slave must acknowledge (ACK).\n\n\nThe stop condition is expressed. (SDA is pulled low, then the SCL is pulled high and it stops pulsing. The SDA is then also pulled high.)\n\n\n\n\nThe read message is very similar to the write message. The start condition and the first byte (address and write bit) must always be present. If a read condition is to exist, a repeated restart must be executed followed by the address of the slave with the read bit (1). The second byte/message may be a command message. Following the message, for the next 8 bytes, the master will expect a response to the command.\n\n\nAssuming that the write message from above was never stopped, the read message would be as follows:\n\n\n\n\nExecute a repeated restart.\n\n\nSend the slave address with a read bit (1).\n\n\nThe slave will respond with 8 bits of data. These 8 bits of data depend on the message sent prior to the repeated restart.\n\n\nThe master will not acknowledge (Yes I know, laugh all you want)\n\n\nThe stop condition or a repeated restart is executed.\n\n\n\n\nA visual depiction of a common I2C message is below:\n\n\n\n\nOn the PICpilot, the only I2C peripheral currently in use is the altimeter. The altimeter is connected to the path managing chip.\n\n\nIn the code\n\n\nThe initialization of I2C on the dspic33fj256710a is very simple. There are only a few necessary choices to make:\n\n\nI2C2CONbits.A10M = 0;   //7 bit address mode\n\nI2C2CONbits.DISSLW = 1; //Slew Rate control disabled for 100KHz\n\nI2C2CONbits.SMEN = 0;   //Do NOT use SMBus voltage configuration\n\n///I2C1BRG  - BAUD RATE GENERATOR\n\n///MPL3115A2 requires Max 4MHz\n\nI2C2BRG = 19;           //~118KHz clock rate; FCY = 4MHz\n\n//Enable the I2C module\n\nI2C2CONbits.I2CEN = 1;\n\n\n\nAs you can see, there are only a few important distinctions to make. Firstly, you can have a 10 bit addressing mode or a 7 bit addressing mode. On the PICpilot we use the 7 bit mode.\n\n\nSecondly, the clock rate is set via the I2C2BRG register. This could be upgraded to a faster communication speed in the future. The I2C module is then enabled.\n\n\nAt this point reading and writing can take place. The function to do so is called \nsendMessage()\n:\n\n\nchar sendMessage(char devAddress, char address, char\\* data, char length, char rw)\n\n{\n\n    char rData = 0;\n\n    I2CIdle();\n\n    I2C2CONbits.SEN = 1;  //Send Start condition\n\n    I2CIdle();\n\n    //SET Slave Address \n write (Address shifted one bit left and then the write(0) bit is added)\n\n    I2C2TRN = devAddress \n 1; //If reading, the read process is specified after the dummy bytes.\n\n    if (rw == READ) //If in reading mode\n\n    {\n\n        rData = readMessage(devAddress, address);\n\n    }\n\n    else //Otherwise go into writing mode\n\n    {\n\n       writeMessage(address,data, length);\n\n    }\n\n    I2CIdle();\n\n    I2C2CONbits.PEN = 1; //Send Stop condition\n\n    I2CIdle();\n\n    return rData;\n\n}\n\n\n\nIn the above code, the I2CIdle(); command is a while loop, which waits until the module is ready to transmit:\n\n\nwhile((I2C2CON \n 0x1F ) || I2C2STATbits.TRSTAT == 1);\n\n\n\nIn the code, it is evident that the start condition is asserted (using control register 2), followed by loading the device address and the write bit into the \nI2C2TRN\n transmit buffer. At this point the read or write functions are executed, depending on the request, before finally sending the stop condition.\n\n\nThe write command is extremely simple. It simply loops through the data, waiting for an acknowledgment after each one.\n\n\nvoid writeMessage(char address, char\\* data, char length)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the address.\n\n    //Write each byte of data\n\n    int i = 0;\n\n    for(i = 0; i \n length; i++)\n\n    {\n\n        I2CIdle();//Check until transmition was completed\n\n        I2C2TRN = (char)data[i];\n\n    }\n\n}\n\n\n\nNote, that the register address is first specified, followed by the iteration of bits that is sent to the buffer.\n\n\nOn the contrary the read message is a bit more complicated:\n\n\nchar readMessage(char devAddress, char address)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the local address.\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2CONbits.RSEN = 1; //Resend the start condition\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2TRN = (devAddress \n 1) + 1; //Shift and add the read bit(1) - Prep for restart\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    ///THE MESSAGE FROM THE SLAVE IS SENT HERE\n\n    I2C2CONbits.RCEN = 1; //Enable receive mode\n\n    I2CIdle(); //Wait until all 8 bits have been acquired\n\n    while (I2C2STATbits.RBF != 1);\n\n    char data = I2C2RCV;\n\n    //Send back a NACK\n\n    I2C2CONbits.ACKDT = 1; //Send NACK\n\n    I2C2CONbits.ACKEN = 1; //Start the acknowledge sequence\n\n    I2CIdle(); //Wait until done\n\n    return data;\n\n}\n\n\n\nThe register address is sent, which is followed by a restart condition. Then the device address is sent, BUT this time, the read bit is sent. At this point, the master enables receiving and waits until all data is received. A NACK (Not Acknowledgement) is sent prior to returning the data.\n\n\nThe device and register addresses depend on the device and its functionality.", 
            "title": "I2C"
        }, 
        {
            "location": "/picpilot/i2c/#i2c", 
            "text": "I2C stands for Inter-Integrated Circuit. It is pronounced \"I-two-C\" or \"I-squared-C\". It is similar to SPI, with the exception that it does not require a slave select line. All communication takes place on one data line, and one clock line. I2C is a  synchronous  method of communication, indicating that a clock line is present. Once again, I2C is a protocol for chips to be able to communicate between one another through serial connections (data on a single wire). It cannot operate in full duplex mode, unlike SPI. This means that both chips take turns transmitting and receiving and cannot do so at the same time. The minimum hardware requirements include a clock line (SCL), a data line (SDA), and both lines connected to Vdd via a pull-up resistor. The connections should looks like this:   This protocol is extremely simple from a hardware point of view. However, it is significantly slower than SPI, which is the main disadvantage. If you require high speed communication, I2C is not the best choice.  In a similar fashion to SPI, I2C also has Master and Slave devices. I2C protocol dictates that the master must always initialize communication.  There are two types of messages that a master device can send. It can be a read or a write message. Both messages are similar in structure; however, the read message requires the slave to respond, whereas the write message does not.  The write message is structured in the following order:   Start condition is specified on SDA and SCL (depends on the settings but typically involves the master pulling the data line low, shortly followed by the clock line being pulled low)  An 8-bit message is then sent, which contains a 7-bit (unique) identifying address, which determines what slave will engage in the data transfer. The 8th bit of the message is a read or write bit. When the bit is low (0), this indicates a write. When the bit is high (1), this indicates a read. In this scenario, we express the write bit (0).  The master waits for an acknowledgment from the slave. The acknowledgment is the slave pulling the data line low (0), while the master listens. If the acknowledgment is not received, there is likely a problem with the device or the connection.  At this point data is written 8 bits at a time, until the stop condition is expressed by the master. After each bit, the slave must acknowledge (ACK).  The stop condition is expressed. (SDA is pulled low, then the SCL is pulled high and it stops pulsing. The SDA is then also pulled high.)   The read message is very similar to the write message. The start condition and the first byte (address and write bit) must always be present. If a read condition is to exist, a repeated restart must be executed followed by the address of the slave with the read bit (1). The second byte/message may be a command message. Following the message, for the next 8 bytes, the master will expect a response to the command.  Assuming that the write message from above was never stopped, the read message would be as follows:   Execute a repeated restart.  Send the slave address with a read bit (1).  The slave will respond with 8 bits of data. These 8 bits of data depend on the message sent prior to the repeated restart.  The master will not acknowledge (Yes I know, laugh all you want)  The stop condition or a repeated restart is executed.   A visual depiction of a common I2C message is below:   On the PICpilot, the only I2C peripheral currently in use is the altimeter. The altimeter is connected to the path managing chip.", 
            "title": "I2C"
        }, 
        {
            "location": "/picpilot/i2c/#in-the-code", 
            "text": "The initialization of I2C on the dspic33fj256710a is very simple. There are only a few necessary choices to make:  I2C2CONbits.A10M = 0;   //7 bit address mode\n\nI2C2CONbits.DISSLW = 1; //Slew Rate control disabled for 100KHz\n\nI2C2CONbits.SMEN = 0;   //Do NOT use SMBus voltage configuration\n\n///I2C1BRG  - BAUD RATE GENERATOR\n\n///MPL3115A2 requires Max 4MHz\n\nI2C2BRG = 19;           //~118KHz clock rate; FCY = 4MHz\n\n//Enable the I2C module\n\nI2C2CONbits.I2CEN = 1;  As you can see, there are only a few important distinctions to make. Firstly, you can have a 10 bit addressing mode or a 7 bit addressing mode. On the PICpilot we use the 7 bit mode.  Secondly, the clock rate is set via the I2C2BRG register. This could be upgraded to a faster communication speed in the future. The I2C module is then enabled.  At this point reading and writing can take place. The function to do so is called  sendMessage() :  char sendMessage(char devAddress, char address, char\\* data, char length, char rw)\n\n{\n\n    char rData = 0;\n\n    I2CIdle();\n\n    I2C2CONbits.SEN = 1;  //Send Start condition\n\n    I2CIdle();\n\n    //SET Slave Address   write (Address shifted one bit left and then the write(0) bit is added)\n\n    I2C2TRN = devAddress   1; //If reading, the read process is specified after the dummy bytes.\n\n    if (rw == READ) //If in reading mode\n\n    {\n\n        rData = readMessage(devAddress, address);\n\n    }\n\n    else //Otherwise go into writing mode\n\n    {\n\n       writeMessage(address,data, length);\n\n    }\n\n    I2CIdle();\n\n    I2C2CONbits.PEN = 1; //Send Stop condition\n\n    I2CIdle();\n\n    return rData;\n\n}  In the above code, the I2CIdle(); command is a while loop, which waits until the module is ready to transmit:  while((I2C2CON   0x1F ) || I2C2STATbits.TRSTAT == 1);  In the code, it is evident that the start condition is asserted (using control register 2), followed by loading the device address and the write bit into the  I2C2TRN  transmit buffer. At this point the read or write functions are executed, depending on the request, before finally sending the stop condition.  The write command is extremely simple. It simply loops through the data, waiting for an acknowledgment after each one.  void writeMessage(char address, char\\* data, char length)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the address.\n\n    //Write each byte of data\n\n    int i = 0;\n\n    for(i = 0; i   length; i++)\n\n    {\n\n        I2CIdle();//Check until transmition was completed\n\n        I2C2TRN = (char)data[i];\n\n    }\n\n}  Note, that the register address is first specified, followed by the iteration of bits that is sent to the buffer.  On the contrary the read message is a bit more complicated:  char readMessage(char devAddress, char address)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the local address.\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2CONbits.RSEN = 1; //Resend the start condition\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2TRN = (devAddress   1) + 1; //Shift and add the read bit(1) - Prep for restart\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    ///THE MESSAGE FROM THE SLAVE IS SENT HERE\n\n    I2C2CONbits.RCEN = 1; //Enable receive mode\n\n    I2CIdle(); //Wait until all 8 bits have been acquired\n\n    while (I2C2STATbits.RBF != 1);\n\n    char data = I2C2RCV;\n\n    //Send back a NACK\n\n    I2C2CONbits.ACKDT = 1; //Send NACK\n\n    I2C2CONbits.ACKEN = 1; //Start the acknowledge sequence\n\n    I2CIdle(); //Wait until done\n\n    return data;\n\n}  The register address is sent, which is followed by a restart condition. Then the device address is sent, BUT this time, the read bit is sent. At this point, the master enables receiving and waits until all data is received. A NACK (Not Acknowledgement) is sent prior to returning the data.  The device and register addresses depend on the device and its functionality.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/datalink/", 
            "text": "Datalink\n\n\nThe datalink is one of the most important peripheral components in an unmanned system. It provides information on the status of the aircraft (telemetry) and provides the crucial functionality of an uplink, in order to be able to communicate with the system and make changes to its overall functionality.\n\n\nMake note that the details of this system can change frequently due to the requirements of each user. The telemetry data may change from the ones present in this document. Likewise, uplink commands may change based on newly implemented features and requirements. Although, this document should be updated whenever there is a change, this may not always occur. Therefore, be careful when referencing data in this section.\n\n\nTelemetry (Downlink) Data\n\n\n\n\n\n\n\n\nData\n\n\nProgramming Variable\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLatitude\n\n\nLat\n\n\nLong double (64bit floating point)\n\n\nThe latitude location of the airplane in degrees.\n\n\n\n\n\n\nLongitude\n\n\nLon\n\n\nLong double (64bit floating point)\n\n\nThe longitude location of the airplane in degrees.\n\n\n\n\n\n\nTime\n\n\nTime\n\n\nFloat (32 bit floating point)\n\n\nThe time as a UTC time stamp.\n\n\n\n\n\n\nPitch\n\n\nPitch\n\n\nFloat\n\n\nThe current state estimation of the pitch of the aircraft in degrees.\n\n\n\n\n\n\nRoll\n\n\nRoll\n\n\nFloat\n\n\nThe current state estimation of the roll of the aircraft in degrees.\n\n\n\n\n\n\nYaw\n\n\nYaw\n\n\nFloat\n\n\nThe current state estimation of the yaw of the aircraft according to the magnetometer in degrees.\n\n\n\n\n\n\nPitch Rate\n\n\nPitch_rate\n\n\nFloat\n\n\nThe gyroscope sensor data. The rate of rotation of the aircraft in radians per second.\n\n\n\n\n\n\nRoll Rate\n\n\nRoll_rate\n\n\nFloat\n\n\nThe gyroscope sensor data. The rate of rotation of the aircraft in radians per second.\n\n\n\n\n\n\nYaw Rate\n\n\nYaw_rate\n\n\nFloat\n\n\nThe gyroscope sensor data. The rate of rotation of the aircraft in radians per second.\n\n\n\n\n\n\nDerivative Gain\n\n\nKd_gain\n\n\nFloat\n\n\nA predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.\n\n\n\n\n\n\nProportional Gain\n\n\nKp_gain\n\n\nFloat\n\n\nA predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.\n\n\n\n\n\n\nIntegral Gain\n\n\nKi_gain\n\n\nFloat\n\n\nA predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.\n\n\n\n\n\n\nHeading\n\n\nHeading\n\n\nFloat\n\n\nThe GPS heading of the aircraft in degrees ranging from 0 to 360.\n\n\n\n\n\n\nGround Speed\n\n\nGround_speed\n\n\nFloat\n\n\nThe ground speed of the aircraft in meters per second.\n\n\n\n\n\n\nPitch Setpoint\n\n\nPitch_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the pitch angle in degrees.\n\n\n\n\n\n\nRoll Setpoint\n\n\nRoll_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the Roll angle in degrees.\n\n\n\n\n\n\nHeading Setpoint\n\n\nheading_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the heading angle in degrees.\n\n\n\n\n\n\nThrottle Setpoint\n\n\nThrottle_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the propeller speed in terms of percentage (0-100%)\n\n\n\n\n\n\nAltitude Setpoint\n\n\naltitude_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the altitude above mean sea level. (in meters)\n\n\n\n\n\n\nAltitude\n\n\naltitude\n\n\nFloat\n\n\nThe altitude of the plane above the mean sea level (in meters)\n\n\n\n\n\n\nPitch Setpoint (Controller)\n\n\nint_pitch_setpoint\n\n\nFloat\n\n\nThe user input for the Pitch angle in arbitrary timer tick units.\n\n\n\n\n\n\nRoll Setpoint(Controller)\n\n\nint_roll_setpoint\n\n\nFloat\n\n\nThe user input for the Roll angle in arbitrary timer tick units.\n\n\n\n\n\n\nYaw Setpoint (Controller)\n\n\nint_yaw_setpoint\n\n\nFloat\n\n\nThe user input for the yaw angle in arbitrary timer tick units.\n\n\n\n\n\n\nLast Wireless Command Sent\nReceived\n\n\nlastCommandSent\n\n\nint\n\n\nThis is a combination of the command number (commands.h) multiplied by 100. For every subsequent call, the number is incremented by 1.For example, if the return home command was called 5 times, this variable would be equal to: \n4105\n\n\n\n\n\n\nError Codes\n\n\nerrorCodes\n\n\nUnsigned int\n\n\nSignals any problems that may be occurring or have occurred.This value is retrieved from StartupErrorCodes.c. The possible values are (and any binary combination):0b0000000000000000: No Errors0b0000000000000001:Power on reset occurred.0b0000000000000010:Brown out reset occurred.0b0000000000000100:Idle Mode Reset Occurred.0b0000000000001000:Sleep Mode Reset Occurred.0b0000000000010000:Software Watch Dog Timer Reset Occurred.0b0000000000100000:Software Reset Occurred.0b0000000001000000:External Reset Occurred.0b0000000010000000:Voltage Regulator Reset Occurred.0b0000000100000000:Illegal Opcode Reset Occurred.0b0000001000000000:Trap Reset Occurred.0b1000000000000000:UHF Switch is ON (Can be used to indicate joystick controller connection)\n\n\n\n\n\n\nCamera Counter\n\n\ncameraCounter\n\n\nUnsigned Int\n\n\nEvery time the camera is triggered, this value increases by one. This allows one to keep track which picture corresponds to what data.\n\n\n\n\n\n\nWaypoint Index\n\n\nwaypointIndex\n\n\nChar\n\n\nIndicates what waypoint the vehicle is attempting to get to.-1 - indicates that the vehicle is going \"HOME\"Any other value indicates the waypoint in the order that it was added.\n\n\n\n\n\n\nController Status Indicator\n\n\nEditing_gain\n\n\nChar\n\n\nAn indicator that depicts which gain values are currently being changed.0x00 = Manual Mode0x01 = Yaw0x02 = Pitch0x03 = Roll0x04 = Heading0x05 = Altitude0x06 = Throttle\n\n\n\n\n\n\nGPS Status Indicator\n\n\nGps_status\n\n\nChar\n\n\nAn indicator that depicts the number of satellites connected, as well as the status of the gps fix. Format:0x\n For example:0x00 = No GPS Fix, 0 Satellites0x1A = GPS Fix, 10 Satellites0x24 = DGPS Fix, 4 Satellites\n\n\n\n\n\n\nBattery Level Indicator\n\n\nbatteryLevel\n\n\nChar\n\n\nThis indicator provides the battery level as a percentage (%) of the original battery capacity specified in the voltageSensor.c/h files.\n\n\n\n\n\n\n\n\nNote that all telemetry data must be visible within the scope of the AttitudeManager.c file.\n\n\nCommand (Uplink) Data\n\n\nEvery command that is sent to the UAV must be predefined with an ID, as well as an associated function. Some commands only change variable values, whereas some call functions with the associated data as a parameter.\n\n\n\n\n\n\n\n\nCommand ID\n\n\nSocket Command\n\n\nAssociated Function\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\ndebug:\n\n\nUART1_SendString(\n)\n\n\nChar Array\n\n\nThe debugging command, which writes to the UART1 port.\n\n\n\n\n\n\n1\n\n\nset_pitchKDGain:\n\n\nsetGain(PITCH, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for pitch control.\n\n\n\n\n\n\n2\n\n\nset_rollKDGain:\n\n\nsetGain(ROLL, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for roll control.\n\n\n\n\n\n\n3\n\n\nset_yawKDGain:\n\n\nsetGain(YAW, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for yaw control.\n\n\n\n\n\n\n4\n\n\nset_pitchKPGain:\n\n\nsetGain(PITCH, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for pitch control.\n\n\n\n\n\n\n5\n\n\nset_rollKPGain:\n\n\nsetGain(ROLL, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for roll control.\n\n\n\n\n\n\n6\n\n\nset_yawKPGain:\n\n\nsetGain(YAW, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for yaw control.\n\n\n\n\n\n\n7\n\n\nset_pitchKIGain:\n\n\nsetGain(PITCH, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for pitch control.\n\n\n\n\n\n\n8\n\n\nset_rollKIGain:\n\n\nsetGain(ROLL, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for roll control.\n\n\n\n\n\n\n9\n\n\nset_yawKIGain:\n\n\nsetGain(YAW, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for yaw control.\n\n\n\n\n\n\n10\n\n\nset_headingKDGain:\n\n\nsetGain(HEADING, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for heading control.\n\n\n\n\n\n\n11\n\n\nset_headingKPGain:\n\n\nsetGain(HEADING, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for heading control.\n\n\n\n\n\n\n12\n\n\nset_headingKIGain:\n\n\nsetGain(HEADING, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for heading control.\n\n\n\n\n\n\n13\n\n\nset_altitudeKDGain:\n\n\nsetGain(ALTITUDE, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for altitude control.\n\n\n\n\n\n\n14\n\n\nset_altitudeKPGain:\n\n\nsetGain(ALTITUDE, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for altitude control.\n\n\n\n\n\n\n15\n\n\nset_altitudeKIGain:\n\n\nsetGain(ALTITUDE, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for altitude control.\n\n\n\n\n\n\n16\n\n\nset_throttleKDGain:\n\n\nsetGain(THROTTLE, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for throttle control (speed).\n\n\n\n\n\n\n17\n\n\nset_throttleKPGain:\n\n\nsetGain(THROTTLE, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for throttle control (speed).\n\n\n\n\n\n\n18\n\n\nset_throttleKIGain:\n\n\nsetGain(THROTTLE, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for throttle control (speed).\n\n\n\n\n\n\n19\n\n\nset_pathGain:\n\n\nCurrently Unsupported, but will not cause errors if set\n\n\nFloat\n\n\nThe command used to set the gain that scales lateral positional control around a path.\n\n\n\n\n\n\n20\n\n\nset_orbitGain:\n\n\nCurrently Unsupported, but will not cause errors if set\n\n\nFloat\n\n\nThe command used to set the gain that scales orbital convergence.\n\n\n\n\n\n\n21\n\n\nset_showGain:\n\n\ndisplayGain = \n\n\nChar\n\n\nThe command used to switch the output between multiple gain types:0x00 = Yaw0x01 = Pitch0x02 = Roll0x03 = Heading0x04 = Altitude0x05 = Throttle*Note that there is no support for the path gain or orbital gain yet.\n\n\n\n\n\n\n22\n\n\nset_pitchRate:\n\n\nsp_PitchRate = \n\n\nInt\n\n\nThe user input for the pitch rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]). Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n23\n\n\nset_rollRate:\n\n\nsp_RollRate = \n\n\nInt\n\n\nThe user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n24\n\n\nset_yawRate:\n\n\nsp_YawRate = \n\n\nInt\n\n\nThe user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n25\n\n\nset_pitchAngle:\n\n\nsp_PitchAngle = \n\n\nFloat\n\n\nThe user input for the pitch angle in degrees. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n26\n\n\nset_rollAngle:\n\n\nsp_RollAngle = \n\n\nFloat\n\n\nThe user input for the roll angle in degrees. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n27\n\n\nset_yawAngle:\n\n\nCurrently Unsupported, but will not cause errors if set\n\n\nFloat\n\n\nThe user input for the yaw angle in degrees. WILL LIKELY BE REMOVED IN THE FUTURE IF UNEEDED. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n28\n\n\nset_altitude:\n\n\nsp_Altitude = \n\n\nFloat\n\n\nThe user input for the altitude in meters above sea level. Note you must set command 32 greater than 6 to use this.\n\n\n\n\n\n\n29\n\n\nset_heading:\n\n\nsp_Heading = \n\n\nFloat\n\n\nThe user input for the heading in standard compass bearing degrees. Note you must set command 32 greater than 7 to use this.\n\n\n\n\n\n\n30\n\n\nset_throttle:\n\n\nsp_Throttle = \n\n\nInt\n\n\nThe user input for the throttle as a percentage. Note you must set command 32 to 8 to use this.\n\n\n\n\n\n\n31\n\n\nset_autonomousLevel:\n\n\ncontrolLevel = \n\n\nInt\n\n\nThis sets the source of control input between the autopilot, the remote control, and the ground stations:0b00000000 = Full manual control (default)0b00000001 = Set Pitch Rate(0), Pitch Angle(1)0b00000010 = Pitch Control Source: Controller(0), Ground Station(1) 0b00000100 = Roll Control Type: Roll Rate(0), Roll Angle(1)0b00001000 = Roll Control Sources: Controller(0), Ground Station(1)0b00110000 = Throttle control source: Controller(0), Ground Station(1), Autopilot(2) 0b01000000 = Altitude Source: Ground Station(0), Autopilot(1)0b10000000 = Altitude Control On(1) or Off(0)0b100000000 = Heading control source: Ground Station(0), Autopilot(1)0b1000000000=  To fly with Ground Station Control of the Pitch Rate and Roll Angle:set_autonomousLevel:14To fly with Ground Station Control of the Pitch Rate, Roll Angle, and Throttle:set_autonomousLevel:30To fly with Ground Station Control of Altitude, and Throttle (Roll controlled by controller):set_autonomousLevel:134To fly with Ground Station Control of Altitude, Throttle, Roll Angle:set_autonomousLevel:156To reset everything and fly with controller:set_autonomousLevel:0\n\n\n\n\n\n\n32\n\n\nset_angularWalkVariance:\n\n\nsetAngularWalkVariance(\n)\n\n\nFloat\n\n\nSets the Kalman Filter parameter that determines how fast the gyro bias estimates converge.\n\n\n\n\n\n\n33\n\n\nSet_gyroVariance:\n\n\nsetGyroVariance(\n)\n\n\nFloat\n\n\nSets the Kalman filter parameter that determines the weighting of the gryo in the attitude estimates of the plane.\n\n\n\n\n\n\n34\n\n\nset_magneticVariance:\n\n\nsetMagneticVariance(\n)\n\n\nFloat\n\n\nSets the Kalman filter parameter that determines the weighting of the magnetometers in the attitude estimates of the plane.\n\n\n\n\n\n\n35\n\n\nset_accelVariance:\n\n\nsetAccelVariance(\n)\n\n\nFloat\n\n\nSets the Kalman filter parameter that determines the weighting of the accelerometers in the attitude estimates of the plane.\n\n\n\n\n\n\n36\n\n\nset_scaleFactor:\n\n\npitchScaleFactor = \n\n\nFloat\n\n\nSets the value for the feed-forward term of pitch, when the aircraft is turning. In other words, when the aircraft is turning, this proportion is added to the elevators to prevent the airplane from losing altitude.\n\n\n\n\n\n\n37\n\n\ncalibrate_altimeter:\n\n\namData.calibrationHeight = \namData.command = PM_CALIBRATE_ALTIMETER\n\n\nFloat\n\n\nThis sets the reference height on the altimeter to a predefined value. This allows one to choose a \nrelative\n value for the height aircraft. For example, one may set 0m to refer to the starting or landing terrain height.\n\n\n\n\n\n\n38\n\n\nclear_waypoints:\n\n\namData.waypoint.id = \namData.command = PM_CLEAR_WAYPOINTS\n\n\nByte\n\n\nThis command clears ALL waypoints. The \n is just a dummy variable.\n\n\n\n\n\n\n39\n\n\nremove_waypoint:\n\n\namData.waypoint.id = \namData.command = PM_REMOVE_WAYPOINT\n\n\nByte\n\n\nThis command removes a specific waypoint given a specific ID as the parameter.\n\n\n\n\n\n\n40\n\n\nset_targetWaypoint:\n\n\namData.waypoint.id = \namData.command = PM_SET_TARGET_WAYPOINT\n\n\nByte\n\n\nThe target waypoint is the waypoint which the UAV is trying to currently get to. If this command is called, it can be used to skip waypoints, or return to waypoints. The \n is the specified ID for the new target.\n\n\n\n\n\n\n41\n\n\nreturn_home:\n\n\namData.command = PM_RETURN_HOME\n\n\nByte\n\n\nThis tells the plane to go to the \"home\" coordinates. The \n is just a dummy variable.\n\n\n\n\n\n\n42\n\n\ncancel_returnHome:\n\n\namData.command = PM_CANCEL_RETURN_HOME\n\n\nByte\n\n\nThis tells the plane to return back to its original path after being called to the \"home\" coordinates.\n\n\n\n\n\n\n43\n\n\nsend_heartbeat:\n\n\nheartbeatTimer = time\n\n\nByte\n\n\nThis sends a \"heartbeat\" (verification ping) to the plane to tell it that a data connection is still present. If this command is not received after a certain amount of time, emergency maneuvers will be used.\n\n\n\n\n\n\n44\n\n\ntrigger_camera:\n\n\ntriggerCamera(\n)\n\n\nInt\n\n\nThis manually triggers the camera via a \"fake\" PWM signal. The \n is the integer value of the PWM signal.\n\n\n\n\n\n\n45\n\n\nset_triggerDistance:\n\n\nsetTriggerDistance(\n)\n\n\nFloat\n\n\nThis sets the trigger distance (how often a picture is taken based on distance). This \n is a value in meters.\n\n\n\n\n\n\n46\n\n\nset_gimbleOffset:\n\n\nsetGimbleOffset(\n)\n\n\nInt\n\n\nThis provides an offset to the gimbal. If the gimbal is misaligned on start up, this function can correct it.\n\n\n\n\n\n\n47\n\n\nkill_plane:\n\n\nif (\n == 1234)                    killingPlane = 1;\n\n\nInt\n\n\nThis crashes the plane into the ground (in emergencies). This requires a password (\n = \"1234\") to ensure this isn't an accident.\n\n\n\n\n\n\n48\n\n\nunkill_plane:\n\n\nif (\n == 1234)                    killingPlane = 0;\n\n\nInt\n\n\nThis changes the state of the plane from \"I'm crashing\" to \"Nevermind, this was just a test\". This requires a password (\n = \"1234\") to ensure this isn't an accident.\n\n\n\n\n\n\n128\n\n\nnew_waypoint:\n,\n,\n,\n\n\namData.command = PM_NEW_WAYPOINTamData.waypoint = \n\n\n4 floats\n\n\nThis uploads and appends a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius).\n\n\n\n\n\n\n129\n\n\ninsert_Waypoint:\n\n\namData.command = PM_INSERT_WAYPOINT amData.waypoint = \n\n\n4 floats followed by 2 Bytes\n\n\nThis uploads and inserts a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius,nextID,previousID).\n\n\n\n\n\n\n130\n\n\nset_ReturnHomeCoordinates:\n\n\namData.command = PM_SET_RETURN_HOME_COORDINATESamData.waypoint = \n\n\n3 Floats\n\n\nThis sets the home coordinates, to which the plane will return in case of an emergency. The format is (longitude, latitude, altitude).\n\n\n\n\n\n\n131\n\n\ntare_IMU:\n,\n,\n\n\nadjustVNOrientationMatrix(float* adjustment);\n\n\n3 Floats\n\n\nThis adds a bias adjustment to the matrix based on the last setting. The 3 data values are the x,y,z components of the aircraft.\n\n\n\n\n\n\n132\n\n\nSet_IMU:\n,\n,\n\n\nsetVNOrientationMatrix(float* adjustment);\n\n\n3 Floats\n\n\nThis is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.\n\n\n\n\n\n\n\n\nIn the code\n\n\nPrior to usage, the datalink must be initialized.  This is done so in \nmain.c _using _initDataLink()\n. This simply initializes the UART2 interface (see UART section) for appropriate usage with the datalink.\n\n\nAfter initialization, the data link can be used. The interface used to queue data to the datalink is present in the AttitudeManager.c file.\n\n\nIn the code \u2013 Downlink/Telemetry\n\n\nData is exported to the data link at a certain frequency (according to a clock). This is done by calling \nwriteDatalink(frequency)\n, where frequency is the time between packets. This subroutine creates a structure (defined in \nnet.h\n) which contains memory locations for every variable. This data is then pushed to be processed in \nnet_outbound.c\n.\n\n\nif (time - lastTime \n frequency) {\n\n    lastTime = time;\n\n    struct telem_block* statusData = createTelemetryBlock();\n\n    statusData-\nlat = gps_Latitude;\n\n    statusData-\nlon = gps_Longitude;\n\n    ...\n\nreturn pushOutboundTelemetryQueue(statusData);\n\n}\n\n\n\nWhen all the data is assembled in the struct, \npushOutboundTelemetryQueue(statusData)\n is called. This pushes the data onto a queue to be processed later:\n\n\nint pushOutboundTelemetryQueue(struct telem_block *telem) {\n\n    if (getOutboundQueueLength() \n= OUTBOUND_QUEUE_SIZE) {\n\n        return -1;\n\n    }\n\n    outBuffer[outbuff_end] = telem;\n\n    outbuff_end++;\n\n    outbuff_end = outbuff_end % OUTBOUND_QUEUE_SIZE;\n\n    return getOutboundQueueLength();\n\n}\n\n\n\nNote that this is a circular buffer. When the buffer reaches the OUTBOUND_QUEUE_SIZE, the outbuff_end variable starts from 0 and overwrites the old data.\n\n\nEvery once in a while, the data accumulated must be processed. As a result, every iteration of the program runs a subroutine to maintain and cleanup the circular buffer. For the outgoing buffer, this method is \noutboundBufferMaintenance()\n:\n\n\nif ( stagingBuffer.sendIndex \n= PACKET_LENGTH ) {\n\n    destroyTelemetryBlock(stagingBuffer.telemetry.asStruct);\n\n    if ( getOutboundQueueLength() ) {\n\n        stageTelemetryBlock(popOutboundTelemetryQueue());\n\n    }\n\n} else if ( stagingBuffer.telemetry.asStruct == 0 \n getOutboundQueueLength() ) {\n\n    stageTelemetryBlock(popOutboundTelemetryQueue());\n\n}\n\n\n\nNote that the structure of \nstagingBuffer\n is as follows:\n\n\nstruct telem_buffer {\n\n    unsigned int sendIndex;             // index into telemetry to send\n\n    unsigned char header[API_HEADER_LENGTH];    // The header for the telem\n\n    union {\n\n        struct telem_block *asStruct;   // The telemetry block being sent\n\n        unsigned char *asArray;         // The telemetry intepreted as an array\n\n    } telemetry;\n\n    unsigned char checksum;             // The checksum so far\n\n};\n\n\n\nNote that the \nstagingBuffer _converts the data into a data link friendly format. The data link hardware requires that each data packet must be sent with a header, the data, and a checksum (For more specification see the XBEE section). These are 3 components of the _telem_buffer\n structure. The 4th component is the \nsendIndex\n variable. This value is used to keep track (index) what data has already been sent or still needs to be sent.\n\n\nAfter sufficient error checking (making sure \nsendIndex\n is less than the allowed packet size), stageTelemetryBlock(popOutboundTelemetryQueue()) is called. This method takes (pops) the next struct of data and stages it to be sent. \nstageTelemetryBlock()\n is responsible for converting the telemetry data into a \ntelem_buffer\n structure.\n\n\nvoid stageTelemetryBlock(struct telem_block *telem) {\n\n    stagingBuffer.telemetry.asStruct = telem;\n\n    generateApiHeader(stagingBuffer.header, 0);\n\n    stagingBuffer.checksum = 0;\n\n    // Send index should be reset last for reasons\n\n    stagingBuffer.sendIndex = 0;\n\n    sendNextByte();\n\n}\n\n\n\nThe first line of the subroutine adds the data into the packet. The second line (\ngenerateApiHeader(stagingBuffer.header,0))\n creates an appropriate header in the \nstagingBuffer.header\n memory address with a data frame of 0. (See the XBEE section for the datasheet). The API header includes information involving which device the packet should be sent to, the length of the packet, as well as acknowledgement options, and packet types (data packet, configuration packet, status packet). After the \nchecksum\n and \nsendIndex\n are explicitly reset, the sending process begins with \nsendNextByte()\n:\n\n\nvoid sendNextByte(void) {\n\n    unsigned char sendByte; // The byte to send\n\n    if ( stagingBuffer.sendIndex \n API_HEADER_LENGTH ) {\n\n        //while (U2STAbits.TRMT == 0);\n\n        sendByte = stagingBuffer.header[stagingBuffer.sendIndex] \n 0xFF;\n\n        // Compute checksum\n\n        if (stagingBuffer.sendIndex \n= 3) {\n\n            stagingBuffer.checksum += sendByte \n 0xFF;\n\n        }\n\n    } else if ( stagingBuffer.sendIndex \n PACKET_LENGTH - 1 ) {\n\n        sendByte = stagingBuffer.telemetry.asArray[stagingBuffer.sendIndex - API_HEADER_LENGTH] \n 0xFF;\n\n        stagingBuffer.checksum += sendByte \n 0xFF;\n\n    } else if ( stagingBuffer.sendIndex == PACKET_LENGTH - 1) {\n\n        sendByte = 0xFF - (stagingBuffer.checksum \n 0xFF);\n\n    } else {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    stagingBuffer.sendIndex++;\n\n    IFS1bits.U2TXIF = 0;\n\n    U2TXREG = sendByte;\n\n}\n\n\n\nAll the \"\nif\n\" statements above, compile the header, the data and the checksum together. Note that the checksum is the bitwise inverse of the actual sum: sendByte = 0xFF - (stagingBuffer.checksum \n 0xFF). The most important part of this process is the last line, where each byte is sent to the UART transmit buffer. Since the UART transmit process is interrupt-based, each interrupt keeps calling \nsendNextByte()\n, until there is no more data left:\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {\n\n    // Short circuit if nothing in the staging area yet\n\n    if ( stagingBuffer.telemetry.asStruct == 0 ) {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    sendNextByte();\n\n}\n\n\n\nThe process can be described through this flowchart:\n\n\n\n\nIn the code \u2013 Uplink\n\n\nOnce every iteration, a command is read from the uplink queue. This is done by calling readDatalink(). The command \npopCommand()\n is called. If any new commands have been received, \npopCommand()\n will return a \ncommand\n struct (defined in \nnet.h\n):\n\n\nstruct command {\n\n    unsigned char cmd;\n\n    unsigned char data\\_length;\n\n    unsigned char data[101];\n\n};\n\n\n\nIt is fairly straight forward. The structure contains a \ncmd.cmd _which indicates the command ID. This ID corresponds to a certain function that needs to be completed. Following the pop command are a series of case statements (one for each command ID). For instance, if the command ID is 30, the following command is run (in _net_inbound.c\n):\n\n\nstruct command* cmd = popCommand();\n\n//TODO: Add rudimentary input validation\n\nif ( cmd ) {\n\n    if (lastCommandSentCode == cmd-\ncmd){\n\n        lastCommandSentCode++;\n\n    }\n\n    else{\n\n        lastCommandSentCode = cmd-\ncmd * 100;\n\n    }\n\n    switch (cmd-\ncmd) {\n\n        ...\n\n        case SET_THROTTLE:\n\n            sp_ThrottleRate = (int)(*(int*)(\ncmd-\ndata) / 100.0  * (890 - 454) + 454);\n\n            break;\n\n        ...\n    }\n\n}\n\n\n\nThe throttle ends up being set to the value indicated in the \ncmd.data\n location. In addition, the last command read is stored and sent to the ground station as verification that the command was received.\n\n\nThe \npopCommand() _function waits and reads the next available command from a circular buffer (note the _INBOUND_QUEUE_SIZE\n variable). If the command doesn't exist, it exits the function.\n\n\nIn order for the command structure to exist, the \nU2RXInterrupt\n must have been triggered. This occurs when new data is sent.\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {\n\n    unsigned char data = U2RXREG;\n\n    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        IFS1bits.U2RXIF = 0;\n\n        return;\n\n    }\n\n    switch ( payloadPos ) {\n\n        case 0:\n\n            if ( data != START_DELIMITER ) {\n\n                IFS1bits.U2RXIF = 0;\n\n                return;\n\n            }\n\n            break;\n\n        case 1:\n\n            if ( data != 0 ) {\n\n                payloadPos = 0;\n\n                IFS1bits.U2RXIF = 0;\n\n                return;                 // packet length \n 100 bytes, so msb == 0\n\n            }\n\n            break;\n\n        case 2:\n\n            payloadLength[packetPos] = data;\n\n            break;\n\n        default:        // Normally, don't do anything special\n\n            break;\n\n    }\n\n    rawPackets[packetPos][payloadPos++] = data;\n\n    if ( payloadPos \n payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet\n\n        rawPacketStatus[packetPos] = READY;\n\n        payloadPos = 0;\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        if ( rawPacketStatus[packetPos] == EMPTY ) {\n\n            rawPacketStatus[packetPos] = BUSY;\n\n        }\n\n    }\n\n    IFS1bits.U2RXIF = 0;\n\n}\n\n\n\nThe first thing that occurs when new data arrives is a check to see if there is enough memory to store the data. A \nif statement\n is used to check if the buffer (rawPacketStatus) is busy or not.  Note that the interrupt will only record the data, if the current \npacketPos\n marked busy.\n\n\nIf the buffer is full, the next buffer location is checked. Otherwise, the packet is parsed byte by byte.\n\n\nFirstly, the start delimiter is looked for using a case statement. Until the start delimiter is found, nothing happens. Secondly, for case 1 and 2, the length of the packet is check and recorded. Once the length of the packet is known, the \ndata\n is read into a 2d array called \nrawPackets\n. This array contains each byte of every packet in the circular buffer. Once all the data is copied into the array, the packet is marked as \nREADY\n, and the next one is marked \nBUSY\n if it is \nEMPTY\n, and the processing of the data begins on the next maintenance cycle when \ninboundBufferMaintenance()\n is called from \nmain.c\n:\n\n\nvoid inboundBufferMaintenance(void) {\n\n    int i;\n\n    for ( i = 0; i \n RAW_PACKET_BUFFER_SIZE; i++ ) {\n\n        if ( rawPacketStatus[i] == READY \n checkPacket(rawPackets[i]) ) {\n\n            struct command\\* cmd = createCommand( rawPackets[i] );\n\n            if ( cmd ) {            // create command was successful ?\n\n                pushCommand( cmd ); // queue it up\n\n                rawPacketStatus[i] = EMPTY;         // buffer is now good for writing another packet\n\n            }\n\n        }\n\n    }\n\n    if ( rawPacketStatus[0] == EMPTY ) {\n\n        rawPacketStatus[0] = BUSY;\n\n    }\n\n}\n\n\n\nThis subroutine iterates through each buffer location and checks for any \nREADY\n packets. If one is found, and it has been verified through a checksum, the command structure is created from the data using the \ncreateCommand(rawPackets[i])\n method. Once this is done, the previous spot is marked \nEMPTY\n. The first buffer is always primed if it is empty.", 
            "title": "Datalink"
        }, 
        {
            "location": "/picpilot/datalink/#datalink", 
            "text": "The datalink is one of the most important peripheral components in an unmanned system. It provides information on the status of the aircraft (telemetry) and provides the crucial functionality of an uplink, in order to be able to communicate with the system and make changes to its overall functionality.  Make note that the details of this system can change frequently due to the requirements of each user. The telemetry data may change from the ones present in this document. Likewise, uplink commands may change based on newly implemented features and requirements. Although, this document should be updated whenever there is a change, this may not always occur. Therefore, be careful when referencing data in this section.", 
            "title": "Datalink"
        }, 
        {
            "location": "/picpilot/datalink/#telemetry-downlink-data", 
            "text": "Data  Programming Variable  Format  Description      Latitude  Lat  Long double (64bit floating point)  The latitude location of the airplane in degrees.    Longitude  Lon  Long double (64bit floating point)  The longitude location of the airplane in degrees.    Time  Time  Float (32 bit floating point)  The time as a UTC time stamp.    Pitch  Pitch  Float  The current state estimation of the pitch of the aircraft in degrees.    Roll  Roll  Float  The current state estimation of the roll of the aircraft in degrees.    Yaw  Yaw  Float  The current state estimation of the yaw of the aircraft according to the magnetometer in degrees.    Pitch Rate  Pitch_rate  Float  The gyroscope sensor data. The rate of rotation of the aircraft in radians per second.    Roll Rate  Roll_rate  Float  The gyroscope sensor data. The rate of rotation of the aircraft in radians per second.    Yaw Rate  Yaw_rate  Float  The gyroscope sensor data. The rate of rotation of the aircraft in radians per second.    Derivative Gain  Kd_gain  Float  A predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.    Proportional Gain  Kp_gain  Float  A predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.    Integral Gain  Ki_gain  Float  A predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.    Heading  Heading  Float  The GPS heading of the aircraft in degrees ranging from 0 to 360.    Ground Speed  Ground_speed  Float  The ground speed of the aircraft in meters per second.    Pitch Setpoint  Pitch_setpoint  Float  The autopilot-controlled setpoint for the pitch angle in degrees.    Roll Setpoint  Roll_setpoint  Float  The autopilot-controlled setpoint for the Roll angle in degrees.    Heading Setpoint  heading_setpoint  Float  The autopilot-controlled setpoint for the heading angle in degrees.    Throttle Setpoint  Throttle_setpoint  Float  The autopilot-controlled setpoint for the propeller speed in terms of percentage (0-100%)    Altitude Setpoint  altitude_setpoint  Float  The autopilot-controlled setpoint for the altitude above mean sea level. (in meters)    Altitude  altitude  Float  The altitude of the plane above the mean sea level (in meters)    Pitch Setpoint (Controller)  int_pitch_setpoint  Float  The user input for the Pitch angle in arbitrary timer tick units.    Roll Setpoint(Controller)  int_roll_setpoint  Float  The user input for the Roll angle in arbitrary timer tick units.    Yaw Setpoint (Controller)  int_yaw_setpoint  Float  The user input for the yaw angle in arbitrary timer tick units.    Last Wireless Command Sent Received  lastCommandSent  int  This is a combination of the command number (commands.h) multiplied by 100. For every subsequent call, the number is incremented by 1.For example, if the return home command was called 5 times, this variable would be equal to:  4105    Error Codes  errorCodes  Unsigned int  Signals any problems that may be occurring or have occurred.This value is retrieved from StartupErrorCodes.c. The possible values are (and any binary combination):0b0000000000000000: No Errors0b0000000000000001:Power on reset occurred.0b0000000000000010:Brown out reset occurred.0b0000000000000100:Idle Mode Reset Occurred.0b0000000000001000:Sleep Mode Reset Occurred.0b0000000000010000:Software Watch Dog Timer Reset Occurred.0b0000000000100000:Software Reset Occurred.0b0000000001000000:External Reset Occurred.0b0000000010000000:Voltage Regulator Reset Occurred.0b0000000100000000:Illegal Opcode Reset Occurred.0b0000001000000000:Trap Reset Occurred.0b1000000000000000:UHF Switch is ON (Can be used to indicate joystick controller connection)    Camera Counter  cameraCounter  Unsigned Int  Every time the camera is triggered, this value increases by one. This allows one to keep track which picture corresponds to what data.    Waypoint Index  waypointIndex  Char  Indicates what waypoint the vehicle is attempting to get to.-1 - indicates that the vehicle is going \"HOME\"Any other value indicates the waypoint in the order that it was added.    Controller Status Indicator  Editing_gain  Char  An indicator that depicts which gain values are currently being changed.0x00 = Manual Mode0x01 = Yaw0x02 = Pitch0x03 = Roll0x04 = Heading0x05 = Altitude0x06 = Throttle    GPS Status Indicator  Gps_status  Char  An indicator that depicts the number of satellites connected, as well as the status of the gps fix. Format:0x  For example:0x00 = No GPS Fix, 0 Satellites0x1A = GPS Fix, 10 Satellites0x24 = DGPS Fix, 4 Satellites    Battery Level Indicator  batteryLevel  Char  This indicator provides the battery level as a percentage (%) of the original battery capacity specified in the voltageSensor.c/h files.     Note that all telemetry data must be visible within the scope of the AttitudeManager.c file.", 
            "title": "Telemetry (Downlink) Data"
        }, 
        {
            "location": "/picpilot/datalink/#command-uplink-data", 
            "text": "Every command that is sent to the UAV must be predefined with an ID, as well as an associated function. Some commands only change variable values, whereas some call functions with the associated data as a parameter.     Command ID  Socket Command  Associated Function  Format  Description      0  debug:  UART1_SendString( )  Char Array  The debugging command, which writes to the UART1 port.    1  set_pitchKDGain:  setGain(PITCH, KD_GAIN,  )  Float  The command to set the derivative gain for pitch control.    2  set_rollKDGain:  setGain(ROLL, KD_GAIN,  )  Float  The command to set the derivative gain for roll control.    3  set_yawKDGain:  setGain(YAW, KD_GAIN,  )  Float  The command to set the derivative gain for yaw control.    4  set_pitchKPGain:  setGain(PITCH, KP_GAIN,  )  Float  The command to set the proportional gain for pitch control.    5  set_rollKPGain:  setGain(ROLL, KP_GAIN,  )  Float  The command to set the proportional gain for roll control.    6  set_yawKPGain:  setGain(YAW, KP_GAIN,  )  Float  The command to set the proportional gain for yaw control.    7  set_pitchKIGain:  setGain(PITCH, KI_GAIN,  )  Float  The command to set the integral gain for pitch control.    8  set_rollKIGain:  setGain(ROLL, KI_GAIN,  )  Float  The command to set the proportional gain for roll control.    9  set_yawKIGain:  setGain(YAW, KI_GAIN,  )  Float  The command to set the proportional gain for yaw control.    10  set_headingKDGain:  setGain(HEADING, KD_GAIN,  )  Float  The command to set the derivative gain for heading control.    11  set_headingKPGain:  setGain(HEADING, KP_GAIN,  )  Float  The command to set the proportional gain for heading control.    12  set_headingKIGain:  setGain(HEADING, KI_GAIN,  )  Float  The command to set the integral gain for heading control.    13  set_altitudeKDGain:  setGain(ALTITUDE, KD_GAIN,  )  Float  The command to set the derivative gain for altitude control.    14  set_altitudeKPGain:  setGain(ALTITUDE, KP_GAIN,  )  Float  The command to set the proportional gain for altitude control.    15  set_altitudeKIGain:  setGain(ALTITUDE, KI_GAIN,  )  Float  The command to set the integral gain for altitude control.    16  set_throttleKDGain:  setGain(THROTTLE, KD_GAIN,  )  Float  The command to set the derivative gain for throttle control (speed).    17  set_throttleKPGain:  setGain(THROTTLE, KP_GAIN,  )  Float  The command to set the derivative gain for throttle control (speed).    18  set_throttleKIGain:  setGain(THROTTLE, KI_GAIN,  )  Float  The command to set the integral gain for throttle control (speed).    19  set_pathGain:  Currently Unsupported, but will not cause errors if set  Float  The command used to set the gain that scales lateral positional control around a path.    20  set_orbitGain:  Currently Unsupported, but will not cause errors if set  Float  The command used to set the gain that scales orbital convergence.    21  set_showGain:  displayGain =   Char  The command used to switch the output between multiple gain types:0x00 = Yaw0x01 = Pitch0x02 = Roll0x03 = Heading0x04 = Altitude0x05 = Throttle*Note that there is no support for the path gain or orbital gain yet.    22  set_pitchRate:  sp_PitchRate =   Int  The user input for the pitch rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]). Note you must set command 32 greater than 4 to use this.    23  set_rollRate:  sp_RollRate =   Int  The user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.    24  set_yawRate:  sp_YawRate =   Int  The user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.    25  set_pitchAngle:  sp_PitchAngle =   Float  The user input for the pitch angle in degrees. Note you must set command 32 greater than 5 to use this.    26  set_rollAngle:  sp_RollAngle =   Float  The user input for the roll angle in degrees. Note you must set command 32 greater than 5 to use this.    27  set_yawAngle:  Currently Unsupported, but will not cause errors if set  Float  The user input for the yaw angle in degrees. WILL LIKELY BE REMOVED IN THE FUTURE IF UNEEDED. Note you must set command 32 greater than 5 to use this.    28  set_altitude:  sp_Altitude =   Float  The user input for the altitude in meters above sea level. Note you must set command 32 greater than 6 to use this.    29  set_heading:  sp_Heading =   Float  The user input for the heading in standard compass bearing degrees. Note you must set command 32 greater than 7 to use this.    30  set_throttle:  sp_Throttle =   Int  The user input for the throttle as a percentage. Note you must set command 32 to 8 to use this.    31  set_autonomousLevel:  controlLevel =   Int  This sets the source of control input between the autopilot, the remote control, and the ground stations:0b00000000 = Full manual control (default)0b00000001 = Set Pitch Rate(0), Pitch Angle(1)0b00000010 = Pitch Control Source: Controller(0), Ground Station(1) 0b00000100 = Roll Control Type: Roll Rate(0), Roll Angle(1)0b00001000 = Roll Control Sources: Controller(0), Ground Station(1)0b00110000 = Throttle control source: Controller(0), Ground Station(1), Autopilot(2) 0b01000000 = Altitude Source: Ground Station(0), Autopilot(1)0b10000000 = Altitude Control On(1) or Off(0)0b100000000 = Heading control source: Ground Station(0), Autopilot(1)0b1000000000=  To fly with Ground Station Control of the Pitch Rate and Roll Angle:set_autonomousLevel:14To fly with Ground Station Control of the Pitch Rate, Roll Angle, and Throttle:set_autonomousLevel:30To fly with Ground Station Control of Altitude, and Throttle (Roll controlled by controller):set_autonomousLevel:134To fly with Ground Station Control of Altitude, Throttle, Roll Angle:set_autonomousLevel:156To reset everything and fly with controller:set_autonomousLevel:0    32  set_angularWalkVariance:  setAngularWalkVariance( )  Float  Sets the Kalman Filter parameter that determines how fast the gyro bias estimates converge.    33  Set_gyroVariance:  setGyroVariance( )  Float  Sets the Kalman filter parameter that determines the weighting of the gryo in the attitude estimates of the plane.    34  set_magneticVariance:  setMagneticVariance( )  Float  Sets the Kalman filter parameter that determines the weighting of the magnetometers in the attitude estimates of the plane.    35  set_accelVariance:  setAccelVariance( )  Float  Sets the Kalman filter parameter that determines the weighting of the accelerometers in the attitude estimates of the plane.    36  set_scaleFactor:  pitchScaleFactor =   Float  Sets the value for the feed-forward term of pitch, when the aircraft is turning. In other words, when the aircraft is turning, this proportion is added to the elevators to prevent the airplane from losing altitude.    37  calibrate_altimeter:  amData.calibrationHeight =  amData.command = PM_CALIBRATE_ALTIMETER  Float  This sets the reference height on the altimeter to a predefined value. This allows one to choose a  relative  value for the height aircraft. For example, one may set 0m to refer to the starting or landing terrain height.    38  clear_waypoints:  amData.waypoint.id =  amData.command = PM_CLEAR_WAYPOINTS  Byte  This command clears ALL waypoints. The   is just a dummy variable.    39  remove_waypoint:  amData.waypoint.id =  amData.command = PM_REMOVE_WAYPOINT  Byte  This command removes a specific waypoint given a specific ID as the parameter.    40  set_targetWaypoint:  amData.waypoint.id =  amData.command = PM_SET_TARGET_WAYPOINT  Byte  The target waypoint is the waypoint which the UAV is trying to currently get to. If this command is called, it can be used to skip waypoints, or return to waypoints. The   is the specified ID for the new target.    41  return_home:  amData.command = PM_RETURN_HOME  Byte  This tells the plane to go to the \"home\" coordinates. The   is just a dummy variable.    42  cancel_returnHome:  amData.command = PM_CANCEL_RETURN_HOME  Byte  This tells the plane to return back to its original path after being called to the \"home\" coordinates.    43  send_heartbeat:  heartbeatTimer = time  Byte  This sends a \"heartbeat\" (verification ping) to the plane to tell it that a data connection is still present. If this command is not received after a certain amount of time, emergency maneuvers will be used.    44  trigger_camera:  triggerCamera( )  Int  This manually triggers the camera via a \"fake\" PWM signal. The   is the integer value of the PWM signal.    45  set_triggerDistance:  setTriggerDistance( )  Float  This sets the trigger distance (how often a picture is taken based on distance). This   is a value in meters.    46  set_gimbleOffset:  setGimbleOffset( )  Int  This provides an offset to the gimbal. If the gimbal is misaligned on start up, this function can correct it.    47  kill_plane:  if (  == 1234)                    killingPlane = 1;  Int  This crashes the plane into the ground (in emergencies). This requires a password (  = \"1234\") to ensure this isn't an accident.    48  unkill_plane:  if (  == 1234)                    killingPlane = 0;  Int  This changes the state of the plane from \"I'm crashing\" to \"Nevermind, this was just a test\". This requires a password (  = \"1234\") to ensure this isn't an accident.    128  new_waypoint: , , ,  amData.command = PM_NEW_WAYPOINTamData.waypoint =   4 floats  This uploads and appends a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius).    129  insert_Waypoint:  amData.command = PM_INSERT_WAYPOINT amData.waypoint =   4 floats followed by 2 Bytes  This uploads and inserts a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius,nextID,previousID).    130  set_ReturnHomeCoordinates:  amData.command = PM_SET_RETURN_HOME_COORDINATESamData.waypoint =   3 Floats  This sets the home coordinates, to which the plane will return in case of an emergency. The format is (longitude, latitude, altitude).    131  tare_IMU: , ,  adjustVNOrientationMatrix(float* adjustment);  3 Floats  This adds a bias adjustment to the matrix based on the last setting. The 3 data values are the x,y,z components of the aircraft.    132  Set_IMU: , ,  setVNOrientationMatrix(float* adjustment);  3 Floats  This is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.", 
            "title": "Command (Uplink) Data"
        }, 
        {
            "location": "/picpilot/datalink/#in-the-code", 
            "text": "Prior to usage, the datalink must be initialized.  This is done so in  main.c _using _initDataLink() . This simply initializes the UART2 interface (see UART section) for appropriate usage with the datalink.  After initialization, the data link can be used. The interface used to queue data to the datalink is present in the AttitudeManager.c file.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/datalink/#in-the-code-downlinktelemetry", 
            "text": "Data is exported to the data link at a certain frequency (according to a clock). This is done by calling  writeDatalink(frequency) , where frequency is the time between packets. This subroutine creates a structure (defined in  net.h ) which contains memory locations for every variable. This data is then pushed to be processed in  net_outbound.c .  if (time - lastTime   frequency) {\n\n    lastTime = time;\n\n    struct telem_block* statusData = createTelemetryBlock();\n\n    statusData- lat = gps_Latitude;\n\n    statusData- lon = gps_Longitude;\n\n    ...\n\nreturn pushOutboundTelemetryQueue(statusData);\n\n}  When all the data is assembled in the struct,  pushOutboundTelemetryQueue(statusData)  is called. This pushes the data onto a queue to be processed later:  int pushOutboundTelemetryQueue(struct telem_block *telem) {\n\n    if (getOutboundQueueLength()  = OUTBOUND_QUEUE_SIZE) {\n\n        return -1;\n\n    }\n\n    outBuffer[outbuff_end] = telem;\n\n    outbuff_end++;\n\n    outbuff_end = outbuff_end % OUTBOUND_QUEUE_SIZE;\n\n    return getOutboundQueueLength();\n\n}  Note that this is a circular buffer. When the buffer reaches the OUTBOUND_QUEUE_SIZE, the outbuff_end variable starts from 0 and overwrites the old data.  Every once in a while, the data accumulated must be processed. As a result, every iteration of the program runs a subroutine to maintain and cleanup the circular buffer. For the outgoing buffer, this method is  outboundBufferMaintenance() :  if ( stagingBuffer.sendIndex  = PACKET_LENGTH ) {\n\n    destroyTelemetryBlock(stagingBuffer.telemetry.asStruct);\n\n    if ( getOutboundQueueLength() ) {\n\n        stageTelemetryBlock(popOutboundTelemetryQueue());\n\n    }\n\n} else if ( stagingBuffer.telemetry.asStruct == 0   getOutboundQueueLength() ) {\n\n    stageTelemetryBlock(popOutboundTelemetryQueue());\n\n}  Note that the structure of  stagingBuffer  is as follows:  struct telem_buffer {\n\n    unsigned int sendIndex;             // index into telemetry to send\n\n    unsigned char header[API_HEADER_LENGTH];    // The header for the telem\n\n    union {\n\n        struct telem_block *asStruct;   // The telemetry block being sent\n\n        unsigned char *asArray;         // The telemetry intepreted as an array\n\n    } telemetry;\n\n    unsigned char checksum;             // The checksum so far\n\n};  Note that the  stagingBuffer _converts the data into a data link friendly format. The data link hardware requires that each data packet must be sent with a header, the data, and a checksum (For more specification see the XBEE section). These are 3 components of the _telem_buffer  structure. The 4th component is the  sendIndex  variable. This value is used to keep track (index) what data has already been sent or still needs to be sent.  After sufficient error checking (making sure  sendIndex  is less than the allowed packet size), stageTelemetryBlock(popOutboundTelemetryQueue()) is called. This method takes (pops) the next struct of data and stages it to be sent.  stageTelemetryBlock()  is responsible for converting the telemetry data into a  telem_buffer  structure.  void stageTelemetryBlock(struct telem_block *telem) {\n\n    stagingBuffer.telemetry.asStruct = telem;\n\n    generateApiHeader(stagingBuffer.header, 0);\n\n    stagingBuffer.checksum = 0;\n\n    // Send index should be reset last for reasons\n\n    stagingBuffer.sendIndex = 0;\n\n    sendNextByte();\n\n}  The first line of the subroutine adds the data into the packet. The second line ( generateApiHeader(stagingBuffer.header,0))  creates an appropriate header in the  stagingBuffer.header  memory address with a data frame of 0. (See the XBEE section for the datasheet). The API header includes information involving which device the packet should be sent to, the length of the packet, as well as acknowledgement options, and packet types (data packet, configuration packet, status packet). After the  checksum  and  sendIndex  are explicitly reset, the sending process begins with  sendNextByte() :  void sendNextByte(void) {\n\n    unsigned char sendByte; // The byte to send\n\n    if ( stagingBuffer.sendIndex   API_HEADER_LENGTH ) {\n\n        //while (U2STAbits.TRMT == 0);\n\n        sendByte = stagingBuffer.header[stagingBuffer.sendIndex]   0xFF;\n\n        // Compute checksum\n\n        if (stagingBuffer.sendIndex  = 3) {\n\n            stagingBuffer.checksum += sendByte   0xFF;\n\n        }\n\n    } else if ( stagingBuffer.sendIndex   PACKET_LENGTH - 1 ) {\n\n        sendByte = stagingBuffer.telemetry.asArray[stagingBuffer.sendIndex - API_HEADER_LENGTH]   0xFF;\n\n        stagingBuffer.checksum += sendByte   0xFF;\n\n    } else if ( stagingBuffer.sendIndex == PACKET_LENGTH - 1) {\n\n        sendByte = 0xFF - (stagingBuffer.checksum   0xFF);\n\n    } else {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    stagingBuffer.sendIndex++;\n\n    IFS1bits.U2TXIF = 0;\n\n    U2TXREG = sendByte;\n\n}  All the \" if \" statements above, compile the header, the data and the checksum together. Note that the checksum is the bitwise inverse of the actual sum: sendByte = 0xFF - (stagingBuffer.checksum   0xFF). The most important part of this process is the last line, where each byte is sent to the UART transmit buffer. Since the UART transmit process is interrupt-based, each interrupt keeps calling  sendNextByte() , until there is no more data left:  void __attribute__((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {\n\n    // Short circuit if nothing in the staging area yet\n\n    if ( stagingBuffer.telemetry.asStruct == 0 ) {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    sendNextByte();\n\n}  The process can be described through this flowchart:", 
            "title": "In the code \u2013 Downlink/Telemetry"
        }, 
        {
            "location": "/picpilot/datalink/#in-the-code-uplink", 
            "text": "Once every iteration, a command is read from the uplink queue. This is done by calling readDatalink(). The command  popCommand()  is called. If any new commands have been received,  popCommand()  will return a  command  struct (defined in  net.h ):  struct command {\n\n    unsigned char cmd;\n\n    unsigned char data\\_length;\n\n    unsigned char data[101];\n\n};  It is fairly straight forward. The structure contains a  cmd.cmd _which indicates the command ID. This ID corresponds to a certain function that needs to be completed. Following the pop command are a series of case statements (one for each command ID). For instance, if the command ID is 30, the following command is run (in _net_inbound.c ):  struct command* cmd = popCommand();\n\n//TODO: Add rudimentary input validation\n\nif ( cmd ) {\n\n    if (lastCommandSentCode == cmd- cmd){\n\n        lastCommandSentCode++;\n\n    }\n\n    else{\n\n        lastCommandSentCode = cmd- cmd * 100;\n\n    }\n\n    switch (cmd- cmd) {\n\n        ...\n\n        case SET_THROTTLE:\n\n            sp_ThrottleRate = (int)(*(int*)( cmd- data) / 100.0  * (890 - 454) + 454);\n\n            break;\n\n        ...\n    }\n\n}  The throttle ends up being set to the value indicated in the  cmd.data  location. In addition, the last command read is stored and sent to the ground station as verification that the command was received.  The  popCommand() _function waits and reads the next available command from a circular buffer (note the _INBOUND_QUEUE_SIZE  variable). If the command doesn't exist, it exits the function.  In order for the command structure to exist, the  U2RXInterrupt  must have been triggered. This occurs when new data is sent.  void __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {\n\n    unsigned char data = U2RXREG;\n\n    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        IFS1bits.U2RXIF = 0;\n\n        return;\n\n    }\n\n    switch ( payloadPos ) {\n\n        case 0:\n\n            if ( data != START_DELIMITER ) {\n\n                IFS1bits.U2RXIF = 0;\n\n                return;\n\n            }\n\n            break;\n\n        case 1:\n\n            if ( data != 0 ) {\n\n                payloadPos = 0;\n\n                IFS1bits.U2RXIF = 0;\n\n                return;                 // packet length   100 bytes, so msb == 0\n\n            }\n\n            break;\n\n        case 2:\n\n            payloadLength[packetPos] = data;\n\n            break;\n\n        default:        // Normally, don't do anything special\n\n            break;\n\n    }\n\n    rawPackets[packetPos][payloadPos++] = data;\n\n    if ( payloadPos   payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet\n\n        rawPacketStatus[packetPos] = READY;\n\n        payloadPos = 0;\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        if ( rawPacketStatus[packetPos] == EMPTY ) {\n\n            rawPacketStatus[packetPos] = BUSY;\n\n        }\n\n    }\n\n    IFS1bits.U2RXIF = 0;\n\n}  The first thing that occurs when new data arrives is a check to see if there is enough memory to store the data. A  if statement  is used to check if the buffer (rawPacketStatus) is busy or not.  Note that the interrupt will only record the data, if the current  packetPos  marked busy.  If the buffer is full, the next buffer location is checked. Otherwise, the packet is parsed byte by byte.  Firstly, the start delimiter is looked for using a case statement. Until the start delimiter is found, nothing happens. Secondly, for case 1 and 2, the length of the packet is check and recorded. Once the length of the packet is known, the  data  is read into a 2d array called  rawPackets . This array contains each byte of every packet in the circular buffer. Once all the data is copied into the array, the packet is marked as  READY , and the next one is marked  BUSY  if it is  EMPTY , and the processing of the data begins on the next maintenance cycle when  inboundBufferMaintenance()  is called from  main.c :  void inboundBufferMaintenance(void) {\n\n    int i;\n\n    for ( i = 0; i   RAW_PACKET_BUFFER_SIZE; i++ ) {\n\n        if ( rawPacketStatus[i] == READY   checkPacket(rawPackets[i]) ) {\n\n            struct command\\* cmd = createCommand( rawPackets[i] );\n\n            if ( cmd ) {            // create command was successful ?\n\n                pushCommand( cmd ); // queue it up\n\n                rawPacketStatus[i] = EMPTY;         // buffer is now good for writing another packet\n\n            }\n\n        }\n\n    }\n\n    if ( rawPacketStatus[0] == EMPTY ) {\n\n        rawPacketStatus[0] = BUSY;\n\n    }\n\n}  This subroutine iterates through each buffer location and checks for any  READY  packets. If one is found, and it has been verified through a checksum, the command structure is created from the data using the  createCommand(rawPackets[i])  method. Once this is done, the previous spot is marked  EMPTY . The first buffer is always primed if it is empty.", 
            "title": "In the code \u2013 Uplink"
        }, 
        {
            "location": "/picpilot/analog-to-digital-converter/", 
            "text": "Analog to Digital Converter\n\n\nThe Analog to Digital Converter (ADC) on the PICpilot is used for a single purpose, which to monitor and report the battery life remaining for the vehicle and/or the autopilot. The path managing chip is responsible for measuring the battery voltage. Based on the reference voltage, a percentage is determined which indicates the voltage measured in relationship to the reference voltage. This data is transmitted to the attitude manager chip and then it is transmitted wirelessly along with the telemetry data.\n\n\nThe functionality of the ADC is fairly straightforward. The ADC module switches between two states. One of which is the sampling period, whereas the other is the conversion period. During the conversion period, no sampling is performed. Instead, the previously captured data is converted into a 12 bit number. Therefore, in order to attain the voltage percent, you simply divide the data by 4096, the largest possible 12 bit number.\n\n\nIn the PICpilot, the ADC module is triggered through interrupts (although it can also be manually polled).\n\n\nIn the code\n\n\nAll the code for the voltage sensor is available in the \nvoltageSensor.c\n and \n.h\n files. The code which controls the ADC module is extremely straight forward. The process mostly involves initializations. Most of the \"magic\" is handled automatically by the module, therefore minimal logical coding is required. A few of the important lines have been included below:\n\n\nAD1CON1bits.FORM = 0;                // Data Output Format: Unsigned Int\n\nAD1CON1bits.SSRC = 7;                // Internal Counter (SAMC) ends sampling and starts conversion\n\nAD1CON1bits.AD12B = 1;                // 12-bit single channel operation\n\nAD1CON1bits.SAMP = 1;\n\nAD1CON2bits.SMPI=0;                        // Interrupt address every sample/conversion\n\nAD1CON2bits.CHPS = 0;                //We are using channel 0\n\nAD1CON2bits.VCFG = 0;                 //Voltage Reference is 3.3V and Ground Reference is Ground\n\nAD1CON3bits.SAMC=0;                         // Auto Sample Time = 0\\*Tad\n\nAD1CON3bits.ADCS=6;                        // ADC Conversion Clock Tad=Tcy\\*(ADCS+1)= (1/40M)\\*7 = 175nS\n\n\n\nAD1CHS0bits.CH0SA = 0xC;                 //Channel 0 positive input on AN12 (Sample A)\n\nAD1CHS0bits.CH0SB = 0xC;                 //Channel 0 positive input on AN12 (Sample B)\n\nIFS0bits.AD1IF = 0;                        // Clear the A/D interrupt flag bit\n\nIEC0bits.AD1IE = 1;                        // Enable A/D interrupt\n\nAD1CON1bits.ADON = 1;                // Turn on the A/D converter\n\n\n\nAfter each interrupt, the battery voltage is updated into the \ncurrentSignal\n variable. When the battery voltage is requested, this integer is multiplied by 100 and divided by 4096 to get a percentage (4096 is 12 bits of data).", 
            "title": "Analog to Digital Converter"
        }, 
        {
            "location": "/picpilot/analog-to-digital-converter/#analog-to-digital-converter", 
            "text": "The Analog to Digital Converter (ADC) on the PICpilot is used for a single purpose, which to monitor and report the battery life remaining for the vehicle and/or the autopilot. The path managing chip is responsible for measuring the battery voltage. Based on the reference voltage, a percentage is determined which indicates the voltage measured in relationship to the reference voltage. This data is transmitted to the attitude manager chip and then it is transmitted wirelessly along with the telemetry data.  The functionality of the ADC is fairly straightforward. The ADC module switches between two states. One of which is the sampling period, whereas the other is the conversion period. During the conversion period, no sampling is performed. Instead, the previously captured data is converted into a 12 bit number. Therefore, in order to attain the voltage percent, you simply divide the data by 4096, the largest possible 12 bit number.  In the PICpilot, the ADC module is triggered through interrupts (although it can also be manually polled).", 
            "title": "Analog to Digital Converter"
        }, 
        {
            "location": "/picpilot/analog-to-digital-converter/#in-the-code", 
            "text": "All the code for the voltage sensor is available in the  voltageSensor.c  and  .h  files. The code which controls the ADC module is extremely straight forward. The process mostly involves initializations. Most of the \"magic\" is handled automatically by the module, therefore minimal logical coding is required. A few of the important lines have been included below:  AD1CON1bits.FORM = 0;                // Data Output Format: Unsigned Int\n\nAD1CON1bits.SSRC = 7;                // Internal Counter (SAMC) ends sampling and starts conversion\n\nAD1CON1bits.AD12B = 1;                // 12-bit single channel operation\n\nAD1CON1bits.SAMP = 1;\n\nAD1CON2bits.SMPI=0;                        // Interrupt address every sample/conversion\n\nAD1CON2bits.CHPS = 0;                //We are using channel 0\n\nAD1CON2bits.VCFG = 0;                 //Voltage Reference is 3.3V and Ground Reference is Ground\n\nAD1CON3bits.SAMC=0;                         // Auto Sample Time = 0\\*Tad\n\nAD1CON3bits.ADCS=6;                        // ADC Conversion Clock Tad=Tcy\\*(ADCS+1)= (1/40M)\\*7 = 175nS\n\n\n\nAD1CHS0bits.CH0SA = 0xC;                 //Channel 0 positive input on AN12 (Sample A)\n\nAD1CHS0bits.CH0SB = 0xC;                 //Channel 0 positive input on AN12 (Sample B)\n\nIFS0bits.AD1IF = 0;                        // Clear the A/D interrupt flag bit\n\nIEC0bits.AD1IE = 1;                        // Enable A/D interrupt\n\nAD1CON1bits.ADON = 1;                // Turn on the A/D converter  After each interrupt, the battery voltage is updated into the  currentSignal  variable. When the battery voltage is requested, this integer is multiplied by 100 and divided by 4096 to get a percentage (4096 is 12 bits of data).", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/", 
            "text": "Sensors and Peripherals\n\n\nThere are multiple devices and peripherals currently in use on the PICpilot, however, the purpose of this document is not to document their functionality. Instead, appropriate references are listed below.\n\n\nGPS (MEDIATEK-3329)\n\n\nThis GPS module outputs data in the form of NMEA strings. These are ASCI strings with GPS relevant data embedded in them. A separate program is used to convert these strings to a useable format. The PICpilot expects the data to be in the form of a structure:\n\n\ntypedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;\n\n\n\nLatitude\n and \nLongitude\n should be in degrees.\n\n\nTime\n should be in 24 hour time, with the decimal portion indicating milliseconds.\n\n\nSpeed\n should be in m/s.\n\n\nAltitude\n should be in m.\n\n\nHeading\n should be in degrees (geographical heading, not magnetic).\n\n\nSatellites\n is the number of connected satellites.\n\n\nPositionFix\n is a number representing the accuracy of the data (0 = no data, 1 = GPS functional, 2 = DGPS functional)\n\n\nIn the current PICpilot, GPS updates occur 10 times a second.\n\n\nThe data sheets can be retrieved from here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JQXVOR093anI0YXc/view?usp=sharing\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JR2xTV3dCcGJWczQ/view?usp=sharing\n\n\nIMU (VN-100/VectorNav-100)\n\n\nThe VectorNav-100 has a Kalman filter implemented within it. All the registers and commands that can be executed on the oldest VectorNav are available in four files within the PICpilot code. This includes the VN100.c/.h files, the VN_user.c/.h files, the VN_lib.c/.h, and the VN_math.c/.h files.\n\n\nI GET IT that was 8 files, not four....moving on...\n\n\nYou will find the SPI initialization function in the VN100.c file. It initializes the SPI2 interface.\n\n\nIn the PICpilot, the two most commonly called functions are \nVN100_SPI_GetYPR()\n and \nVN100_SPI_GetRates()\n. These two functions get the rate and angles of rotation along the yaw, pitch, and roll axis of the vehicle.\n\n\nFor a complete list of functions and settings take a look at the documentation:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JYXlSdW85NnlxYkE/view?usp=sharing\n\n\nAltimeter (MPL3115A2)\n\n\nThe complete functionality of the altimeter can be found in the MPL3115A2.c/.h files.\n\n\nThere are only 3 functions implemented in the code. An initialization, calibration, and sensor read function.\n\n\nTo see the complete list of functions provided by the altimeter, as well as further details see the documentation here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JeUE4Y3BhQzVMdkk/view?usp=sharing\n\n\nWireless Link - XBEE PRO S3B\n\n\nThe XBEE PRO S3B is currently the wireless interface used with the PICpilot. Nonetheless, many wireless links can be easily substituted with minimal coding as long as a UART interface is supported.\n\n\nThe PICpilot currently only supports this model currently. This wireless link uses the 900MHz spectrum for communication between devices.\n\n\nAccording to the packet structure specification in the datasheet below, the data is sent or received in that manner.\n\n\nFor details on other functions and feature that are part of the XBEE PRO S3B module download the documentation here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JNzdLWXdCWHlEcGs/view?usp=sharing\n\n\nThe above link also includes details on the packet structure. See page 62 for the Tx packet structure. See page 70 for the Rx packet structure.\n\n\nThe configuration options for the base station can be found here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JTXZESmFEMG9uZEk/view?usp=sharing\n\n\nThe configuration options for the aircraft module can be found here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4Jdml6Wlg5UFZKWEE/view?usp=sharing\n\n\nRC Receiver (EzUHF)\n\n\nThe exact model of the RC Receiver is insignificant to the functionality of the PICpilot. However, the PICpilot has 8 PWM inputs and 8 PWM outputs. Therefore, it would be prudent to have a RC Receiver capable of managing 8 channels.\n\n\nThe current receiver uses the 431-437MHz spectrum.\n\n\nThe documentation can be found here:\n\n\nhttp://www.immersionrc.com/downloads/manuals/EzUHFManual_EN_v1.0.pdf\n\n\nAirspeed Sensor (WIP)\n\n\nThis has not been implemented yet.\n\n\nUltrasonic Sensor (WIP)\n\n\nThis has not been implemented yet.", 
            "title": "Sensors and Peripherals"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#sensors-and-peripherals", 
            "text": "There are multiple devices and peripherals currently in use on the PICpilot, however, the purpose of this document is not to document their functionality. Instead, appropriate references are listed below.", 
            "title": "Sensors and Peripherals"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#gps-mediatek-3329", 
            "text": "This GPS module outputs data in the form of NMEA strings. These are ASCI strings with GPS relevant data embedded in them. A separate program is used to convert these strings to a useable format. The PICpilot expects the data to be in the form of a structure:  typedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;  Latitude  and  Longitude  should be in degrees.  Time  should be in 24 hour time, with the decimal portion indicating milliseconds.  Speed  should be in m/s.  Altitude  should be in m.  Heading  should be in degrees (geographical heading, not magnetic).  Satellites  is the number of connected satellites.  PositionFix  is a number representing the accuracy of the data (0 = no data, 1 = GPS functional, 2 = DGPS functional)  In the current PICpilot, GPS updates occur 10 times a second.  The data sheets can be retrieved from here:  https://drive.google.com/file/d/0BySpWXvmBM4JQXVOR093anI0YXc/view?usp=sharing  https://drive.google.com/file/d/0BySpWXvmBM4JR2xTV3dCcGJWczQ/view?usp=sharing", 
            "title": "GPS (MEDIATEK-3329)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#imu-vn-100vectornav-100", 
            "text": "The VectorNav-100 has a Kalman filter implemented within it. All the registers and commands that can be executed on the oldest VectorNav are available in four files within the PICpilot code. This includes the VN100.c/.h files, the VN_user.c/.h files, the VN_lib.c/.h, and the VN_math.c/.h files.  I GET IT that was 8 files, not four....moving on...  You will find the SPI initialization function in the VN100.c file. It initializes the SPI2 interface.  In the PICpilot, the two most commonly called functions are  VN100_SPI_GetYPR()  and  VN100_SPI_GetRates() . These two functions get the rate and angles of rotation along the yaw, pitch, and roll axis of the vehicle.  For a complete list of functions and settings take a look at the documentation:  https://drive.google.com/file/d/0BySpWXvmBM4JYXlSdW85NnlxYkE/view?usp=sharing", 
            "title": "IMU (VN-100/VectorNav-100)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#altimeter-mpl3115a2", 
            "text": "The complete functionality of the altimeter can be found in the MPL3115A2.c/.h files.  There are only 3 functions implemented in the code. An initialization, calibration, and sensor read function.  To see the complete list of functions provided by the altimeter, as well as further details see the documentation here:  https://drive.google.com/file/d/0BySpWXvmBM4JeUE4Y3BhQzVMdkk/view?usp=sharing", 
            "title": "Altimeter (MPL3115A2)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#wireless-link-xbee-pro-s3b", 
            "text": "The XBEE PRO S3B is currently the wireless interface used with the PICpilot. Nonetheless, many wireless links can be easily substituted with minimal coding as long as a UART interface is supported.  The PICpilot currently only supports this model currently. This wireless link uses the 900MHz spectrum for communication between devices.  According to the packet structure specification in the datasheet below, the data is sent or received in that manner.  For details on other functions and feature that are part of the XBEE PRO S3B module download the documentation here:  https://drive.google.com/file/d/0BySpWXvmBM4JNzdLWXdCWHlEcGs/view?usp=sharing  The above link also includes details on the packet structure. See page 62 for the Tx packet structure. See page 70 for the Rx packet structure.  The configuration options for the base station can be found here:  https://drive.google.com/file/d/0BySpWXvmBM4JTXZESmFEMG9uZEk/view?usp=sharing  The configuration options for the aircraft module can be found here:  https://drive.google.com/file/d/0BySpWXvmBM4Jdml6Wlg5UFZKWEE/view?usp=sharing", 
            "title": "Wireless Link - XBEE PRO S3B"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#rc-receiver-ezuhf", 
            "text": "The exact model of the RC Receiver is insignificant to the functionality of the PICpilot. However, the PICpilot has 8 PWM inputs and 8 PWM outputs. Therefore, it would be prudent to have a RC Receiver capable of managing 8 channels.  The current receiver uses the 431-437MHz spectrum.  The documentation can be found here:  http://www.immersionrc.com/downloads/manuals/EzUHFManual_EN_v1.0.pdf", 
            "title": "RC Receiver (EzUHF)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#airspeed-sensor-wip", 
            "text": "This has not been implemented yet.", 
            "title": "Airspeed Sensor (WIP)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#ultrasonic-sensor-wip", 
            "text": "This has not been implemented yet.", 
            "title": "Ultrasonic Sensor (WIP)"
        }, 
        {
            "location": "/picpilot/attitude-control/", 
            "text": "Attitude Control\n\n\nAttitude Control is very similar regardless of the aircraft which is being used. The end goal is to be able to keep the aircraft stable and in control. The way in which this is achieved is always very similar.\n\n\nIn the PICpilot, we use PID loops to manage our system. Although there are other types of controllers available, PID controllers are the best option due to their reliability, accuracy, and simplicity. The section on PID loops has a detailed explanation of how they work, and how they work together.\n\n\nThis section mostly deals with the \nAttitudeManager.c\n file, as the name implies.\n\n\nThe attitude manager has the 3 main goals, as well as a side task. The 3 main goals include the aggregation of status data (inputs, sensors, etc.), error analysis on the status of the aircraft, and corrections to the aircraft. The side task involves sending all this data to the ground station, as well as receiving from the ground station.\n\n\nInitialization\n\n\nThe initialization process involves beginning communication with all components. The process involves the following steps:\n\n\n\n\nInitializing communication to the Path Manager via SPI and DMA\n\n\nVN 100 is initialized\n\n\nVN 100 is offset according to a rotation matrix\n\n\nVN 100 is then calibrated with confidence parameters for the X/Y/Z magnetometers, accelerometers, and gyroscopes\n\n\nPWM input and output is specified according to the used channels\n\n\n\n\nThis can be found in the \nattitudeInit()\n function in the \nAttitudeManager.c\n file.\n\n\nAggregation of Data\n\n\nUsing the initialized sensors from the prior section, the vehicle can now collect data systematically.\n\n\nEvery loop, new data is acquired from the DMA/SPI interface connected to the Path Manager chip. Data acquired from this chip includes the time, heading, speed, longitude, latitude, altitude, number of satellites, position fix, battery level, waypoint index, set point altitude, and set point heading.\n\n\nNext, data is acquired from the PWM inputs. This includes stick positions, which determine the roll, pitch, yaw, and throttle of the aircraft. These inputs are scaled to values ranging from -1024 to 1024.\n\n\nFinally, the VectorNav is polled for the latest rotational data. The roll, pitch, and yaw rate data is acquired through the \nVN100_SPI_GetRates(0, (float*) \nimuData)\n function call. The roll, pitch, and yaw angles can be determined via the \nVN100_SPI_GetYPR(0, \nimuData[YAW], \nimuData[PITCH], \nimuData[ROLL])\n function call.\n\n\nThis concludes all data acquisition. The next step involves analyzing the error.\n\n\nError Analysis (PID control)\n\n\nPID control works on the basis of minimizing error. The majority of the attitude manager involves consecutive PID loops correcting specific portions of flying an aircraft.\n\n\nAll the PID loop code can be found in the \nOrientationControl.c\n file. It is called from the AttitudeManager.c code.\n\n\nAltitude\n\n\nThe altitude is controlled through a standard PID loop. This can be found in the code:\n\n\n    sp_PitchAngle = controlSignalAltitude(sp_Altitude,(int)gps_Altitude);\n\n    if (sp_PitchAngle \n MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = MAX_PITCH_ANGLE;\n\n    if (sp_PitchAngle \n -MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = -MAX_PITCH_ANGLE;\n\n\n\nLogically, the pitch angle is determined from the desired altitude. If the plane is too low, the pitch angle will be positive (up). If the plane is too high, the pitch angle will be negative (down). The pitch angle is then checked to be within \"safety limits\".\n\n\nThrottle\n\n\nLike the altitude PID loop, the throttle also has PID loop, which is also based on the altitude:\n\n\n    control_Throttle = sp_ThrottleRate + controlSignalThrottle(sp_Altitude, (int)gps_Altitude);\n\n    if (control_Throttle \n MAX_PWM){\n\n        control_Throttle = MAX_PWM;\n\n    }\n\n    else if (control_Throttle \n MIN_PWM){\n\n        control_Throttle = MIN_PWM;\n\n    }\n\n\n\nLogically, if the plane needs to climb, you need to increase the throttle (otherwise it will stall due to low airspeed). Likewise, if the plane needs to reduce its altitude, to prevent high airspeeds, the plane decreases the throttle. If the plane is perfectly positioned, a constant throttle is maintained as per the \nsp_ThrottleRate\n variable. Once again, the throttle is limited within the legal limits of the throttle (to ensure the throttle doesn't become negative or larger than 100%).\n\n\nHeading\n\n\nThe heading control code looks as such:\n\n\n    while (sp_Heading \n 360)\n\n        sp_Heading -=360;\n\n    while (sp_Heading \n 0)\n\n        sp_Heading +=360;\n\n        sp_HeadingRate = controlSignalHeading(sp_Heading, gps_PositionFix==2?gps_Heading:(int)imu_YawAngle);\n\n        //Approximating Roll angle from Heading\n\n        sp_RollAngle = sp_HeadingRate;//(int)(atan((float)(sp_HeadingRate)) * PI/180.0);\n\n    if (sp_RollAngle \n MAX_ROLL_ANGLE)\n\n        sp_RollAngle = MAX_ROLL_ANGLE;\n\n    if (sp_RollAngle \n -MAX_ROLL_ANGLE)\n\n        sp_RollAngle = -MAX_ROLL_ANGLE;\n\n\n\nAs you can see, the input is the heading and the resulting output is a roll angle. In other words, if there is a greater error in the heading, a larger roll angle is established to correct for the heading error.\n\n\nThe first two while loops take into account any angle overflow or underflow, in other words, if the value is above 360 or negative, it is scaled to be between 0 and 360.\n\n\nOnce again the roll value is limited to a reasonable value, to prevent excessive maneuvers.\n\n\nAngles\n\n\nThe code to maintain the angular roll and pitch of the aircraft look as such (one statement for each):\n\n\nsp_ComputedRollRate = controlSignalAngles(sp_RollAngle,  imu_RollAngle, ROLL, -(SP_RANGE) / (MAX_ROLL_ANGLE));\n\n\n\nNote that depending on the on the input angles, the output is a \"rate\". It is an angular rate. In other words, if the difference between the setpoint and the output is large, the angular rate will also be large.\n\n\nAngular Rate\n\n\nThe result from the angular PID loop gives rise to the angular rate PID loop. This loop is often acknowledged as a stabilizing system, where small quick vibrations are accounted for.\n\n\ncontrol_Roll = controlSignal((sp_ComputedRollRate / SERVO_SCALE_FACTOR), imu_RollRate, ROLL);\n\n\n\nThe output of this function completes the PID pipeline. The value of \ncontrol_Roll\n, or the equivalent variable for the pitch for that matter, is then directly applied to the PWM module, in order to create a correction to the system (using the flaps, elevators, rudder, or what not).\n\n\nOutput Corrections\n\n\nOnce the calculations have been made to determine what corrections should be made to the system, it is then time to physically alter the system based on the calculations.\n\n\nThis involves output to the PWM module. After a series of checks, to ensure that all values are within the maximum and minimum parameters for the PWM signal, a PWM call is made to the appropriate channel:\n\n\nsetPWM(1, control_Roll + rollTrim);\n\n\n\nAs long as the PWM module was initialized, there shouldn't be any problem. The vehicle should move its servos appropriately.\n\n\nControl Levels\n\n\nThe control levels implemented in the attitude manager are an important part of the testing process. These levels determine which input sources have primary control over the aircraft, as well as how the input translates into flight.\n\n\nFor instance, when testing, one may wish to have control of the throttle, while the roll and pitch is controlled by the autopilot. Such control is implemented in the code.\n\n\nAs it is evident above, there a separate sections of code, which control individual PID loops. The control levels change the source of the input to the PIDs using a simple bit mask. The control level is actually determined by a single integer. Each value of the integer represents a different \ncontrol level.\n As a result, a bit mask is placed within an, if statement to determine whether or not a specific element of control is enabled or disabled.\n\n\nFor instance, take this scenario:\n\n\nif ((controlLevel \n ROLL_CONTROL_SOURCE) == 0 \n (controlLevel \n HEADING_CONTROL_ON) == 0)\n\n    sp_RollAngle = (int)((-sp_RollRate / ((float)SP\\_RANGE / MAX_ROLL_ANGLE) ));\n\n\n\nThis snippet of code, converts the controller input into a roll angle. For instance, if the stick is centered, the plane will be at a 0\u00b0 roll angle. If the pilot steers left, the plane will angle itself left at that same angle. The \nif\n statement contains two bit masks. Note that the \ncontrolLevel\n variable has a \nbitwise AND \n(\n) applied to it.\n\n\nTherefore, if the controlLevel is (in binary):\n\n\n0b00000000 00010011\n\n\nThe code above will run, because a \nAND\n bit mask of 0b00001000, will return a value of zero, just as well as 0b00000010 00000000 will also return a logical value of zero.\n\n\nThis type of logic is applied to multiple sections of the attitude manager code.", 
            "title": "Attitude Control"
        }, 
        {
            "location": "/picpilot/attitude-control/#attitude-control", 
            "text": "Attitude Control is very similar regardless of the aircraft which is being used. The end goal is to be able to keep the aircraft stable and in control. The way in which this is achieved is always very similar.  In the PICpilot, we use PID loops to manage our system. Although there are other types of controllers available, PID controllers are the best option due to their reliability, accuracy, and simplicity. The section on PID loops has a detailed explanation of how they work, and how they work together.  This section mostly deals with the  AttitudeManager.c  file, as the name implies.  The attitude manager has the 3 main goals, as well as a side task. The 3 main goals include the aggregation of status data (inputs, sensors, etc.), error analysis on the status of the aircraft, and corrections to the aircraft. The side task involves sending all this data to the ground station, as well as receiving from the ground station.", 
            "title": "Attitude Control"
        }, 
        {
            "location": "/picpilot/attitude-control/#initialization", 
            "text": "The initialization process involves beginning communication with all components. The process involves the following steps:   Initializing communication to the Path Manager via SPI and DMA  VN 100 is initialized  VN 100 is offset according to a rotation matrix  VN 100 is then calibrated with confidence parameters for the X/Y/Z magnetometers, accelerometers, and gyroscopes  PWM input and output is specified according to the used channels   This can be found in the  attitudeInit()  function in the  AttitudeManager.c  file.", 
            "title": "Initialization"
        }, 
        {
            "location": "/picpilot/attitude-control/#aggregation-of-data", 
            "text": "Using the initialized sensors from the prior section, the vehicle can now collect data systematically.  Every loop, new data is acquired from the DMA/SPI interface connected to the Path Manager chip. Data acquired from this chip includes the time, heading, speed, longitude, latitude, altitude, number of satellites, position fix, battery level, waypoint index, set point altitude, and set point heading.  Next, data is acquired from the PWM inputs. This includes stick positions, which determine the roll, pitch, yaw, and throttle of the aircraft. These inputs are scaled to values ranging from -1024 to 1024.  Finally, the VectorNav is polled for the latest rotational data. The roll, pitch, and yaw rate data is acquired through the  VN100_SPI_GetRates(0, (float*)  imuData)  function call. The roll, pitch, and yaw angles can be determined via the  VN100_SPI_GetYPR(0,  imuData[YAW],  imuData[PITCH],  imuData[ROLL])  function call.  This concludes all data acquisition. The next step involves analyzing the error.", 
            "title": "Aggregation of Data"
        }, 
        {
            "location": "/picpilot/attitude-control/#error-analysis-pid-control", 
            "text": "PID control works on the basis of minimizing error. The majority of the attitude manager involves consecutive PID loops correcting specific portions of flying an aircraft.  All the PID loop code can be found in the  OrientationControl.c  file. It is called from the AttitudeManager.c code.", 
            "title": "Error Analysis (PID control)"
        }, 
        {
            "location": "/picpilot/attitude-control/#altitude", 
            "text": "The altitude is controlled through a standard PID loop. This can be found in the code:      sp_PitchAngle = controlSignalAltitude(sp_Altitude,(int)gps_Altitude);\n\n    if (sp_PitchAngle   MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = MAX_PITCH_ANGLE;\n\n    if (sp_PitchAngle   -MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = -MAX_PITCH_ANGLE;  Logically, the pitch angle is determined from the desired altitude. If the plane is too low, the pitch angle will be positive (up). If the plane is too high, the pitch angle will be negative (down). The pitch angle is then checked to be within \"safety limits\".", 
            "title": "Altitude"
        }, 
        {
            "location": "/picpilot/attitude-control/#throttle", 
            "text": "Like the altitude PID loop, the throttle also has PID loop, which is also based on the altitude:      control_Throttle = sp_ThrottleRate + controlSignalThrottle(sp_Altitude, (int)gps_Altitude);\n\n    if (control_Throttle   MAX_PWM){\n\n        control_Throttle = MAX_PWM;\n\n    }\n\n    else if (control_Throttle   MIN_PWM){\n\n        control_Throttle = MIN_PWM;\n\n    }  Logically, if the plane needs to climb, you need to increase the throttle (otherwise it will stall due to low airspeed). Likewise, if the plane needs to reduce its altitude, to prevent high airspeeds, the plane decreases the throttle. If the plane is perfectly positioned, a constant throttle is maintained as per the  sp_ThrottleRate  variable. Once again, the throttle is limited within the legal limits of the throttle (to ensure the throttle doesn't become negative or larger than 100%).", 
            "title": "Throttle"
        }, 
        {
            "location": "/picpilot/attitude-control/#heading", 
            "text": "The heading control code looks as such:      while (sp_Heading   360)\n\n        sp_Heading -=360;\n\n    while (sp_Heading   0)\n\n        sp_Heading +=360;\n\n        sp_HeadingRate = controlSignalHeading(sp_Heading, gps_PositionFix==2?gps_Heading:(int)imu_YawAngle);\n\n        //Approximating Roll angle from Heading\n\n        sp_RollAngle = sp_HeadingRate;//(int)(atan((float)(sp_HeadingRate)) * PI/180.0);\n\n    if (sp_RollAngle   MAX_ROLL_ANGLE)\n\n        sp_RollAngle = MAX_ROLL_ANGLE;\n\n    if (sp_RollAngle   -MAX_ROLL_ANGLE)\n\n        sp_RollAngle = -MAX_ROLL_ANGLE;  As you can see, the input is the heading and the resulting output is a roll angle. In other words, if there is a greater error in the heading, a larger roll angle is established to correct for the heading error.  The first two while loops take into account any angle overflow or underflow, in other words, if the value is above 360 or negative, it is scaled to be between 0 and 360.  Once again the roll value is limited to a reasonable value, to prevent excessive maneuvers.", 
            "title": "Heading"
        }, 
        {
            "location": "/picpilot/attitude-control/#angles", 
            "text": "The code to maintain the angular roll and pitch of the aircraft look as such (one statement for each):  sp_ComputedRollRate = controlSignalAngles(sp_RollAngle,  imu_RollAngle, ROLL, -(SP_RANGE) / (MAX_ROLL_ANGLE));  Note that depending on the on the input angles, the output is a \"rate\". It is an angular rate. In other words, if the difference between the setpoint and the output is large, the angular rate will also be large.", 
            "title": "Angles"
        }, 
        {
            "location": "/picpilot/attitude-control/#angular-rate", 
            "text": "The result from the angular PID loop gives rise to the angular rate PID loop. This loop is often acknowledged as a stabilizing system, where small quick vibrations are accounted for.  control_Roll = controlSignal((sp_ComputedRollRate / SERVO_SCALE_FACTOR), imu_RollRate, ROLL);  The output of this function completes the PID pipeline. The value of  control_Roll , or the equivalent variable for the pitch for that matter, is then directly applied to the PWM module, in order to create a correction to the system (using the flaps, elevators, rudder, or what not).", 
            "title": "Angular Rate"
        }, 
        {
            "location": "/picpilot/attitude-control/#output-corrections", 
            "text": "Once the calculations have been made to determine what corrections should be made to the system, it is then time to physically alter the system based on the calculations.  This involves output to the PWM module. After a series of checks, to ensure that all values are within the maximum and minimum parameters for the PWM signal, a PWM call is made to the appropriate channel:  setPWM(1, control_Roll + rollTrim);  As long as the PWM module was initialized, there shouldn't be any problem. The vehicle should move its servos appropriately.", 
            "title": "Output Corrections"
        }, 
        {
            "location": "/picpilot/attitude-control/#control-levels", 
            "text": "The control levels implemented in the attitude manager are an important part of the testing process. These levels determine which input sources have primary control over the aircraft, as well as how the input translates into flight.  For instance, when testing, one may wish to have control of the throttle, while the roll and pitch is controlled by the autopilot. Such control is implemented in the code.  As it is evident above, there a separate sections of code, which control individual PID loops. The control levels change the source of the input to the PIDs using a simple bit mask. The control level is actually determined by a single integer. Each value of the integer represents a different  control level.  As a result, a bit mask is placed within an, if statement to determine whether or not a specific element of control is enabled or disabled.  For instance, take this scenario:  if ((controlLevel   ROLL_CONTROL_SOURCE) == 0   (controlLevel   HEADING_CONTROL_ON) == 0)\n\n    sp_RollAngle = (int)((-sp_RollRate / ((float)SP\\_RANGE / MAX_ROLL_ANGLE) ));  This snippet of code, converts the controller input into a roll angle. For instance, if the stick is centered, the plane will be at a 0\u00b0 roll angle. If the pilot steers left, the plane will angle itself left at that same angle. The  if  statement contains two bit masks. Note that the  controlLevel  variable has a  bitwise AND  ( ) applied to it.  Therefore, if the controlLevel is (in binary):  0b00000000 00010011  The code above will run, because a  AND  bit mask of 0b00001000, will return a value of zero, just as well as 0b00000010 00000000 will also return a logical value of zero.  This type of logic is applied to multiple sections of the attitude manager code.", 
            "title": "Control Levels"
        }, 
        {
            "location": "/picpilot/path-management/", 
            "text": "Path Management\n\n\nPath management can be broken up into 3 sections. The straight parts, the parts where you turn, and the way you put them together. There is not much more to it than that.\n\n\nStraight Line Path Following\n\n\nStraight line path following, also known as, following a line, is the most rudimentary part of any unmanned system. It is mostly a mathematical construct applied to a digital system. The mathematics will be described here, which can be easily compared to the code.\n\n\nThe principle is simple. Given two points, and the location of your vehicle, determine what heading it should follow. Now imagine the plane is directly on the path. The heading would follow the line exactly. Now imagine the plane is slightly off the path. What should happen is that the plane should face slightly towards the path, to minimize its \ncross-track error\n. Now imagine the plane is an infinite distance away. The plane should head at a heading perpendicular to the line, in order to regain distance. This is the premise of the straight line path following algorithm. As a result, a heading vector field would look as such:\n\n\n\n\nThe equations that govern this behaviour are not complicated. There are only a few things required to make this calculation. Firstly, you must know the heading of the path. If you have the XY coordinates of the path endpoints, you can easily determine that through simple trigonometry. If you only have the GPS coordinates, you should use the \nHaversine Formula\n in order to get the XY coordinates.\n\n\nOnce you have the coordinates, subtracting them will give you the direction of travel (in an XY plane). Furthermore, by applying the \narctan\n function on the direction of travel, one will determine the path heading. In addition, the value should be between \u2013PI and +PI. Thus, any 2PI corrections that need to be made can be made at this point.\n\n\nNow the path error (or cross-track error) is calculated. This is calculated as:\n\n\ncos(courseAngle) * (positionY - targetWaypointY) \u2013 sin(courseAngle)*(positionX \u2013 targetWaypointX)\n\n\n\nOn a map, the _cross-track error _looks like this:\n\n\n\n\nUsing trigonometry you can easily derive the formula (as above) for cross-track error to encompass any situation.\n\n\nThe cross track error is then useful to determine the heading of the aircraft. Once again, using the \narctan\n function is suitable to do so:\n\n\n\n\n90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError))\n\n\n\nNote, as the atan term increases, the heading approaches the \n(courseAngle -__MAX_PATH_APPROACH_ANGLE)\n.\n\n\nNote, that the courseAngle is calculated with respect to the x-axis, on the x-y plane. In other words, a path going from West to East would have a courseAngle of 0 degrees. This would be 90 degrees in terms of a true heading. Therefore, to get the true heading, you must subtract the \ncourseAngle\n from 90 degrees.\n\n\nOrbit Following\n\n\nUnlike straight line path following, orbit following involves following a curve of a certain radius. An orbit is depicted by a radius, a center location, and the direction of travel (clockwise or anti-clockwise).\n\n\n\n\nIn order to maintain a certain radius, the Euclidean distance needs to be calculated between the center of the orbit and the plane itself. The goal of this function is to maintain this Euclidean distance constant. The Euclidean distance can be calculated as such:\n\n\nfloat orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));\n\n\n\nThis value is then used to determine the equivalent of \ncross-track _error, but for an orbit. This is done very easily. The term _d\n (Euclidean distance) subtracted by the \n\u03c1\n (desired radius) provides the relative error, which must be minimized.\n\n\n\n\n90 - rad2deg(courseAngle + direction \\* (PI/2 + atan(k\\_gain[ORBIT] \\* (orbitDistance - radius)/radius)))\n\n\n\nThis equation is actually very similar to the equation governing straight line path following. The \narctan\n function forces the heading to converge onto the orbit. The direction of travel (\n\u03bb\n) which can be either \n1\n or \n-1\n, reverses the effect of the heading perturbations. This is then added onto the course angle as a perturbation. Once again, a gain value needs to be tuned to determine the rate of convergence.\n\n\nThe course angle can be determined easily based on the location of the curve. For instance, if the vehicle is in the first quadrant of the circle/orbit, the heading will range between 270\u00b0 and 0\u00b0, assuming a counter-clockwise rotation. This course angle can be calculated using this equation:\n\n\nfloat courseAngle = atan2(position[1] - center[1], position[0] - center[0]);\n\n\n\nPutting it all together\n\n\nThe orbit following and straight path following algorithms are used in combination in order to assemble a path. Both algorithms alternate in usage. Every corner uses the orbit following algorithm. Every straight line uses the straight path following algorithm.\n\n\nIn order to put the two together, you must draw in orbits between each set of points. The additional restriction is that they must be tangent to both lines, as depicted in this diagram:\n\n\n\n\nFiguring out where the tangent will touch requires some basic trigonometry. The derivation won't be explained here, however, the coordinates at which this occurs can be calculated using:\n\n\n\n\nWhere nextX/Y/Z refer to the coordinates of the point Wi+1 and targetX/Y/Z refer to the coordinates of the point Wi.\n\n\nThe turning angle can be calculated via the following equation:\n\n\nfloat turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));\n\n\n\nThis is simply the dot product of the (Wi - Wi-1) vector and the (Wi+1 - Wi) vector. Given the dot product formula, you can use the \narccos\n function to determine the angle between the two lines.\n\n\nAt these calculated points, there is a checkpoint. Imagine a giant plane perpendicular to the path. As soon as the plane crosses this boundary, the next step is executed. For instance, if the vehicle is travelling straight along a path, then passes the plane, it will initiate a turn (orbiting algorithm). Once it passes the next plane, it will initiate the straight line path following algorithm once again.\n\n\nIn order to detect if a vehicle passes the boundary, the dot product of two vectors must be taken. If the value is positive, it is an indicator that the vehicle has crossed the boundary.\n\n\nThe dot product is:\n\n\n\n\nBoth vectors have X, Y, and Z components. Likewise, equations that depict the half plane are stated above.\n\n\nNote that in the code, all \"direction vectors\" such as Wi \u2013 Wi-1 are normalized.\n\n\nFor every pair of \"checkpoints\" the path index is incremented once they are passed. The index is used to identify the data in a linked list through the wireless communications.\n\n\nManaging Path Data\n\n\nPath data is stored in a structure, which contains all necessary information for a single path (line) segment. The construct looks as follows:\n\n\ntypedef struct _PathData{\n\n    struct _PathData* next;\n\n    struct _PathData* previous;\n\n    long double longitude;  //TODO: Longitude and Latitude is bulky. Use cartesian 2D approximations\n\n    long double latitude;\n\n    float altitude;\n\n    float radius; //Radius of turn\n\n    char id;    //Array ID\n\n    char index;\n\n} PathData;\n\n\n\nThis structure is a doubly linked list element. It links to the previous node and the next node. This makes it easy to traverse from one element to another. As a result, it is easy to add, insert, delete, and clear all waypoint nodes.\n\n\nThe included functions are:\n\n\nPathData* initializePathNode(void);\n\nunsigned int destroyPathNode(PathData* node);\n\nPathData* initializePathNodeAndNext(void);\n\nunsigned int appendPathNode(PathData* node);\n\nunsigned int removePathNode(unsigned int ID);\n\nvoid clearPathNodes(void);\n\nunsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID);\n\n\n\nThese functions are all executed in the _checkAMData() _function. This function polls input over the DMA/SPI bus. When a new input is detected (via the WaypointWrapper structure), a corresponding function is executed.", 
            "title": "Path Management"
        }, 
        {
            "location": "/picpilot/path-management/#path-management", 
            "text": "Path management can be broken up into 3 sections. The straight parts, the parts where you turn, and the way you put them together. There is not much more to it than that.", 
            "title": "Path Management"
        }, 
        {
            "location": "/picpilot/path-management/#straight-line-path-following", 
            "text": "Straight line path following, also known as, following a line, is the most rudimentary part of any unmanned system. It is mostly a mathematical construct applied to a digital system. The mathematics will be described here, which can be easily compared to the code.  The principle is simple. Given two points, and the location of your vehicle, determine what heading it should follow. Now imagine the plane is directly on the path. The heading would follow the line exactly. Now imagine the plane is slightly off the path. What should happen is that the plane should face slightly towards the path, to minimize its  cross-track error . Now imagine the plane is an infinite distance away. The plane should head at a heading perpendicular to the line, in order to regain distance. This is the premise of the straight line path following algorithm. As a result, a heading vector field would look as such:   The equations that govern this behaviour are not complicated. There are only a few things required to make this calculation. Firstly, you must know the heading of the path. If you have the XY coordinates of the path endpoints, you can easily determine that through simple trigonometry. If you only have the GPS coordinates, you should use the  Haversine Formula  in order to get the XY coordinates.  Once you have the coordinates, subtracting them will give you the direction of travel (in an XY plane). Furthermore, by applying the  arctan  function on the direction of travel, one will determine the path heading. In addition, the value should be between \u2013PI and +PI. Thus, any 2PI corrections that need to be made can be made at this point.  Now the path error (or cross-track error) is calculated. This is calculated as:  cos(courseAngle) * (positionY - targetWaypointY) \u2013 sin(courseAngle)*(positionX \u2013 targetWaypointX)  On a map, the _cross-track error _looks like this:   Using trigonometry you can easily derive the formula (as above) for cross-track error to encompass any situation.  The cross track error is then useful to determine the heading of the aircraft. Once again, using the  arctan  function is suitable to do so:   90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError))  Note, as the atan term increases, the heading approaches the  (courseAngle -__MAX_PATH_APPROACH_ANGLE) .  Note, that the courseAngle is calculated with respect to the x-axis, on the x-y plane. In other words, a path going from West to East would have a courseAngle of 0 degrees. This would be 90 degrees in terms of a true heading. Therefore, to get the true heading, you must subtract the  courseAngle  from 90 degrees.", 
            "title": "Straight Line Path Following"
        }, 
        {
            "location": "/picpilot/path-management/#orbit-following", 
            "text": "Unlike straight line path following, orbit following involves following a curve of a certain radius. An orbit is depicted by a radius, a center location, and the direction of travel (clockwise or anti-clockwise).   In order to maintain a certain radius, the Euclidean distance needs to be calculated between the center of the orbit and the plane itself. The goal of this function is to maintain this Euclidean distance constant. The Euclidean distance can be calculated as such:  float orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));  This value is then used to determine the equivalent of  cross-track _error, but for an orbit. This is done very easily. The term _d  (Euclidean distance) subtracted by the  \u03c1  (desired radius) provides the relative error, which must be minimized.   90 - rad2deg(courseAngle + direction \\* (PI/2 + atan(k\\_gain[ORBIT] \\* (orbitDistance - radius)/radius)))  This equation is actually very similar to the equation governing straight line path following. The  arctan  function forces the heading to converge onto the orbit. The direction of travel ( \u03bb ) which can be either  1  or  -1 , reverses the effect of the heading perturbations. This is then added onto the course angle as a perturbation. Once again, a gain value needs to be tuned to determine the rate of convergence.  The course angle can be determined easily based on the location of the curve. For instance, if the vehicle is in the first quadrant of the circle/orbit, the heading will range between 270\u00b0 and 0\u00b0, assuming a counter-clockwise rotation. This course angle can be calculated using this equation:  float courseAngle = atan2(position[1] - center[1], position[0] - center[0]);", 
            "title": "Orbit Following"
        }, 
        {
            "location": "/picpilot/path-management/#putting-it-all-together", 
            "text": "The orbit following and straight path following algorithms are used in combination in order to assemble a path. Both algorithms alternate in usage. Every corner uses the orbit following algorithm. Every straight line uses the straight path following algorithm.  In order to put the two together, you must draw in orbits between each set of points. The additional restriction is that they must be tangent to both lines, as depicted in this diagram:   Figuring out where the tangent will touch requires some basic trigonometry. The derivation won't be explained here, however, the coordinates at which this occurs can be calculated using:   Where nextX/Y/Z refer to the coordinates of the point Wi+1 and targetX/Y/Z refer to the coordinates of the point Wi.  The turning angle can be calculated via the following equation:  float turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));  This is simply the dot product of the (Wi - Wi-1) vector and the (Wi+1 - Wi) vector. Given the dot product formula, you can use the  arccos  function to determine the angle between the two lines.  At these calculated points, there is a checkpoint. Imagine a giant plane perpendicular to the path. As soon as the plane crosses this boundary, the next step is executed. For instance, if the vehicle is travelling straight along a path, then passes the plane, it will initiate a turn (orbiting algorithm). Once it passes the next plane, it will initiate the straight line path following algorithm once again.  In order to detect if a vehicle passes the boundary, the dot product of two vectors must be taken. If the value is positive, it is an indicator that the vehicle has crossed the boundary.  The dot product is:   Both vectors have X, Y, and Z components. Likewise, equations that depict the half plane are stated above.  Note that in the code, all \"direction vectors\" such as Wi \u2013 Wi-1 are normalized.  For every pair of \"checkpoints\" the path index is incremented once they are passed. The index is used to identify the data in a linked list through the wireless communications.", 
            "title": "Putting it all together"
        }, 
        {
            "location": "/picpilot/path-management/#managing-path-data", 
            "text": "Path data is stored in a structure, which contains all necessary information for a single path (line) segment. The construct looks as follows:  typedef struct _PathData{\n\n    struct _PathData* next;\n\n    struct _PathData* previous;\n\n    long double longitude;  //TODO: Longitude and Latitude is bulky. Use cartesian 2D approximations\n\n    long double latitude;\n\n    float altitude;\n\n    float radius; //Radius of turn\n\n    char id;    //Array ID\n\n    char index;\n\n} PathData;  This structure is a doubly linked list element. It links to the previous node and the next node. This makes it easy to traverse from one element to another. As a result, it is easy to add, insert, delete, and clear all waypoint nodes.  The included functions are:  PathData* initializePathNode(void);\n\nunsigned int destroyPathNode(PathData* node);\n\nPathData* initializePathNodeAndNext(void);\n\nunsigned int appendPathNode(PathData* node);\n\nunsigned int removePathNode(unsigned int ID);\n\nvoid clearPathNodes(void);\n\nunsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID);  These functions are all executed in the _checkAMData() _function. This function polls input over the DMA/SPI bus. When a new input is detected (via the WaypointWrapper structure), a corresponding function is executed.", 
            "title": "Managing Path Data"
        }, 
        {
            "location": "/picpilot/resources/", 
            "text": "Additional Readings and Resources\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help", 
            "title": "Resources"
        }, 
        {
            "location": "/picpilot/resources/#additional-readings-and-resources", 
            "text": "Information on Model Aircraft  General Aerodynamic Principles  Git Help", 
            "title": "Additional Readings and Resources"
        }, 
        {
            "location": "/picpilot/faq/", 
            "text": "FAQ\n\n\nNo questions here yet.", 
            "title": "FAQ"
        }, 
        {
            "location": "/picpilot/faq/#faq", 
            "text": "No questions here yet.", 
            "title": "FAQ"
        }, 
        {
            "location": "/computer-vision/", 
            "text": "Welcome to the Computer Vision Docs!\n\n\nContents\n\n\n\n\nBuilding the project - Linux\n\n\nBuilding the project - Windows\n\n\nCoding Conventions\n\n\nUsing the WARG Server Environment\n\n\nContributing\n\n\nWriting Tests\n\n\n\n\nInstallation\n\n\nThe installation process depends on what system you have. WARG-CV runs on Linux. However, in case you don\u2019t have Linux, we have premade a DockerFile, so that you can setup a virtual image on any system.\nYou may be able to get the project to compile on Mac OS X, but that is up to you to figure out.\n\n\nIf you don't have a Linux environment, don't worry! You can download a docker image. It is essentially a premade virtual machine.\n\n\n\n\nGo to \nhttps://docs.docker.com/mac/\n for Mac systems\n\n\nGo to \nhttps://docs.docker.com/windows/\n for Windows systems.\n\n\n\n\nYou can get our \ndocker image here\n.\n\n\nAfter completing the download and installing docker:\n\n\n\n\nUnzip the package.\n\n\ndocker import IMAGE.tar.gz\n where IMAGE is the name of the docker image archive included in the zip archive\n\n\ndocker images\n should now list the new image\n\n\ndocker run -i -t IMAGE_ID /bin/bash\n with the appropriate image id as shown with \ndocker images", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/computer-vision/#welcome-to-the-computer-vision-docs", 
            "text": "", 
            "title": "Welcome to the Computer Vision Docs!"
        }, 
        {
            "location": "/computer-vision/#contents", 
            "text": "Building the project - Linux  Building the project - Windows  Coding Conventions  Using the WARG Server Environment  Contributing  Writing Tests", 
            "title": "Contents"
        }, 
        {
            "location": "/computer-vision/#installation", 
            "text": "The installation process depends on what system you have. WARG-CV runs on Linux. However, in case you don\u2019t have Linux, we have premade a DockerFile, so that you can setup a virtual image on any system.\nYou may be able to get the project to compile on Mac OS X, but that is up to you to figure out.  If you don't have a Linux environment, don't worry! You can download a docker image. It is essentially a premade virtual machine.   Go to  https://docs.docker.com/mac/  for Mac systems  Go to  https://docs.docker.com/windows/  for Windows systems.   You can get our  docker image here .  After completing the download and installing docker:   Unzip the package.  docker import IMAGE.tar.gz  where IMAGE is the name of the docker image archive included in the zip archive  docker images  should now list the new image  docker run -i -t IMAGE_ID /bin/bash  with the appropriate image id as shown with  docker images", 
            "title": "Installation"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/", 
            "text": "Building the Project\n\n\n1. Install Dependencies\n\n\nDependencies:\n- OpenCV - 3.x (2.x.x is no longer supported)\n- Boost - Tested with 1.56-60, should work with earlier versions\n- ZBar\n- DecklinkSDK (Optional, if available builds support for reading video from Decklink video capture cards)\n- Exiv2\n\n\n2. Clone the Repo\n\n\ngit clone https://github.com/UWARG/computer-vision.git\n\n\n\n\nIf you want to be able to submit changes you should fork the repository first and then clone your fork\n\n\ngit clone https://github.com/YOUR_NAME_HERE/computer-vision.git\n\n\n\n\n3. Configure the project with CMake\n\n\nIt is recommended to build from a separate directory to keep the source tree clean\n\n\ncd computer vision\nmkdir build\ncd build\ncmake ..\n\n\n\n\n4. Build\n\n\nmake\n\n\n\n\nBuilding individual modules\nOnce the project is configured\n\n\nmake MODULE_NAME\n\n\n\n\nFor a list of build targets including Submodules\n\n\nmake help\n\n\n\n\nRunning tests\n\n\nmake test", 
            "title": "Building the project [Linux]"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#building-the-project", 
            "text": "", 
            "title": "Building the Project"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#1-install-dependencies", 
            "text": "Dependencies:\n- OpenCV - 3.x (2.x.x is no longer supported)\n- Boost - Tested with 1.56-60, should work with earlier versions\n- ZBar\n- DecklinkSDK (Optional, if available builds support for reading video from Decklink video capture cards)\n- Exiv2", 
            "title": "1. Install Dependencies"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#2-clone-the-repo", 
            "text": "git clone https://github.com/UWARG/computer-vision.git  If you want to be able to submit changes you should fork the repository first and then clone your fork  git clone https://github.com/YOUR_NAME_HERE/computer-vision.git", 
            "title": "2. Clone the Repo"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#3-configure-the-project-with-cmake", 
            "text": "It is recommended to build from a separate directory to keep the source tree clean  cd computer vision\nmkdir build\ncd build\ncmake ..", 
            "title": "3. Configure the project with CMake"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#4-build", 
            "text": "make  Building individual modules\nOnce the project is configured  make MODULE_NAME  For a list of build targets including Submodules  make help  Running tests  make test", 
            "title": "4. Build"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Windows]/", 
            "text": "Building the project\n\n\nTODO: Anyone who wants to try doing this, please fill this out", 
            "title": "Building the project [Windows]"
        }, 
        {
            "location": "/computer-vision/Building-the-project-[Windows]/#building-the-project", 
            "text": "TODO: Anyone who wants to try doing this, please fill this out", 
            "title": "Building the project"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/", 
            "text": "Coding Conventions\n\n\nCode\n\n\nVariable Names:\n\n\nvarName\n\n\nConstant Names:\n\n\nCONST_NAME\n\n\nFunction Names:\n\n\nfunction_name\n\n\nClass Names:\n\n\nClassName\n\n\nIndentation:\n\n\n4 spaces per level of indentation\n\n\nbrackets:\n\n\nvoid foo_bar(int i) {\n    int varName = (i + 2)/2;\n}\n\n\n\n\nFile Structure\n\n\nFile Names:\n\n\nfile_name.ext\n\n\nDirectory Structure:\n\n\n|-- computer-vision\n    |-- modules\n        |-- core\n            |-- include\n                |-- header.h\n            |-- src\n                |-- source.cpp\n            |-- CMakeLists.txt\n    |-- CMakeLists.txt\n    |-- main.cpp\n         ...\n\n\n\n\nHeader File Formatting\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \nbar.h\n\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED\n\n\n\n\nSource file formatting\n\n\n/*\n * This file is part of WARG's computer-vision\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \nbar.h\n\n#include \nfoo.h\n\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}", 
            "title": "Coding Conventions"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#coding-conventions", 
            "text": "", 
            "title": "Coding Conventions"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#variable-names", 
            "text": "varName", 
            "title": "Variable Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#constant-names", 
            "text": "CONST_NAME", 
            "title": "Constant Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#function-names", 
            "text": "function_name", 
            "title": "Function Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#class-names", 
            "text": "ClassName", 
            "title": "Class Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#indentation", 
            "text": "4 spaces per level of indentation", 
            "title": "Indentation:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#brackets", 
            "text": "void foo_bar(int i) {\n    int varName = (i + 2)/2;\n}", 
            "title": "brackets:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#file-structure", 
            "text": "", 
            "title": "File Structure"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#file-names", 
            "text": "file_name.ext", 
            "title": "File Names:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#directory-structure", 
            "text": "|-- computer-vision\n    |-- modules\n        |-- core\n            |-- include\n                |-- header.h\n            |-- src\n                |-- source.cpp\n            |-- CMakeLists.txt\n    |-- CMakeLists.txt\n    |-- main.cpp\n         ...", 
            "title": "Directory Structure:"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#header-file-formatting", 
            "text": "/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include  bar.h \n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED", 
            "title": "Header File Formatting"
        }, 
        {
            "location": "/computer-vision/Coding-Conventions/#source-file-formatting", 
            "text": "/*\n * This file is part of WARG's computer-vision\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include  bar.h \n#include  foo.h \n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}", 
            "title": "Source file formatting"
        }, 
        {
            "location": "/computer-vision/Contributing/", 
            "text": "Contributing\n\n\n\n\nAdding a New Class\n\n\nThe project is divided into modules. Any class that is specific to a certain module should be stored in that module's directory. Classes that need to be accessed by multiple modules should go in Core.\n\n\nThe class should be declared in a header file of the same name as the class and placed in the appropriate module's include directory.\n\n\nFor example: Suppose we are creating class Foo in module Core\n\n\n(See \nCoding Conventions\n for details on formatting)\n\n\nFile: modules/core/include/foo.h\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \nbar.h\n\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED\n\n\n\n\nThe corresponding source file which contains the definitions for the class Foo is placed in the src folder\n\n\nFile: modules/core/src/foo.cpp\n\n\n/**\n * @file foo.cpp\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \nbar.h\n\n#include \nfoo.h\n\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}\n\n\n\n\n\nHowever we're not done yet. While header files when placed in the proper directory are immediately ready for use, source files must be added to the module's CMakeLists.txt file to be compiled into the module.\n\n\nFile: modules/core/CMakeLists.txt\n\n\ninclude_directories(include)\nadd_library(Core src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\n\n\n\n\nYour source file should be added to the arguments of the add_library function (ideally in retaining alphabetical order for readability)\n\n\nBut what if bar is part of an external library?\n\n\nIf you've forgotten what bar is already notice that it is an external class included in foo.h\n\n\nThe first question to answer is whether or not the use of bar can be avoided. In particular it may provide functionality that is already available in one of the project's current dependencies. Unless it provides substantially improved functionality over what is already available it probably shouldn't be added to the project.\n\n\nIf you determine that bar is a necessary dependency, then it needs to be added to CMakeLists.txt as well. As long as it is only being used in one module, it can be defined in that module's CMakeLists.txt rather than the global CMakeLists.txt.\n\n\nFor simplicity we will assume bar.h is part of the package Bar\n\n\nFile: modules/core/CMakeLists.txt\n\n\ninclude_directories(include)\nfind_package(Bar)\nif(Bar_FOUND)\n    include_directories(${Bar_INCLUDE_DIRS})\n    add_library(Core ${Bar_LIBRARIES} src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\nendif()\n\n\n\n\nYou may want to research the library you've added online since many external libraries have additional configuration that needs to be added to the CMakeLists or unusual naming conventions for the package.\n\n\nAnd we're done.\nNow if you re-run cmake and re-build Foo should be built into the project.\n\n\n\n\nContributing to Master Repository\n\n\nTo get your code added to master you will, if you haven't done so already, need to fork the project. This can be done by going to the computer-vision page on GitHub and clicking the fork button in the top right.\n\n\nYou then need to make your local code point your fork rather than master.\n\n\ngit remote set-url origin $FORK_URL\n\n\n\n\nWhere $FORK_URL is the clone link for your fork\n\n\nYou will also want to set a new remote, called upstream, to reference the master repository so that you can pull changes.\n\n\ngit remote add upstream git@github.com:UWARG/computer-vision.git\n\n\n\n\nor for https\n\n\ngit remote add upstream https://github.com/UWARG/computer-vision.git\n\n\n\n\nthis allows upstream changes to be fetched with \ngit fetch upstream\n and merged into the current branch with \ngit merge upstream/branch_name\n\n\nNow, you can commit your code and push to the fork with\n\n\ngit add modules/core/src/foo.cpp modules/core/include/foo.h modules/core/CMakeLists.txt\ngit commit -m \nAdded class Foo\n\ngit push origin\n\n\n\n\nNote that it is recommended to add files individually rather than adding all at once with \ngit add -A .\n\n\nThat way you ensure you only commit the files you intend to add.\nYou can also see a list of all unstaged changes (changes that have yet to be added) using \ngit diff\n\n\nOnce the code is pushed, go to Github to your fork's page and create a pull request by either going into the pull request menu and choosing \"New Pull Request\", or, if you have pushed code recently, a pop-up will appear on the main page prompting you to create a pull request.\n\n\nFrom the pull request page you can add comments to the pull request noting what you have changed, you can review the changed you have made to make sure you haven't included anything unnecessary and then you can submit the request.\n\n\nPlease note that pull requests will be rejected if they contain extraneous changes.\nYou can avoid a lot of issues by configuring git to ignore point out whitespace issues in diffs and to fix when patching with:\n\n\ngit config core.whitespace trailing-space,space-before-tab\ngit config apply.whitespace fix", 
            "title": "Contributing"
        }, 
        {
            "location": "/computer-vision/Contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }, 
        {
            "location": "/computer-vision/Contributing/#adding-a-new-class", 
            "text": "The project is divided into modules. Any class that is specific to a certain module should be stored in that module's directory. Classes that need to be accessed by multiple modules should go in Core.  The class should be declared in a header file of the same name as the class and placed in the appropriate module's include directory.  For example: Suppose we are creating class Foo in module Core  (See  Coding Conventions  for details on formatting)  File: modules/core/include/foo.h  /**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include  bar.h \n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED  The corresponding source file which contains the definitions for the class Foo is placed in the src folder  File: modules/core/src/foo.cpp  /**\n * @file foo.cpp\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include  bar.h \n#include  foo.h \n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}  However we're not done yet. While header files when placed in the proper directory are immediately ready for use, source files must be added to the module's CMakeLists.txt file to be compiled into the module.  File: modules/core/CMakeLists.txt  include_directories(include)\nadd_library(Core src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)  Your source file should be added to the arguments of the add_library function (ideally in retaining alphabetical order for readability)", 
            "title": "Adding a New Class"
        }, 
        {
            "location": "/computer-vision/Contributing/#but-what-if-bar-is-part-of-an-external-library", 
            "text": "If you've forgotten what bar is already notice that it is an external class included in foo.h  The first question to answer is whether or not the use of bar can be avoided. In particular it may provide functionality that is already available in one of the project's current dependencies. Unless it provides substantially improved functionality over what is already available it probably shouldn't be added to the project.  If you determine that bar is a necessary dependency, then it needs to be added to CMakeLists.txt as well. As long as it is only being used in one module, it can be defined in that module's CMakeLists.txt rather than the global CMakeLists.txt.  For simplicity we will assume bar.h is part of the package Bar  File: modules/core/CMakeLists.txt  include_directories(include)\nfind_package(Bar)\nif(Bar_FOUND)\n    include_directories(${Bar_INCLUDE_DIRS})\n    add_library(Core ${Bar_LIBRARIES} src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\nendif()  You may want to research the library you've added online since many external libraries have additional configuration that needs to be added to the CMakeLists or unusual naming conventions for the package.  And we're done.\nNow if you re-run cmake and re-build Foo should be built into the project.", 
            "title": "But what if bar is part of an external library?"
        }, 
        {
            "location": "/computer-vision/Contributing/#contributing-to-master-repository", 
            "text": "To get your code added to master you will, if you haven't done so already, need to fork the project. This can be done by going to the computer-vision page on GitHub and clicking the fork button in the top right.  You then need to make your local code point your fork rather than master.  git remote set-url origin $FORK_URL  Where $FORK_URL is the clone link for your fork  You will also want to set a new remote, called upstream, to reference the master repository so that you can pull changes.  git remote add upstream git@github.com:UWARG/computer-vision.git  or for https  git remote add upstream https://github.com/UWARG/computer-vision.git  this allows upstream changes to be fetched with  git fetch upstream  and merged into the current branch with  git merge upstream/branch_name  Now, you can commit your code and push to the fork with  git add modules/core/src/foo.cpp modules/core/include/foo.h modules/core/CMakeLists.txt\ngit commit -m  Added class Foo \ngit push origin  Note that it is recommended to add files individually rather than adding all at once with  git add -A .  That way you ensure you only commit the files you intend to add.\nYou can also see a list of all unstaged changes (changes that have yet to be added) using  git diff  Once the code is pushed, go to Github to your fork's page and create a pull request by either going into the pull request menu and choosing \"New Pull Request\", or, if you have pushed code recently, a pop-up will appear on the main page prompting you to create a pull request.  From the pull request page you can add comments to the pull request noting what you have changed, you can review the changed you have made to make sure you haven't included anything unnecessary and then you can submit the request.  Please note that pull requests will be rejected if they contain extraneous changes.\nYou can avoid a lot of issues by configuring git to ignore point out whitespace issues in diffs and to fix when patching with:  git config core.whitespace trailing-space,space-before-tab\ngit config apply.whitespace fix", 
            "title": "Contributing to Master Repository"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/", 
            "text": "Using the Warg Computer environment\n\n\n(Note that at the time of this being written the server is still being set up, hence a lot of this guide is both not yet applicable and may change)\n\n\nSetting up an SSH Client\n\n\nBefore you can connect to the WARG Server you will need an SSH client.\n\n\nWindows:\n\n\nThere are several windows SSH clients, one of the more popular ones is PuTTY, which can be downloaded \nhere\n\n\nMac OS X and Linux:\n\n\nSSH should be installed by default and can be accessed by the following terminal command\n\n\nssh user@hostname\n\n\n\n\nGetting an account\n\n\nYou will not be able to connect to the WARG server without an account on the system. You will have to come in personally to the WARG bay to set this up.\n\n\nConnecting to the server\n\n\nTo connect to the WARG server you will need\n\n\nUser:\n     User-name you set up on the WARG server\n\n\nHost-name:\n ip address of the WARG computer\n\n\nPort:\n 22 (The default port, you probably won't need to set this)\n\n\nLinux and OS X\n\n\nOn Linux or OS X this translates to the following command:\n\n\nssh user@ssh.uwarg.com\n\n\n\n\nOptionally you can append -Y to the end of the command to enable graphics forwarding which will allow you to run graphical applications on the server (with the graphics being displayed on your computer)\n\n\nssh user@ssh.uwarg.com -Y\n\n\n\n\nWindows\n\n\nOn Windows, see one of the following tutorials for more info on configuring PuTTY.\n\n\nAn older tutorial that covers the basics\n\n\nhttp://jfitz.com/tips/putty_config.html\n\n\nMore advanced PuTTY usage\n\n\nhttp://support.suso.com/supki/SSH_Tutorial_for_Windows\n\n\nUseful Commands in the Server Environment (feel free to expand this section)\n\n\n(words in ALL_CAPS are arguments)\n\n\nls\n Shows a list of files and directories in your current directory or in a different one by specifying a different directory \nls DIRECTORY\n\n\ncd DIRECTORY\n opens the given directory\n\n\nnano\n Simple command line text editor, can open files with \nnano FILE_NAME\n\n\n(for a more complex editor that is better suited to programming, try \nvim\n or \nemacs\n. \nhere\n is an emacs tutorial and \nhere\n is a vim one. There is also this fun looking interactive vim tutorial \nhere\n)\n\n\nYou can also learn more about any of the commands by appending \n--help\n to a command or by entering \nman COMMAND\n\n\nUseful Graphical Applications\n\n\ngedit\n The Gnome text editor\n\n\nnautilus\n A Linux file manager", 
            "title": "Using the WARG computer environment"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#using-the-warg-computer-environment", 
            "text": "(Note that at the time of this being written the server is still being set up, hence a lot of this guide is both not yet applicable and may change)", 
            "title": "Using the Warg Computer environment"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#setting-up-an-ssh-client", 
            "text": "Before you can connect to the WARG Server you will need an SSH client.", 
            "title": "Setting up an SSH Client"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#windows", 
            "text": "There are several windows SSH clients, one of the more popular ones is PuTTY, which can be downloaded  here", 
            "title": "Windows:"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#mac-os-x-and-linux", 
            "text": "SSH should be installed by default and can be accessed by the following terminal command  ssh user@hostname", 
            "title": "Mac OS X and Linux:"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#getting-an-account", 
            "text": "You will not be able to connect to the WARG server without an account on the system. You will have to come in personally to the WARG bay to set this up.", 
            "title": "Getting an account"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#connecting-to-the-server", 
            "text": "To connect to the WARG server you will need  User:      User-name you set up on the WARG server  Host-name:  ip address of the WARG computer  Port:  22 (The default port, you probably won't need to set this)", 
            "title": "Connecting to the server"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#linux-and-os-x", 
            "text": "On Linux or OS X this translates to the following command:  ssh user@ssh.uwarg.com  Optionally you can append -Y to the end of the command to enable graphics forwarding which will allow you to run graphical applications on the server (with the graphics being displayed on your computer)  ssh user@ssh.uwarg.com -Y", 
            "title": "Linux and OS X"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#windows_1", 
            "text": "On Windows, see one of the following tutorials for more info on configuring PuTTY.  An older tutorial that covers the basics  http://jfitz.com/tips/putty_config.html  More advanced PuTTY usage  http://support.suso.com/supki/SSH_Tutorial_for_Windows", 
            "title": "Windows"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#useful-commands-in-the-server-environment-feel-free-to-expand-this-section", 
            "text": "(words in ALL_CAPS are arguments)  ls  Shows a list of files and directories in your current directory or in a different one by specifying a different directory  ls DIRECTORY  cd DIRECTORY  opens the given directory  nano  Simple command line text editor, can open files with  nano FILE_NAME  (for a more complex editor that is better suited to programming, try  vim  or  emacs .  here  is an emacs tutorial and  here  is a vim one. There is also this fun looking interactive vim tutorial  here )  You can also learn more about any of the commands by appending  --help  to a command or by entering  man COMMAND", 
            "title": "Useful Commands in the Server Environment (feel free to expand this section)"
        }, 
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#useful-graphical-applications", 
            "text": "gedit  The Gnome text editor  nautilus  A Linux file manager", 
            "title": "Useful Graphical Applications"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/", 
            "text": "Writing Tests\n\n\nTesting should be done in a directory inside the submodule called test, which should be included in the module's CMakeLists.txt via add_subdirectory and should have its own CMakeLists.txt.\nFurthermore, large test files should be stored in the global computer-vision/testdata directory so that they can be shared between multiple tests.\nThat is, test directories should have the following structure\n\n\n|-- computer-vision\n    |-- modules\n        |-- MODULE_NAME\n            |-- include\n            |-- src\n            |-- test\n                |-- CMakeLists.txt\n                |-- foo_test.cpp\n                |-- bar_test.cpp\n            |-- CMakeLists.txt\n    |-- testdata\n        |-- image.jpg\n\n\n\n\nTesting should be done using the boost test framework.\n\n\nTutorials provided by boost are found \nhere\n.\n\n\nAPI Reference available \nhere\n\n\nTo test code it should be run inside the BOOST_AUTO_TEST_CASE and use the boost test macros to verify sanity and results.\nSome available macros include\n\n\nBOOST_WARN(predicate); // produces a warning if predicate is false, does not cause failures\nBOOST_CHECK(predicate); // produces a failure if predicate is false, but continues testing\nBOOST_REQUIRE(predicate); // produces a failure if predicate is false and aborts test suite.\n\n\n\n\nExample\n\n\nfile: modules/mymodule/test/test.cpp\n\n\n#define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE TestSuiteName\n#include \nboost/test/unit_test.hpp\n\n#include \nfoo.h\n // declares type foo, header is in the core module\n\nBOOST_AUTO_TEST_CASE(TestName) {\n    foo bar;\n    BOOST_CHECK(foo.baz());\n}\n\n\n\n\nfile: modules/mymodule/test/CMakeLists.txt\n\n\ninclude_directories(${Core_INCLUDE_DIR})\nadd_executable(mytest test.cpp)\ntarget_link_libraries(mytest Core)\n\n# Tests\nadd_test(\n    NAME \nexample test\n\n    COMMAND mytest\n)", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/#writing-tests", 
            "text": "Testing should be done in a directory inside the submodule called test, which should be included in the module's CMakeLists.txt via add_subdirectory and should have its own CMakeLists.txt.\nFurthermore, large test files should be stored in the global computer-vision/testdata directory so that they can be shared between multiple tests.\nThat is, test directories should have the following structure  |-- computer-vision\n    |-- modules\n        |-- MODULE_NAME\n            |-- include\n            |-- src\n            |-- test\n                |-- CMakeLists.txt\n                |-- foo_test.cpp\n                |-- bar_test.cpp\n            |-- CMakeLists.txt\n    |-- testdata\n        |-- image.jpg  Testing should be done using the boost test framework.  Tutorials provided by boost are found  here .  API Reference available  here  To test code it should be run inside the BOOST_AUTO_TEST_CASE and use the boost test macros to verify sanity and results.\nSome available macros include  BOOST_WARN(predicate); // produces a warning if predicate is false, does not cause failures\nBOOST_CHECK(predicate); // produces a failure if predicate is false, but continues testing\nBOOST_REQUIRE(predicate); // produces a failure if predicate is false and aborts test suite.", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/computer-vision/Writing-Tests/#example", 
            "text": "file: modules/mymodule/test/test.cpp  #define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE TestSuiteName\n#include  boost/test/unit_test.hpp \n#include  foo.h  // declares type foo, header is in the core module\n\nBOOST_AUTO_TEST_CASE(TestName) {\n    foo bar;\n    BOOST_CHECK(foo.baz());\n}  file: modules/mymodule/test/CMakeLists.txt  include_directories(${Core_INCLUDE_DIR})\nadd_executable(mytest test.cpp)\ntarget_link_libraries(mytest Core)\n\n# Tests\nadd_test(\n    NAME  example test \n    COMMAND mytest\n)", 
            "title": "Example"
        }, 
        {
            "location": "/bootcamp/mechanical/", 
            "text": "WARG Mechanical Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nMake justified mechanical design decisions based on project constraints and criteria\n\n\nLearn to take accurate measurements of parts using vernier callipers\n\n\nLearn CAD design in SolidWorks\n\n\nLearn how to make assemblies in SolidWorks\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Two-Axis Camera Gimbal:\n\n\nBackground\n\n\nA camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.\n\n\nTask\n\n\nYou are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of \nmm and g\n. If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed \npart files and assembly file\n to a Team Lead for evaluation.\n\n\nProject Checklist\n\n\n\n\nParts made in SolidWorks using dimensions of mm and g\n\n\nGoPro Case measured with power button exposed\n\n\nMounting method using 4 M4 bolts to the flat board\n\n\nMotors / Servos selected and modeled (if required)\n\n\nAssembly created with the gimbal able to rotate 360 degrees in both axis\n\n\n\n\nUsing Solidworks\n\n\nThere are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Mechanical"
        }, 
        {
            "location": "/bootcamp/mechanical/#warg-mechanical-bootcamp", 
            "text": "", 
            "title": "WARG Mechanical Bootcamp"
        }, 
        {
            "location": "/bootcamp/mechanical/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/mechanical/#bootcamp-objectives", 
            "text": "Make justified mechanical design decisions based on project constraints and criteria  Learn to take accurate measurements of parts using vernier callipers  Learn CAD design in SolidWorks  Learn how to make assemblies in SolidWorks", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/mechanical/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/mechanical/#1-two-axis-camera-gimbal", 
            "text": "", 
            "title": "1. Two-Axis Camera Gimbal:"
        }, 
        {
            "location": "/bootcamp/mechanical/#background", 
            "text": "A camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/mechanical/#task", 
            "text": "You are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of  mm and g . If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed  part files and assembly file  to a Team Lead for evaluation.", 
            "title": "Task"
        }, 
        {
            "location": "/bootcamp/mechanical/#project-checklist", 
            "text": "Parts made in SolidWorks using dimensions of mm and g  GoPro Case measured with power button exposed  Mounting method using 4 M4 bolts to the flat board  Motors / Servos selected and modeled (if required)  Assembly created with the gimbal able to rotate 360 degrees in both axis", 
            "title": "Project Checklist"
        }, 
        {
            "location": "/bootcamp/mechanical/#using-solidworks", 
            "text": "There are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.", 
            "title": "Using Solidworks"
        }, 
        {
            "location": "/bootcamp/mechanical/#2-previous-team-contribution", 
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/mechanical/#completion-of-bootcamp", 
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/bootcamp/computer-vision/", 
            "text": "Computer-Vision Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve and to familiarize you with our system and conventions. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with the main software project! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\n1. Fork and Setup Local Project\n\n\nForks can be created using the fork button in the top right of the Github Interface (you need to be signed into a Github account).\n\n\nClone your fork with either:\n\n\ngit clone git@github.com:YOUR_USERNAME_HERE/computer-vision-bootcamp.git\n\n\n\n\nif you want to use ssh\nor\n\n\ngit clone https://github.com/YOUR_USERNAME_HERE/computer-vision-bootcamp.git\n\n\n\n\nfor https\n\n\nNote that you will need to have CMake installed so that you can build your module once you've written it.\n\n\n2. Choose a Task\n\n\nYour task is to write a module that detects and identifies objects in an image.\n\n\nFor this you will need to install and familiarize yourself with OpenCV\nYou will also need Boost and CMake.\nThe OpenCV documentation contains a \nset of tutorials\n which you may find useful.\n\n\nA note on OpenCV if you are not using our prebuilt docker image\n\n\nThe most recent OpenCV major release, OpenCV 3.x, is not yet generally available in package repositories due to the update breaking a large number of packages downstream. This means that you will have to build and install OpenCV 3.x manually.\nThe computer vision project uses OpenCV 3.0 or newer, and it is recommended that you use it if possible, but if you run into difficulties getting it to work, feel free to use OpenCV 2.4.x for the bootcamp.\n\n\n3. Implement\n\n\nSpecifically, your code must contain a class or function which, when given an image (in the form of a \ncv::Mat\n) returns a set of data structures detailing the locations of distinct objects in the image as well as optionally any other information you wish to include (e.g. colour of the object).\n\n\nThe object detection can be simple (i.e, identifying objects of solid colour on a blank background), or more complicated if you wish.\n\n\nBe Wary of the fact that this will get much more difficult and time consuming when trying to do something more complex.\nIt is Strongly recommended to start with something very simple, submit it, and if you want to add complexity, do so while you are waiting for it to be reviewed.\n\n\nYour code must be implemented as a submodule and must:\n\n\n\n\nFollow our \nstyle guide\n\n\nBuild using CMake\n\n\nBe well documented using doxygen-formatted comments\n\n\nBe tested using our \ntesting framework\n. Note that in the core module of the bootcamp project there is a contour comparison function that can be used to compare the results of OpenCV edge detection algorithms to manually created vectors of points for the purposes of testing.\n\n\n\n\nSee \ncontributing\n for an example and more information.\n\n\nYou are also welcome to implement something different if you want, but please run your idea by a computer-vision lead first.\n\n\n4. Submit\n\n\nTo submit your bootcamp project you should create a pull request. Note that this does not mean you are done, we will review your pull request and give you feedback and you will be expected to update it so that if meets all requirements.\n\n\nOnce your pull request has been merged you are ready to work on the Computer Vision project.", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/bootcamp/computer-vision/#computer-vision-bootcamp", 
            "text": "", 
            "title": "Computer-Vision Bootcamp"
        }, 
        {
            "location": "/bootcamp/computer-vision/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve and to familiarize you with our system and conventions. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with the main software project! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/computer-vision/#1-fork-and-setup-local-project", 
            "text": "Forks can be created using the fork button in the top right of the Github Interface (you need to be signed into a Github account).  Clone your fork with either:  git clone git@github.com:YOUR_USERNAME_HERE/computer-vision-bootcamp.git  if you want to use ssh\nor  git clone https://github.com/YOUR_USERNAME_HERE/computer-vision-bootcamp.git  for https  Note that you will need to have CMake installed so that you can build your module once you've written it.", 
            "title": "1. Fork and Setup Local Project"
        }, 
        {
            "location": "/bootcamp/computer-vision/#2-choose-a-task", 
            "text": "Your task is to write a module that detects and identifies objects in an image.  For this you will need to install and familiarize yourself with OpenCV\nYou will also need Boost and CMake.\nThe OpenCV documentation contains a  set of tutorials  which you may find useful.", 
            "title": "2. Choose a Task"
        }, 
        {
            "location": "/bootcamp/computer-vision/#a-note-on-opencv-if-you-are-not-using-our-prebuilt-docker-image", 
            "text": "The most recent OpenCV major release, OpenCV 3.x, is not yet generally available in package repositories due to the update breaking a large number of packages downstream. This means that you will have to build and install OpenCV 3.x manually.\nThe computer vision project uses OpenCV 3.0 or newer, and it is recommended that you use it if possible, but if you run into difficulties getting it to work, feel free to use OpenCV 2.4.x for the bootcamp.", 
            "title": "A note on OpenCV if you are not using our prebuilt docker image"
        }, 
        {
            "location": "/bootcamp/computer-vision/#3-implement", 
            "text": "Specifically, your code must contain a class or function which, when given an image (in the form of a  cv::Mat ) returns a set of data structures detailing the locations of distinct objects in the image as well as optionally any other information you wish to include (e.g. colour of the object).  The object detection can be simple (i.e, identifying objects of solid colour on a blank background), or more complicated if you wish.  Be Wary of the fact that this will get much more difficult and time consuming when trying to do something more complex.\nIt is Strongly recommended to start with something very simple, submit it, and if you want to add complexity, do so while you are waiting for it to be reviewed.  Your code must be implemented as a submodule and must:   Follow our  style guide  Build using CMake  Be well documented using doxygen-formatted comments  Be tested using our  testing framework . Note that in the core module of the bootcamp project there is a contour comparison function that can be used to compare the results of OpenCV edge detection algorithms to manually created vectors of points for the purposes of testing.   See  contributing  for an example and more information.  You are also welcome to implement something different if you want, but please run your idea by a computer-vision lead first.", 
            "title": "3. Implement"
        }, 
        {
            "location": "/bootcamp/computer-vision/#4-submit", 
            "text": "To submit your bootcamp project you should create a pull request. Note that this does not mean you are done, we will review your pull request and give you feedback and you will be expected to update it so that if meets all requirements.  Once your pull request has been merged you are ready to work on the Computer Vision project.", 
            "title": "4. Submit"
        }, 
        {
            "location": "/bootcamp/electrical/", 
            "text": "\ufeff\n\n\nWARG Electrical Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nLearn how to make a PCB board.\n\n\nLearn basic computer-aided circuit design principles.\n\n\nLearn where to find documentation and how to understand it.\n\n\nLearn about basic circuit design\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Tracking Antenna Power Circuit\n\n\nBackground\n\n\nThe tracking antenna helps to ensure our ground station keeps in contact with the plane at all times by pointing antennas at the plane, using data from the ground station. To do this, the tracking antenna has 2 servos that point the antennas, an arduino to do computations and basic control, and multiple sensors to help in calibration. \nThe power circuit allows the antenna to be powered by either a battery or from a power cable, and simplifies the wiring to the servos and arduino.\n\n\nTask\n\n\nYour task is to design a PCB using DipTrace which will be able to take power from a battery or power cable.  If both battery and power cable are connected, it should default towards the power cable. It will have pin connections for the 2 servos (pan and tilt) and the arduino (5V, GND, and a PWM signal for each servo). To save money, design the PCB as small as possible. There will also be multiple LED indicators to show the circuit is working.\n\n\nThe example schematic is at the bottom of this page. You can copy it directly, make some improvements, or design your own.  \n\n\nNote: We are not actually printing this circuit due to the cost and time constraints.\n\n\nInputs, Outputs, and LEDs\n\n\n\n\n3-wire PWM cable for pan servo\n\n\n3-wire PWM cable for tilt servo\n\n\n4 female pins for arduino wires (5V, GND, Pan, and Tilt)\n\n\nJST battery connector (input power)\n\n\nDC 5.5mm barrel jack (9-12V input power)\n\n\nLED indicator to indicate the board is powered\n\n\n\n\nProject Checklist\n\n\n\n\nSchematic, PCB, and parts list\n\n\nInputs and outputs listed above\n\n\nCircuit elements (MOSFET and Voltage regulator) that regulate power and can switch between the two sources\n\n\nIf both power elements are plugged in, it defaults to the power cable\n\n\nLabels to define inputs, outputs, and component placements\n\n\nTraces are adequately sized and well routed\n\n\n\n\nUsing DipTrace\n\n\nGo to this link and download the freeware:\n\nhttp://diptrace.com/download-diptrace/\n\n\nIf you need help with using the CAD software, here are some resources:\n\n\nDiptrace Tutorial: \nhttp://diptrace.com/support/tutorials/\n\n\nSchematics: \nhttps://www.youtube.com/watch?v=uCPUqXFvUZU\n\n\nPCB Layout: \nhttps://www.youtube.com/watch?v=kw51rlCTYBY\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nShow a team lead the schematic, PCB, and parts list files. Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Electrical"
        }, 
        {
            "location": "/bootcamp/electrical/#warg-electrical-bootcamp", 
            "text": "", 
            "title": "WARG Electrical Bootcamp"
        }, 
        {
            "location": "/bootcamp/electrical/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/electrical/#bootcamp-objectives", 
            "text": "Learn how to make a PCB board.  Learn basic computer-aided circuit design principles.  Learn where to find documentation and how to understand it.  Learn about basic circuit design", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/electrical/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/electrical/#1-tracking-antenna-power-circuit", 
            "text": "", 
            "title": "1. Tracking Antenna Power Circuit"
        }, 
        {
            "location": "/bootcamp/electrical/#background", 
            "text": "The tracking antenna helps to ensure our ground station keeps in contact with the plane at all times by pointing antennas at the plane, using data from the ground station. To do this, the tracking antenna has 2 servos that point the antennas, an arduino to do computations and basic control, and multiple sensors to help in calibration. \nThe power circuit allows the antenna to be powered by either a battery or from a power cable, and simplifies the wiring to the servos and arduino.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/electrical/#task", 
            "text": "Your task is to design a PCB using DipTrace which will be able to take power from a battery or power cable.  If both battery and power cable are connected, it should default towards the power cable. It will have pin connections for the 2 servos (pan and tilt) and the arduino (5V, GND, and a PWM signal for each servo). To save money, design the PCB as small as possible. There will also be multiple LED indicators to show the circuit is working.  The example schematic is at the bottom of this page. You can copy it directly, make some improvements, or design your own.    Note: We are not actually printing this circuit due to the cost and time constraints.", 
            "title": "Task"
        }, 
        {
            "location": "/bootcamp/electrical/#inputs-outputs-and-leds", 
            "text": "3-wire PWM cable for pan servo  3-wire PWM cable for tilt servo  4 female pins for arduino wires (5V, GND, Pan, and Tilt)  JST battery connector (input power)  DC 5.5mm barrel jack (9-12V input power)  LED indicator to indicate the board is powered", 
            "title": "Inputs, Outputs, and LEDs"
        }, 
        {
            "location": "/bootcamp/electrical/#project-checklist", 
            "text": "Schematic, PCB, and parts list  Inputs and outputs listed above  Circuit elements (MOSFET and Voltage regulator) that regulate power and can switch between the two sources  If both power elements are plugged in, it defaults to the power cable  Labels to define inputs, outputs, and component placements  Traces are adequately sized and well routed", 
            "title": "Project Checklist"
        }, 
        {
            "location": "/bootcamp/electrical/#using-diptrace", 
            "text": "Go to this link and download the freeware: http://diptrace.com/download-diptrace/  If you need help with using the CAD software, here are some resources:  Diptrace Tutorial:  http://diptrace.com/support/tutorials/  Schematics:  https://www.youtube.com/watch?v=uCPUqXFvUZU  PCB Layout:  https://www.youtube.com/watch?v=kw51rlCTYBY", 
            "title": "Using DipTrace"
        }, 
        {
            "location": "/bootcamp/electrical/#2-previous-team-contribution", 
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/electrical/#completion-of-bootcamp", 
            "text": "Show a team lead the schematic, PCB, and parts list files. Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/bootcamp/rccompetition/", 
            "text": "RC Car Competition\n\n\nDesigned by Students, For Students\n\n\n\n\nCompetition Sign Up Deadline\n : Continuous\u2026. Come Join!\n\n\nCompetition Showcase Date:\n Saturday March 21\n\n\nst\n\n\n2014 (Tentative)\n\n\nThe Waterloo Aerial Robotics Group \u2013 RC Car Competition\n\n\nBackground\n\n\nThe goal of the RC Car competition is to motivate potential recruits to participate in the normal activities of the Waterloo Aerial Robotics Group (WARG). The team leads of WARG have come to realize that it can be difficult for recruits to immediately jump into the day-to-day activities of WARG without having any prior knowledge or experience with the technology. It's a very common occurrence for new recruits to come to the team with very little to no knowledge of the skills needed to immediately contribute, but WARG has a fundamental goal of teaching any student the skills, if they wish to learn.\n\n\nThis competition has been developed by WARG as a tool to teach students about the following:\n\n\n\n\n\uf0b7\uf0b7Basic Programming Skills\n\n\n\uf0b7\uf0b7Control Theory\n\n\n\uf0b7\uf0b7Problem Solving\n\n\n\uf0b7\uf0b7Gain Tuning (Stabilizing a Controlled System)\n\n\n\uf0b7\uf0b7Path Following and Path Planning\n\n\n\n\nAt the end of the competition, it is WARG's goal that each participating student has learned how to perform a majority of the topics listed above. The competition has been designed to guide the recruits through the process, and for this reason, each phase of the competition relies on the previous phase to a certain extent. In other words, as the recruit proceeds through each phase of the competition, they are in fact building further upon their control program. Once the last phase is reached, the recruit should have a fully functional control program. How well this program functions will be based on the recruits time, effort, and general understanding of the skills WARG is trying to teach over the course of the competition.\n\n\nFurthermore, the skills that students develop while participating in this competition can be immediately transferred to the normal activities of WARG. As well, these newly acquired skills can be advertised by the students during interviews, where they can inform the employer on what they've accomplished while participating in the competition.\n\n\nThe end goal of the competition is to develop a program that will make the RC Car autonomously follow a predetermined path. This is in fact exactly what is done by our airplane (SPIKE) in order to complete its competition. Our aircraft can always be improved upon, and it is our hope that students become interested in assisting the team with the skills they acquire through this competition.\n\n\nRegistration Fee\n\n\n*** There will be a $5 fee in order to sign up for the competition, but the amount of money gathered by WARG will simply be put back to the participating students registered in the competition. To be an \"official\" member of WARG, the constitution of the team states that each member must pay an initial $5 fee. In order to incorporate this fee, as well as make the competition day a little more enticing, WARG is using this collection for the sole purpose of buying items such as pizza, pop, snacks, etc. for the final Competition Showcase Day.\n\n\nThe Competition\n\n\nIn teams of 3 or 4 (ideally), students will compete to control a remote control (RC) car that has been outfitted by WARG to have autonomous capabilities. Each team will be competing against the others for a prize pool (prizes to be determined and announced based on participation), where the top 3 teams will be rewarded respectively.\n\n\n* Note that individual sign up is more than welcome, and teams of individuals will be generated\n\n\nThe competition will be graded as follows:\n\n\n\n\n\n\n\n\nPhase\n\n\nTask\n\n\nSkills Acquired\n\n\nWeighting\n\n\n\n\n\n\n\n\n\n\nl\n\n\n-Drive Forward 10sec-Drive Backward 10sec-Turn Right 10sec-Turn Left 10sec\n\n\nCan you \ncall\n a function?Can you make a loop?\n\n\n2.5% each(10% total)\n\n\n\n\n\n\nll\n\n\n-Drive Forward 10m-Drive Backward 10m\n\n\nCan you \nmake\n a function?\n\n\n5% each(10% total)\n\n\n\n\n\n\nlll\n\n\n-Drive Forward 5m,   then Turn Right 90 degrees   then Turn Left 90 degrees\n\n\nCan you think in terms of Heading?\n\n\n15%\n\n\n\n\n\n\nlV\n\n\n-Drive a Straight Line   while Maintaining Heading   Stop after _(100)_m\n\n\nCan you put everything together and create a Control Program?\n\n\n15%\n\n\n\n\n\n\nV\n\n\n-Drive from Point A to Point B   Stop within a _(5)_m Radius\n\n\n15%\n\n\n\n\n\n\n\n\nVl\n\n\nFollow _(10)_ Waypoints\n\n\n35%\n\n\n\n\n\n\n\n\n\n\nNotes:\n\n\n\n\n--Basic programming concepts will be explained to new recruits in order to help them succeed\n\n\n--Values given in the _(Value)_ form are tentative and subject to change\n\n\n--Phases 1 and 3: marks are awarded based on performance of the described task, not preciseness to the defined values (i.e. if you turn further than 90deg we will not punish you, but you must turn at least 90deg)\n\n\n--Phases 2, 4, 5, 6, 7, 8: will be marked based on your team's error, relative to the other teams\n\n\n--The system has been set up to relay GPS information back to WARG, we will use this information to determine your error in accordance to the given task. This eliminates discrepancy with regards to GPS drift (i.e. if we were to mark a GPS coordinate on the ground and say \"go here,\" the GPS may think that spot is in two different locations based on the number of satellites it has at that given time)\n\n\n\n\nTerminology:\n\n\n\n\n--Heading: a 360 degree value of the direction to North (basically like a compass with N = 0deg and 360deg, E = 90deg, S = 180deg, and W = 270deg)\n\n\n--Waypoint: a GPS coordinate described by a Latitude and a Longitude\n\n\n\n\nWhat You Need To Know\n\n\nThere are a few things you'll need to know and understand (other than basic programming concepts) in order to control the RC Car.\n\n\nWhat to Download\n\n\nWARG has created presentational step-by-step presentations to help you setup the programs needed:\n\n\nMPLAB X:  (required)\n\n\nhttps://docs.google.com/presentation/d/1XvRea8qPeCgIOqU_4q_P-z-q1EOupfJyO801Is2gDz4/edit?usp=sharing\n\n\nThis is the IDE used to program the chip on the RC Car\n\n\nGithub:\n  \n(optional)\n\n\nhttps://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing\n\n\n*Please note that the Github presenation presentation might be out of date, but the same concepts will apply in order to get it setup on your system. Contrary, you might not need to download the desktop client, and can simple get the RC-Car-Bootstrap-Competition project as a .ZIP, in which case you can place it where you want and open the Project from MPLAB.\n\n\n*If you choose to use Github, you DO NOT need a UWARG member to add you to the group. Since the project is Public, anyone can view and download the RC-Car-Bootstrap in order to start programming. See the next section for instructions on how to do so.\n\n\nWhere to Get the Code (GitHub)\n\n\nThe following link is where you can download the base project for the RC Car Competition:\n\n\nhttps://github.com/UWARG/RC-Car-Bootstrap-Competition\n\n\nOn the right side of the screen, select \"Download ZIP.\" Place the unzipped folder somewhere on your computer for you to access. Open this folder as a Project in MPLAB X, and you should be ready to start coding.\n\n\n*Note: A presentation may be created later to teach people how to use MPLAB X, but if you start typing some code and want to test that it compiles (i.e. you've created correct code), then you may press the \"Build \n Clean\" button to initially test the program. It should tell you if there are any errors with your code, or something that it doesn't understand.\n\n\nFunctionality Developed by WARG for You to Use\n\n\nWARG has developed a bunch of functions that perform hardware communication with the car. This means that the recruits do not need to understand how to truly talk to the devices, but instead can program the system at a much higher level. What this means is something similar to the following comparison. Somebody tells you to shout \"Hello!\" You don't truly think about the fact that all those fancy biology components in your body are doing things, and somehow in the end\u2026. magical noise comes from your mouth. What happened is that somebody gave you a command at a \"higher level,\" your brain then took that command and did the appropriate things without you truly knowing what's going on, in order to make \"Hello!\" come from your mouth. Might be a weird analogy yes, but that's similar to what's going on in the code.\n\n\nWARG has given you the following functions to work with. They must have the specified inputs, and they perform the specified actions:\n\n\nsetSteering(int percent);\n\n\nThis function does exactly what you think it does. It takes an int value input ranging from -100 to 100.    With -100 turning the wheels fully to the left, and 100 turning the wheels fully to the right.\n\n\nsetThrottle(int percent);\n\n\nThis function does exactly what you think it does. It takes an int value input ranging from -100 to 100. With -100 being full speed in reverse, and 100 being full speed forward.\n\n\ngetTime();\n\n\nThis function returns the time in milliseconds as type \nlong int\n, the function takes no inputs.\n\n\nYou are also given a struct to work with that holds and updates all of the appropriate GPS Data. In order to access this information, simply type \"GPS.______\" where the ____ is filled appropriately as follows:\n\n\nGPS.latitude;     // the current latitude as type \nlong double\n\n\nGPS.longitude;     // the current latitude as type \nlong double\n\n\nGPS.speed;           // the current ground speed as type \nfloat\n\n\nGPS.heading;       // the current heading as type \nint\n\n\nGPS.satellites;     // the current number of satellites as type \nchar\n\n\nGPS.positionFix;  // if there is a position fix or not as type \nchar\n\n\nGPS.altitude;        // the current altitude as type \nint\n\n\nWhere You Program in the Code\n\n\nWhen you download all of the required programs, and get the RC-Car-Bootstrap from Github, you will see the following code segment in the main.c file.\n\n\n\n\nYou will notice that there is already some code in the main body\u2026. YOU MUST LEAVE THIS THERE.\n\n\nThe code that exists is there to initialize the system and ensure it is running properly. As well, it performs all of our background tasks that send data do us about what your system is doing at the moment. All of your code must take place after \"setSteering(0);\" and before \"background();.\" Please note that this is meant by your code in the main function of your program, later on in the phases, you will be required to develop your own functions, which must be developed outside of this main.\n\n\nAspects of Programming (Super Simplified)\n\n\n***WARNING: THIS SECTION IS NOT COMPLETED, AND YOU'LL NEED TO KNOW A FEW MORE THINGS THAN WHAT IS DESCRIBED HERE. FOLLOW THE PROVIDED TUTORIAL LINKS TO HELP YOU LEARN FOR THE TIME BEING.\n\n\nFor any recruit who is nervous, unsure, or thinking twice about joining the competition due to not having prior (or having minimal) knowledge of programming, WARG would like to motivate you to get past that fear. SO GET MOTIVATED!!!\n\n\nProgramming may take a little bit in order for the concepts to finally \"click,\" but once you grasp it\u2026     \u2026it all seems so simple\n\n\nYou will be programming in a language known as C. Just as there are multiple verbal languages (i.e. English, French, Spanish, etc.), there are a bunch of programming languages. These programming languages are a lot easier to transition between and pick up if you know one of the languages, in comparison to verbal languages.\n\n\nMoving on, here is a REALLY REALLY simplified generalization of some programming concepts.\n\n\nVariables\n\n\nYou can think of variables just like the ones you'd use in math, by this we mean that they can be seen as \"place holders\" for a value. Meaning that in math you may declare:\n\n\n\"Let x be the number of apples Brian has on Monday\"\n\n\nVariables in programming are similar, and are place holders for actual values. These values are hidden away and saved somewhere in the microchip (in memory\u2026. but we don't need to know about this right now). Here are a couple examples of variable \ntypes\n:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nint\n\n\nCan be thought of as a \nwhole\n number, or a number \nwithout\n decimals\n\n\n1,  16,  3054\n\n\n\n\n\n\nfloat\n\n\nCan be thought of as a number \nwith\n decimals\n\n\n1.02,  506.23579\n\n\n\n\n\n\n\n\nYou totally thought the list was going to be longer didn't you. Well, technically it is quite a bit larger yes, but in all honesty you could write the whole code for the competition using just these variables and you would be fine. With that said, you might want to utilize something known as an \nArray\n. An array can be thought of as a list of a certain type of variable. If you want to save data on a few things that may relate, or be of similar characteristic, to one another\u2026 you may want to put them into a list.\n\n\nIn order to initialize your variables in your program, you would do as such:\n\n\nint x = 0;    //This means that you've declared a new variable \"x\", that is of type int, and has starting value 0\n\n\nfloat myFloat = 2.34; //a new variable \"myFloat\", of type float, with starting value 2.34\n\n\nint myArray[5];  //Declaration of an array (un-initialized)\u2026\n\n\n\u2026This means that you've declared an array of 5 int variables (i.e. there is a list of 5 int's), you've called this array \"myArray\", and you did not initialize the values to anything\n\n\nYou would then later access individual members of the array by doing the following:\n\n\nmyArray[0] = 8; //This sets the first member in the list to hold a value of 8\n\n\nPiece of cake right? No? Well that's ok, because it took some of the Lead members of WARG a little while to truly get a grasp as well.\n\n\n*** Obviously there's more to programming then just declaring variables, and WARG is currently in the process of writing this document to better help recruits get involved! For the time being, please look at the following tutorials online regarding basic C programming. There's lots of things on the internet if you use that thing\u2026. what are the kids calling it? \"The Google?\"\n\n\nYou'll need to know about \"if\" statements, \"while\" loops, and possible \"for\" loops in order to successfully complete the phases in the competition. Here are a few useful links to help you:\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson1.html\n  -- Specifically:\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson2.html\n  // if statements\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson3.html\n  // looping\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson4.html\n  // functions\n\n\nOr more importantly for now (considering we're still developing this document), in order to be a part of any student team, you need to be able to research. Therefore the following is the most important link we can give you: \nhttp://lmgtfy.com/?q=c+tutorial\n\n\nPhase Definitions\n\n\nThis section of the document is meant to further define what is required, and expected for each Phase of the competition.\n\n\nPhase I\n\n\nPurpose:\n\n\nAllow recruits to get acquainted with a very simple program, and how the process works to program the RC Car. The recruits will need to call functions that have been premade for them, and make a simple loop.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward for 10 seconds\n\n\n\uf0b7\uf0b7Drive Backward for 10 seconds\n\n\n\uf0b7\uf0b7Turn Right for 10 seconds\n\n\n\uf0b7\uf0b7Turn Left for 10 seconds\n\n\n\n\nExplanation:\n\n\nThis phase should not require further explanation in order to get a grasp on what's required. By defining a few variables, and using the pre-made functions given to use, the recruit should be able to create a program that performs the above tasks.\n\n\nEvaluation and Weighting:  \n 10% in total for the phase\n\n\n2.5% will be given per each of the 4 tasks\n\n\nIt is simply expected that the car moves in the appropriate direction for the given time period. The car does not need to stop \"spot on\" the 10 second mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.\n\n\nPhase II\n\n\nPurpose:\n\n\nThe initial purpose of this phase is to have the recruits create a new function from scratch. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward 10 meters\n\n\n\uf0b7\uf0b7Drive Backward 10 meters\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create their own function in order to determine the distance travelled from the car's current position, to a start point (or previous waypoint).\n\n\nYour function definition should pass in latitude and longitude values of the GPS coordinates (2 sets, one for point 'A' and one for point 'B'). The following website gives you a pretty good layout of how your code should look (to some extent, it will look different due to you programming in C and not Java Script). Specifically the following code bite as well:\n\n\nhttp://www.movable-type.co.uk/scripts/latlong.html\n\n\n\n\nAbove is the formula you must program into your function.\n\n\nBelow is how the created such a function with Java Script. *** Your function should return a float of \"d\"\n\n\n\n\nvar R =6371;// km\n\n\nvar\u03c61= lat1.toRadians();\n\n\nvar\u03c62= lat2.toRadians();\n\n\nvar\u0394\u03c6=(lat2-lat1).toRadians();\n\n\nvar\u0394\u03bb=(lon2-lon1).toRadians();\n\n\nvar a =Math.sin(\u0394\u03c6/2)*Math.sin(\u0394\u03c6/2)+\n\n\n    Math.cos(\u03c61)\\*Math.cos(\u03c62)\\*\n\n    Math.sin(\u0394\u03bb/2)\\*Math.sin(\u0394\u03bb/2);\n\n\n\nvar c =2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));\n\n\nvar d = R * c;\n\n\n\n\nThe only addition you must make to this code (besides writing it correctly for your C program), is to multiple the \"c\" value above by \u00b11000. Is needed to convert kilometers into meters.\n\n\nEvaluation and Weighting:  \n 10% in total for the phase\n\n\n5% will be given per each of the 2 tasks\n\n\nInitially, it is simply expected that the car moves in the appropriate direction for the given distance. The car does not need to stop \"spot on\" the 10 meter mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.\n\n\nFurthermore, out of the 5% given towards either task, a weighting of 4% will be achieved by implementing the functionality described in the previous paragraph. The additional 1% will be achieved based on error to the 10m mark. In order to reach the 10m as close as possible, the recruit must implement proper Control Theory in order to slow the car down and receive the extra weighting. The code cannot be written to simply reverse the car for a millisecond after reaching the 10m mark, as this harms the equipment and decreases its lifespan. You may not reverse back to the 10m mark either if you have passed it. Additionally, in order to achieve this extra weighting (and so that WARG can see your control loop is working correctly), the RC Car must be started at an initial throttle of _(40)_%. The weighting will be received based on error in comparison to the top team for this phase (team closest to the 10m mark).\n\n\nPlease note that the control theory aspect will be learned in later phases of the competition. The \"closeness\" to the 10m mark is worth only 1% since it is WARG's desire that all teams initially develop the code well enough to accomplish the initial 4% of this phase for each task. If teams finish the majority of the competition, and after learning control theory, they may return back to this phase in order to try and receive the addition 1%.\n\n\nPhase III\n\n\nPurpose:\n\n\nThe initial purpose of this phase is to have the recruits begin to think in terms of heading, and how it relates to controlling the steering of the car. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward 5 meters, then\n\n\nooTurn Right 90 degrees, then\n\n\nooTurn Left 90 degrees\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create their own functionality in order to determine which direction to steer the car at any given point in time. The car may bounce around, and therefore move off of the desired path. Since we are constantly checking the state of the car (by continuously looping through the entire code), we can determine which way to steer the car at any point in time. It is recommended that this functionality be developed in the form of a function.\n\n\nAt no point during this phase should the car come to a stop while transitioning between task objectives. The desire is that the car drives a smooth path. For this reason, the car should never operate under _(20)_% throttle while transitioning between task objectives. The car may only be controlled to a complete stop once you are completed the phase in the \"Turn Left 90 degrees\" sub-task. Again, the car may never be driven backwards, and must always be moving forwards.\n\n\nEvaluation and Weighting:  \n 15% in total for the phase\n\n\n12% will be given for initially achieving the tasks above by going (at minimum) the distance or angle change that's stated.\n\n\nInitially it is WARG's desire that the recruit moves on after achieving this initial functionality, and returns back at a later time to improve upon the phase's functionality. The additional 3% will be achieved similarly to the methods described in Phase II, in the same manner that the additional 1% is achieved.\n\n\nPhase IV\n\n\nPurpose:\n\n\nThe purpose of this phase is for the recruit to put all of the functionality they've developed together, and create a simple control loop.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive a straight line\n\n\nooWhile maintaining heading\n\n\nooStop after _(100)_m\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create a control loop that will steer the car accordingly and keep it on the desired path. This involves monitoring the heading of the car, and steering the car in the appropriate direction if it starts to stray from the desired path. A heading a starting direction will be determined by WARG based on the competition testing location (the heading to hold will be hardcoded into the recruits program ahead of time, since at this point we are not expecting anything that calculates which heading should be held).\n\n\nYou will notice that if you turn the car too much in a given direction when it strays off the path, it will quickly be weaving back and forth on the path, and the amplitude of this \"weave\" will increase overtime. This is because you must \nconverge\n towards the desired path, rather than do a jerking turn that makes the car immediately be on the path. The rate at which you turn the steering, relative to your distance from the path, is controlled through the \ncontrol loop\n, and by tuning the gains appropriately to fit your system (in this case the system is the RC Car).\n\n\nPlease refer to the \nControl Theory\n section in order to gain more knowledge on how to create a control loop. As well, WARG is considering bring in lecturers in order to host short lectures / tutorials on these concepts. This will be done based on the interest of the students.\n\n\nEvaluation and Weighting:  \n 15% in total for the phase\n\n\nConsidering that we do not expect the car to stray to too far from the desired path (there are no strong winds pushing the car off its path, such as that which occurs with the airplane while in the air), we do not expect the error from the path to be very large at all. Even if the recruit poorly tuned that control loops / gains, we believe the system shouldn't have a problem staying on the desired path.\n\n\nWith this in mind, the 10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error.\n\n\nThe additional 5% of this phase will be calculated based on the recruit's error in distance travelled, in comparison to that of the top team's error. (Hint: this is a controlled stop like that described in Phase II)\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired travel distance of _(100)_m. Again, the car should always be moving forward.\n\n\nPhase V\n\n\nPurpose:\n\n\nThe purpose of this phase is for the recruit to develop dynamic functionality of their code (i.e. not hardcoded values). This phase also has the purpose of developing code that drives the car based on waypoints.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive from Point A to Point B\n\n\nooStop within a _(5)_m radius\n\n\n\n\nExplanation:\n\n\nThe functionality as described in Phase IV should be implemented in this phase in order to better complete the task described.\n\n\nYou'll need to apply some logic into your program and probably create another function to perform basic geometry. In order to find the line (and heading) you must follow, you'll have to generate a xy based system from you latitude / longitude coordinates. You can do this by specifying an anchor point (of latitude longitude, this could possibly be your position on start-up). You can then find your x component, and y component of any given waypoint by holding either your latitude / longitude constant, and sending your anchor, and new waypoint through your getDistance() function.\n\n\nOn competition day, WARG will provide the recruit with a Waypoint to travel to. The program must get its current GPS position (current waypoint), and then calculate a straight line from this current position to the desired waypoint given by WARG. This is the heading that the car must be desired to hold in order to get to the waypoint.\n\n\nWARG will start the car in the opposite (or some determined) direction relative to the goal Waypoint in order to ensure the system is calculating things appropriately.\n\n\n*Hint: The RC Car should calculated which direction to turn in order to be going the appropriate heading the fastest.\n\n\nEvaluation and Weighting:\n   15% in total for the phase\n\n\n10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.\n\n\nThe additional 5% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 5% weighting.\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.\n\n\nPhase VI\n\n\nPurpose:\n\n\nThe purpose of this phase is to combine everything that the recruit has learned in order to make the RC Car follow a dynamic path of waypoints. Two paths of _(10)_ waypoints will be given for the car to follow (the car will follow one path, and then the new waypoints will be programmed, and the second path will be followed).\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Follow a set of _(10)_ Waypoints\n\n\n\n\nExplanation:\n\n\nAt this point in time, WARG hopes that the recruit has learned enough from previous stages in order to accomplish the described task of following a set of _(10)_ waypoints.\n\n\nWaypoint 1 will be the RC Car's current position, the additional 9 waypoints will be provided.\n\n\nEvaluation and Weighting:  \n 35% in total for the phase\n\n\n34% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.\n\n\nThe additional 1% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the final waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 1% weighting.\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.", 
            "title": "RC Car Competition"
        }, 
        {
            "location": "/bootcamp/rccompetition/#rc-car-competition", 
            "text": "", 
            "title": "RC Car Competition"
        }, 
        {
            "location": "/bootcamp/rccompetition/#designed-by-students-for-students", 
            "text": "Competition Sign Up Deadline  : Continuous\u2026. Come Join!  Competition Showcase Date:  Saturday March 21", 
            "title": "Designed by Students, For Students"
        }, 
        {
            "location": "/bootcamp/rccompetition/#st", 
            "text": "2014 (Tentative)  The Waterloo Aerial Robotics Group \u2013 RC Car Competition", 
            "title": "st"
        }, 
        {
            "location": "/bootcamp/rccompetition/#background", 
            "text": "The goal of the RC Car competition is to motivate potential recruits to participate in the normal activities of the Waterloo Aerial Robotics Group (WARG). The team leads of WARG have come to realize that it can be difficult for recruits to immediately jump into the day-to-day activities of WARG without having any prior knowledge or experience with the technology. It's a very common occurrence for new recruits to come to the team with very little to no knowledge of the skills needed to immediately contribute, but WARG has a fundamental goal of teaching any student the skills, if they wish to learn.  This competition has been developed by WARG as a tool to teach students about the following:   \uf0b7\uf0b7Basic Programming Skills  \uf0b7\uf0b7Control Theory  \uf0b7\uf0b7Problem Solving  \uf0b7\uf0b7Gain Tuning (Stabilizing a Controlled System)  \uf0b7\uf0b7Path Following and Path Planning   At the end of the competition, it is WARG's goal that each participating student has learned how to perform a majority of the topics listed above. The competition has been designed to guide the recruits through the process, and for this reason, each phase of the competition relies on the previous phase to a certain extent. In other words, as the recruit proceeds through each phase of the competition, they are in fact building further upon their control program. Once the last phase is reached, the recruit should have a fully functional control program. How well this program functions will be based on the recruits time, effort, and general understanding of the skills WARG is trying to teach over the course of the competition.  Furthermore, the skills that students develop while participating in this competition can be immediately transferred to the normal activities of WARG. As well, these newly acquired skills can be advertised by the students during interviews, where they can inform the employer on what they've accomplished while participating in the competition.  The end goal of the competition is to develop a program that will make the RC Car autonomously follow a predetermined path. This is in fact exactly what is done by our airplane (SPIKE) in order to complete its competition. Our aircraft can always be improved upon, and it is our hope that students become interested in assisting the team with the skills they acquire through this competition.", 
            "title": "Background"
        }, 
        {
            "location": "/bootcamp/rccompetition/#registration-fee", 
            "text": "*** There will be a $5 fee in order to sign up for the competition, but the amount of money gathered by WARG will simply be put back to the participating students registered in the competition. To be an \"official\" member of WARG, the constitution of the team states that each member must pay an initial $5 fee. In order to incorporate this fee, as well as make the competition day a little more enticing, WARG is using this collection for the sole purpose of buying items such as pizza, pop, snacks, etc. for the final Competition Showcase Day.", 
            "title": "Registration Fee"
        }, 
        {
            "location": "/bootcamp/rccompetition/#the-competition", 
            "text": "In teams of 3 or 4 (ideally), students will compete to control a remote control (RC) car that has been outfitted by WARG to have autonomous capabilities. Each team will be competing against the others for a prize pool (prizes to be determined and announced based on participation), where the top 3 teams will be rewarded respectively.  * Note that individual sign up is more than welcome, and teams of individuals will be generated  The competition will be graded as follows:     Phase  Task  Skills Acquired  Weighting      l  -Drive Forward 10sec-Drive Backward 10sec-Turn Right 10sec-Turn Left 10sec  Can you  call  a function?Can you make a loop?  2.5% each(10% total)    ll  -Drive Forward 10m-Drive Backward 10m  Can you  make  a function?  5% each(10% total)    lll  -Drive Forward 5m,   then Turn Right 90 degrees   then Turn Left 90 degrees  Can you think in terms of Heading?  15%    lV  -Drive a Straight Line   while Maintaining Heading   Stop after _(100)_m  Can you put everything together and create a Control Program?  15%    V  -Drive from Point A to Point B   Stop within a _(5)_m Radius  15%     Vl  Follow _(10)_ Waypoints  35%      Notes:   --Basic programming concepts will be explained to new recruits in order to help them succeed  --Values given in the _(Value)_ form are tentative and subject to change  --Phases 1 and 3: marks are awarded based on performance of the described task, not preciseness to the defined values (i.e. if you turn further than 90deg we will not punish you, but you must turn at least 90deg)  --Phases 2, 4, 5, 6, 7, 8: will be marked based on your team's error, relative to the other teams  --The system has been set up to relay GPS information back to WARG, we will use this information to determine your error in accordance to the given task. This eliminates discrepancy with regards to GPS drift (i.e. if we were to mark a GPS coordinate on the ground and say \"go here,\" the GPS may think that spot is in two different locations based on the number of satellites it has at that given time)   Terminology:   --Heading: a 360 degree value of the direction to North (basically like a compass with N = 0deg and 360deg, E = 90deg, S = 180deg, and W = 270deg)  --Waypoint: a GPS coordinate described by a Latitude and a Longitude", 
            "title": "The Competition"
        }, 
        {
            "location": "/bootcamp/rccompetition/#what-you-need-to-know", 
            "text": "There are a few things you'll need to know and understand (other than basic programming concepts) in order to control the RC Car.", 
            "title": "What You Need To Know"
        }, 
        {
            "location": "/bootcamp/rccompetition/#what-to-download", 
            "text": "WARG has created presentational step-by-step presentations to help you setup the programs needed:  MPLAB X:  (required)  https://docs.google.com/presentation/d/1XvRea8qPeCgIOqU_4q_P-z-q1EOupfJyO801Is2gDz4/edit?usp=sharing  This is the IDE used to program the chip on the RC Car  Github:    (optional)  https://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing  *Please note that the Github presenation presentation might be out of date, but the same concepts will apply in order to get it setup on your system. Contrary, you might not need to download the desktop client, and can simple get the RC-Car-Bootstrap-Competition project as a .ZIP, in which case you can place it where you want and open the Project from MPLAB.  *If you choose to use Github, you DO NOT need a UWARG member to add you to the group. Since the project is Public, anyone can view and download the RC-Car-Bootstrap in order to start programming. See the next section for instructions on how to do so.", 
            "title": "What to Download"
        }, 
        {
            "location": "/bootcamp/rccompetition/#where-to-get-the-code-github", 
            "text": "The following link is where you can download the base project for the RC Car Competition:  https://github.com/UWARG/RC-Car-Bootstrap-Competition  On the right side of the screen, select \"Download ZIP.\" Place the unzipped folder somewhere on your computer for you to access. Open this folder as a Project in MPLAB X, and you should be ready to start coding.  *Note: A presentation may be created later to teach people how to use MPLAB X, but if you start typing some code and want to test that it compiles (i.e. you've created correct code), then you may press the \"Build   Clean\" button to initially test the program. It should tell you if there are any errors with your code, or something that it doesn't understand.", 
            "title": "Where to Get the Code (GitHub)"
        }, 
        {
            "location": "/bootcamp/rccompetition/#functionality-developed-by-warg-for-you-to-use", 
            "text": "WARG has developed a bunch of functions that perform hardware communication with the car. This means that the recruits do not need to understand how to truly talk to the devices, but instead can program the system at a much higher level. What this means is something similar to the following comparison. Somebody tells you to shout \"Hello!\" You don't truly think about the fact that all those fancy biology components in your body are doing things, and somehow in the end\u2026. magical noise comes from your mouth. What happened is that somebody gave you a command at a \"higher level,\" your brain then took that command and did the appropriate things without you truly knowing what's going on, in order to make \"Hello!\" come from your mouth. Might be a weird analogy yes, but that's similar to what's going on in the code.  WARG has given you the following functions to work with. They must have the specified inputs, and they perform the specified actions:  setSteering(int percent);  This function does exactly what you think it does. It takes an int value input ranging from -100 to 100.    With -100 turning the wheels fully to the left, and 100 turning the wheels fully to the right.  setThrottle(int percent);  This function does exactly what you think it does. It takes an int value input ranging from -100 to 100. With -100 being full speed in reverse, and 100 being full speed forward.  getTime();  This function returns the time in milliseconds as type  long int , the function takes no inputs.  You are also given a struct to work with that holds and updates all of the appropriate GPS Data. In order to access this information, simply type \"GPS.______\" where the ____ is filled appropriately as follows:  GPS.latitude;     // the current latitude as type  long double  GPS.longitude;     // the current latitude as type  long double  GPS.speed;           // the current ground speed as type  float  GPS.heading;       // the current heading as type  int  GPS.satellites;     // the current number of satellites as type  char  GPS.positionFix;  // if there is a position fix or not as type  char  GPS.altitude;        // the current altitude as type  int", 
            "title": "Functionality Developed by WARG for You to Use"
        }, 
        {
            "location": "/bootcamp/rccompetition/#where-you-program-in-the-code", 
            "text": "When you download all of the required programs, and get the RC-Car-Bootstrap from Github, you will see the following code segment in the main.c file.   You will notice that there is already some code in the main body\u2026. YOU MUST LEAVE THIS THERE.  The code that exists is there to initialize the system and ensure it is running properly. As well, it performs all of our background tasks that send data do us about what your system is doing at the moment. All of your code must take place after \"setSteering(0);\" and before \"background();.\" Please note that this is meant by your code in the main function of your program, later on in the phases, you will be required to develop your own functions, which must be developed outside of this main.", 
            "title": "Where You Program in the Code"
        }, 
        {
            "location": "/bootcamp/rccompetition/#aspects-of-programming-super-simplified", 
            "text": "***WARNING: THIS SECTION IS NOT COMPLETED, AND YOU'LL NEED TO KNOW A FEW MORE THINGS THAN WHAT IS DESCRIBED HERE. FOLLOW THE PROVIDED TUTORIAL LINKS TO HELP YOU LEARN FOR THE TIME BEING.  For any recruit who is nervous, unsure, or thinking twice about joining the competition due to not having prior (or having minimal) knowledge of programming, WARG would like to motivate you to get past that fear. SO GET MOTIVATED!!!  Programming may take a little bit in order for the concepts to finally \"click,\" but once you grasp it\u2026     \u2026it all seems so simple  You will be programming in a language known as C. Just as there are multiple verbal languages (i.e. English, French, Spanish, etc.), there are a bunch of programming languages. These programming languages are a lot easier to transition between and pick up if you know one of the languages, in comparison to verbal languages.  Moving on, here is a REALLY REALLY simplified generalization of some programming concepts.", 
            "title": "Aspects of Programming (Super Simplified)"
        }, 
        {
            "location": "/bootcamp/rccompetition/#variables", 
            "text": "You can think of variables just like the ones you'd use in math, by this we mean that they can be seen as \"place holders\" for a value. Meaning that in math you may declare:  \"Let x be the number of apples Brian has on Monday\"  Variables in programming are similar, and are place holders for actual values. These values are hidden away and saved somewhere in the microchip (in memory\u2026. but we don't need to know about this right now). Here are a couple examples of variable  types :     Type  Description  Example      int  Can be thought of as a  whole  number, or a number  without  decimals  1,  16,  3054    float  Can be thought of as a number  with  decimals  1.02,  506.23579     You totally thought the list was going to be longer didn't you. Well, technically it is quite a bit larger yes, but in all honesty you could write the whole code for the competition using just these variables and you would be fine. With that said, you might want to utilize something known as an  Array . An array can be thought of as a list of a certain type of variable. If you want to save data on a few things that may relate, or be of similar characteristic, to one another\u2026 you may want to put them into a list.  In order to initialize your variables in your program, you would do as such:  int x = 0;    //This means that you've declared a new variable \"x\", that is of type int, and has starting value 0  float myFloat = 2.34; //a new variable \"myFloat\", of type float, with starting value 2.34  int myArray[5];  //Declaration of an array (un-initialized)\u2026  \u2026This means that you've declared an array of 5 int variables (i.e. there is a list of 5 int's), you've called this array \"myArray\", and you did not initialize the values to anything  You would then later access individual members of the array by doing the following:  myArray[0] = 8; //This sets the first member in the list to hold a value of 8  Piece of cake right? No? Well that's ok, because it took some of the Lead members of WARG a little while to truly get a grasp as well.  *** Obviously there's more to programming then just declaring variables, and WARG is currently in the process of writing this document to better help recruits get involved! For the time being, please look at the following tutorials online regarding basic C programming. There's lots of things on the internet if you use that thing\u2026. what are the kids calling it? \"The Google?\"  You'll need to know about \"if\" statements, \"while\" loops, and possible \"for\" loops in order to successfully complete the phases in the competition. Here are a few useful links to help you:  http://www.cprogramming.com/tutorial/c/lesson1.html   -- Specifically:  http://www.cprogramming.com/tutorial/c/lesson2.html   // if statements  http://www.cprogramming.com/tutorial/c/lesson3.html   // looping  http://www.cprogramming.com/tutorial/c/lesson4.html   // functions  Or more importantly for now (considering we're still developing this document), in order to be a part of any student team, you need to be able to research. Therefore the following is the most important link we can give you:  http://lmgtfy.com/?q=c+tutorial", 
            "title": "Variables"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-definitions", 
            "text": "This section of the document is meant to further define what is required, and expected for each Phase of the competition.", 
            "title": "Phase Definitions"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-i", 
            "text": "Purpose:  Allow recruits to get acquainted with a very simple program, and how the process works to program the RC Car. The recruits will need to call functions that have been premade for them, and make a simple loop.  Required Tasks:   \uf0b7\uf0b7Drive Forward for 10 seconds  \uf0b7\uf0b7Drive Backward for 10 seconds  \uf0b7\uf0b7Turn Right for 10 seconds  \uf0b7\uf0b7Turn Left for 10 seconds   Explanation:  This phase should not require further explanation in order to get a grasp on what's required. By defining a few variables, and using the pre-made functions given to use, the recruit should be able to create a program that performs the above tasks.  Evaluation and Weighting:    10% in total for the phase  2.5% will be given per each of the 4 tasks  It is simply expected that the car moves in the appropriate direction for the given time period. The car does not need to stop \"spot on\" the 10 second mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.", 
            "title": "Phase I"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-ii", 
            "text": "Purpose:  The initial purpose of this phase is to have the recruits create a new function from scratch. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.  Required Tasks:   \uf0b7\uf0b7Drive Forward 10 meters  \uf0b7\uf0b7Drive Backward 10 meters   Explanation:  In this phase the recruit must create their own function in order to determine the distance travelled from the car's current position, to a start point (or previous waypoint).  Your function definition should pass in latitude and longitude values of the GPS coordinates (2 sets, one for point 'A' and one for point 'B'). The following website gives you a pretty good layout of how your code should look (to some extent, it will look different due to you programming in C and not Java Script). Specifically the following code bite as well:  http://www.movable-type.co.uk/scripts/latlong.html   Above is the formula you must program into your function.  Below is how the created such a function with Java Script. *** Your function should return a float of \"d\"   var R =6371;// km  var\u03c61= lat1.toRadians();  var\u03c62= lat2.toRadians();  var\u0394\u03c6=(lat2-lat1).toRadians();  var\u0394\u03bb=(lon2-lon1).toRadians();  var a =Math.sin(\u0394\u03c6/2)*Math.sin(\u0394\u03c6/2)+      Math.cos(\u03c61)\\*Math.cos(\u03c62)\\*\n\n    Math.sin(\u0394\u03bb/2)\\*Math.sin(\u0394\u03bb/2);  var c =2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));  var d = R * c;   The only addition you must make to this code (besides writing it correctly for your C program), is to multiple the \"c\" value above by \u00b11000. Is needed to convert kilometers into meters.  Evaluation and Weighting:    10% in total for the phase  5% will be given per each of the 2 tasks  Initially, it is simply expected that the car moves in the appropriate direction for the given distance. The car does not need to stop \"spot on\" the 10 meter mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.  Furthermore, out of the 5% given towards either task, a weighting of 4% will be achieved by implementing the functionality described in the previous paragraph. The additional 1% will be achieved based on error to the 10m mark. In order to reach the 10m as close as possible, the recruit must implement proper Control Theory in order to slow the car down and receive the extra weighting. The code cannot be written to simply reverse the car for a millisecond after reaching the 10m mark, as this harms the equipment and decreases its lifespan. You may not reverse back to the 10m mark either if you have passed it. Additionally, in order to achieve this extra weighting (and so that WARG can see your control loop is working correctly), the RC Car must be started at an initial throttle of _(40)_%. The weighting will be received based on error in comparison to the top team for this phase (team closest to the 10m mark).  Please note that the control theory aspect will be learned in later phases of the competition. The \"closeness\" to the 10m mark is worth only 1% since it is WARG's desire that all teams initially develop the code well enough to accomplish the initial 4% of this phase for each task. If teams finish the majority of the competition, and after learning control theory, they may return back to this phase in order to try and receive the addition 1%.", 
            "title": "Phase II"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-iii", 
            "text": "Purpose:  The initial purpose of this phase is to have the recruits begin to think in terms of heading, and how it relates to controlling the steering of the car. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.  Required Tasks:   \uf0b7\uf0b7Drive Forward 5 meters, then  ooTurn Right 90 degrees, then  ooTurn Left 90 degrees   Explanation:  In this phase the recruit must create their own functionality in order to determine which direction to steer the car at any given point in time. The car may bounce around, and therefore move off of the desired path. Since we are constantly checking the state of the car (by continuously looping through the entire code), we can determine which way to steer the car at any point in time. It is recommended that this functionality be developed in the form of a function.  At no point during this phase should the car come to a stop while transitioning between task objectives. The desire is that the car drives a smooth path. For this reason, the car should never operate under _(20)_% throttle while transitioning between task objectives. The car may only be controlled to a complete stop once you are completed the phase in the \"Turn Left 90 degrees\" sub-task. Again, the car may never be driven backwards, and must always be moving forwards.  Evaluation and Weighting:    15% in total for the phase  12% will be given for initially achieving the tasks above by going (at minimum) the distance or angle change that's stated.  Initially it is WARG's desire that the recruit moves on after achieving this initial functionality, and returns back at a later time to improve upon the phase's functionality. The additional 3% will be achieved similarly to the methods described in Phase II, in the same manner that the additional 1% is achieved.", 
            "title": "Phase III"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-iv", 
            "text": "Purpose:  The purpose of this phase is for the recruit to put all of the functionality they've developed together, and create a simple control loop.  Required Tasks:   \uf0b7\uf0b7Drive a straight line  ooWhile maintaining heading  ooStop after _(100)_m   Explanation:  In this phase the recruit must create a control loop that will steer the car accordingly and keep it on the desired path. This involves monitoring the heading of the car, and steering the car in the appropriate direction if it starts to stray from the desired path. A heading a starting direction will be determined by WARG based on the competition testing location (the heading to hold will be hardcoded into the recruits program ahead of time, since at this point we are not expecting anything that calculates which heading should be held).  You will notice that if you turn the car too much in a given direction when it strays off the path, it will quickly be weaving back and forth on the path, and the amplitude of this \"weave\" will increase overtime. This is because you must  converge  towards the desired path, rather than do a jerking turn that makes the car immediately be on the path. The rate at which you turn the steering, relative to your distance from the path, is controlled through the  control loop , and by tuning the gains appropriately to fit your system (in this case the system is the RC Car).  Please refer to the  Control Theory  section in order to gain more knowledge on how to create a control loop. As well, WARG is considering bring in lecturers in order to host short lectures / tutorials on these concepts. This will be done based on the interest of the students.  Evaluation and Weighting:    15% in total for the phase  Considering that we do not expect the car to stray to too far from the desired path (there are no strong winds pushing the car off its path, such as that which occurs with the airplane while in the air), we do not expect the error from the path to be very large at all. Even if the recruit poorly tuned that control loops / gains, we believe the system shouldn't have a problem staying on the desired path.  With this in mind, the 10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error.  The additional 5% of this phase will be calculated based on the recruit's error in distance travelled, in comparison to that of the top team's error. (Hint: this is a controlled stop like that described in Phase II)  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired travel distance of _(100)_m. Again, the car should always be moving forward.", 
            "title": "Phase IV"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-v", 
            "text": "Purpose:  The purpose of this phase is for the recruit to develop dynamic functionality of their code (i.e. not hardcoded values). This phase also has the purpose of developing code that drives the car based on waypoints.  Required Tasks:   \uf0b7\uf0b7Drive from Point A to Point B  ooStop within a _(5)_m radius   Explanation:  The functionality as described in Phase IV should be implemented in this phase in order to better complete the task described.  You'll need to apply some logic into your program and probably create another function to perform basic geometry. In order to find the line (and heading) you must follow, you'll have to generate a xy based system from you latitude / longitude coordinates. You can do this by specifying an anchor point (of latitude longitude, this could possibly be your position on start-up). You can then find your x component, and y component of any given waypoint by holding either your latitude / longitude constant, and sending your anchor, and new waypoint through your getDistance() function.  On competition day, WARG will provide the recruit with a Waypoint to travel to. The program must get its current GPS position (current waypoint), and then calculate a straight line from this current position to the desired waypoint given by WARG. This is the heading that the car must be desired to hold in order to get to the waypoint.  WARG will start the car in the opposite (or some determined) direction relative to the goal Waypoint in order to ensure the system is calculating things appropriately.  *Hint: The RC Car should calculated which direction to turn in order to be going the appropriate heading the fastest.  Evaluation and Weighting:    15% in total for the phase  10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.  The additional 5% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 5% weighting.  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.", 
            "title": "Phase V"
        }, 
        {
            "location": "/bootcamp/rccompetition/#phase-vi", 
            "text": "Purpose:  The purpose of this phase is to combine everything that the recruit has learned in order to make the RC Car follow a dynamic path of waypoints. Two paths of _(10)_ waypoints will be given for the car to follow (the car will follow one path, and then the new waypoints will be programmed, and the second path will be followed).  Required Tasks:   \uf0b7\uf0b7Follow a set of _(10)_ Waypoints   Explanation:  At this point in time, WARG hopes that the recruit has learned enough from previous stages in order to accomplish the described task of following a set of _(10)_ waypoints.  Waypoint 1 will be the RC Car's current position, the additional 9 waypoints will be provided.  Evaluation and Weighting:    35% in total for the phase  34% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.  The additional 1% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the final waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 1% weighting.  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.", 
            "title": "Phase VI"
        }, 
        {
            "location": "/tutorials/git/", 
            "text": "Git and Github Tutorial\n\n\nThis tutorial will introduce you to git and github. Knowing these is essential if you want to contribute to the software side of UWARG.\n\n\nWhat is Git?\n\n\nGit\n is a source code version control system. What does this mean? It lets you manage source code. Git tracks changes to your code, lets you revert your code, and allows you to collaborate with other people easily.  Git tracks the \nchanges\n to your files only, not the individual files themselves.\n\n\nWhy use Git?\n\n\nYou may just be used to saving code to your computer locally only, and relying on Ctrl-Z in case you break something and want to restart. This is where git shines. You commit code, which allows you to revert to it later if need be (say, you break code).\n\n\nInstalling git\n\n\nYou have two options when installing Git. There's the command line version (you use it through the command promt/no gui). There's also \nGithub for Desktop\n, which is a GUI client for Git that integrates with Github (don't worry we'll explain github later on). If you're a beginner, you should probably start out with the GUI client. If you're on linux or interested in using the command shell (its usually faster than the GUI client) then install that.\n\n\nWindows\n\n\nMac OS X\n\n\nUbuntu\n\n\nIf you're using linux, you can install git by simply running:\n\nsudo apt-get install git\n. \n\n\nHow to use Git\n\n\nUsing git is very simple. How the workflow works is:\n\n\n\n\nYou edit your code in your project\n\n\nYou decide that you would like to save the current state of your project\n\n\nYou add the changed files to the staging index with \ngit add .\n\n\nYou commit the files with \ngit commit -m \"Your unique commit message here\n\n\n\n\nThat's it! Its that simple. When using git you may want to wrap your head around the concept of the staging index, the remote repository, local repository, etc. Those go beyond this tutorial however if you're interested you head scroll down to the other resources section which lists articles that explain it.\n\n\nCommon Commands\n\n\nHere are some common commands you can use with git:\n\n\nWhat is github?\n\n\nOther Resources", 
            "title": "Git and Github"
        }, 
        {
            "location": "/tutorials/git/#git-and-github-tutorial", 
            "text": "This tutorial will introduce you to git and github. Knowing these is essential if you want to contribute to the software side of UWARG.", 
            "title": "Git and Github Tutorial"
        }, 
        {
            "location": "/tutorials/git/#what-is-git", 
            "text": "Git  is a source code version control system. What does this mean? It lets you manage source code. Git tracks changes to your code, lets you revert your code, and allows you to collaborate with other people easily.  Git tracks the  changes  to your files only, not the individual files themselves.", 
            "title": "What is Git?"
        }, 
        {
            "location": "/tutorials/git/#why-use-git", 
            "text": "You may just be used to saving code to your computer locally only, and relying on Ctrl-Z in case you break something and want to restart. This is where git shines. You commit code, which allows you to revert to it later if need be (say, you break code).", 
            "title": "Why use Git?"
        }, 
        {
            "location": "/tutorials/git/#installing-git", 
            "text": "You have two options when installing Git. There's the command line version (you use it through the command promt/no gui). There's also  Github for Desktop , which is a GUI client for Git that integrates with Github (don't worry we'll explain github later on). If you're a beginner, you should probably start out with the GUI client. If you're on linux or interested in using the command shell (its usually faster than the GUI client) then install that.", 
            "title": "Installing git"
        }, 
        {
            "location": "/tutorials/git/#windows", 
            "text": "", 
            "title": "Windows"
        }, 
        {
            "location": "/tutorials/git/#mac-os-x", 
            "text": "", 
            "title": "Mac OS X"
        }, 
        {
            "location": "/tutorials/git/#ubuntu", 
            "text": "If you're using linux, you can install git by simply running: sudo apt-get install git .", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/tutorials/git/#how-to-use-git", 
            "text": "Using git is very simple. How the workflow works is:   You edit your code in your project  You decide that you would like to save the current state of your project  You add the changed files to the staging index with  git add .  You commit the files with  git commit -m \"Your unique commit message here   That's it! Its that simple. When using git you may want to wrap your head around the concept of the staging index, the remote repository, local repository, etc. Those go beyond this tutorial however if you're interested you head scroll down to the other resources section which lists articles that explain it.", 
            "title": "How to use Git"
        }, 
        {
            "location": "/tutorials/git/#common-commands", 
            "text": "Here are some common commands you can use with git:", 
            "title": "Common Commands"
        }, 
        {
            "location": "/tutorials/git/#what-is-github", 
            "text": "", 
            "title": "What is github?"
        }, 
        {
            "location": "/tutorials/git/#other-resources", 
            "text": "", 
            "title": "Other Resources"
        }, 
        {
            "location": "/tutorials/shell/", 
            "text": "Using the command shell\n\n\nSome of the docs and tutorials on this site assume that you know how to navigate the file system using the terminal (whether it be on Windows, Linux, or Mac). For example, working with the computer-vision and groundstation projects is alot easier to do on the command line than with a GUI. In both cases, it isn't possible to setup either of these projects without touching the command line. \n\n\nA recommended tutorial you can checkout is \nCodeAcademy's Command Line Course\n. They guide you through using bash to navigate the file system, run commands, etc. The course is free and should only take you about 3 hours. It's interactive and will teach you how to use the shell far better than we can ;).\n\n\nNote: This course teaches bash (which is what runs on linux by default). It is however far better than the Windows CMD and you can install and use it on Windows by downloading and installing something like \ncmder\n.", 
            "title": "Using the terminal"
        }, 
        {
            "location": "/tutorials/shell/#using-the-command-shell", 
            "text": "Some of the docs and tutorials on this site assume that you know how to navigate the file system using the terminal (whether it be on Windows, Linux, or Mac). For example, working with the computer-vision and groundstation projects is alot easier to do on the command line than with a GUI. In both cases, it isn't possible to setup either of these projects without touching the command line.   A recommended tutorial you can checkout is  CodeAcademy's Command Line Course . They guide you through using bash to navigate the file system, run commands, etc. The course is free and should only take you about 3 hours. It's interactive and will teach you how to use the shell far better than we can ;).  Note: This course teaches bash (which is what runs on linux by default). It is however far better than the Windows CMD and you can install and use it on Windows by downloading and installing something like  cmder .", 
            "title": "Using the command shell"
        }
    ]
}