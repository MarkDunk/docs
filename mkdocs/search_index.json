{
    "docs": [
        {
            "location": "/", 
            "text": "WARG Docs\n\n\nThe official source of all your WARG needs. Joking, there's only documentation here. Enjoy!\n\n\n\n\nBootcamps\n\n\n\n\nMechanical Bootcamp\n\n\n\n\nProjects\n\n\n\n\nPicPilot Documentation\n\n\nGroundstation Documentation\n\n\nComputer Vision Documentation", 
            "title": "Home"
        }, 
        {
            "location": "/#warg-docs", 
            "text": "The official source of all your WARG needs. Joking, there's only documentation here. Enjoy!", 
            "title": "WARG Docs"
        }, 
        {
            "location": "/#bootcamps", 
            "text": "Mechanical Bootcamp", 
            "title": "Bootcamps"
        }, 
        {
            "location": "/#projects", 
            "text": "PicPilot Documentation  Groundstation Documentation  Computer Vision Documentation", 
            "title": "Projects"
        }, 
        {
            "location": "/groundstation/", 
            "text": "Welcome to the Groundstation docs!\n\n\nThe groundstation is the software running on the ground computer communicating to the plane through the \ndata-relay-station\n. This wiki describes everything you need to know about it in order to start contributing.\n\n\nTable of Contents\n\n\n\n\nIntroduction", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/groundstation/#welcome-to-the-groundstation-docs", 
            "text": "The groundstation is the software running on the ground computer communicating to the plane through the  data-relay-station . This wiki describes everything you need to know about it in order to start contributing.", 
            "title": "Welcome to the Groundstation docs!"
        }, 
        {
            "location": "/groundstation/#table-of-contents", 
            "text": "Introduction", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/groundstation/introduction/", 
            "text": "Introduction\n\n\nThe groundstation is a desktop application based on \nNW.js\n. This section will explain what NW.js and \nNode.js\n is, as well as setting up your development environment for building the application.\n\n\nCommunication Path\n\n\nThe groundstation talks directly to the \ndata-relay-station\n. The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).\n\n\n\n\nWhat is Javascript and Node.js?\n\n\nAs you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes. \n\n\nEnter \nNode.js\n\n\nNode.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with \npython script.py\n you can run javascript scripts with \nnode script.js\n. It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it. \n\n\nWhat is NW.js?\n\n\nOk, so where does \nNW.js\n fit in all this? Why do we need it if we can already write native applications with node.js and javascript. You can think of NW.js as a GUI framework. Usually making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.\n\n\nNW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.\n\n\nInstallation\n\n\n\n\n\n\nThe first step is cloning the repository. Open up the terminal and run: \n\ngit clone https://github.com/UWARG/WARG-Ground-Station\n\n\n\n\n\n\nThen you need to install Node.js. You can download and install it \nhere\n. Download Node version 5 and above preferably. After you've installed node you should have the \nnode\n command available for you to use in your terminal. Run \nnode help\n to verify that you've successfuly installed node and make sure you're running the right version.\n\n\n\n\n\n\nNow that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run \nnpm install\n to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).\n\n\n\n\n\n\nNow you're ready to start the app up. Run \nnpm start\n to start the application. You should see a window appear of the groundsation.\n\n\n\n\n\n\nNow you need to download the offline satelite files that the application uses for it's map. \nDownload them here.\n. Extract the zip into the \nassets\n folder of the project directory (so you should have a folder called \nsat_tiles\n in the assets folder). \n\n\n\n\n\n\nCongratulations! You should now have the groundstation installed on your computer ready for you to develop on!", 
            "title": "Introduction"
        }, 
        {
            "location": "/groundstation/introduction/#introduction", 
            "text": "The groundstation is a desktop application based on  NW.js . This section will explain what NW.js and  Node.js  is, as well as setting up your development environment for building the application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/groundstation/introduction/#communication-path", 
            "text": "The groundstation talks directly to the  data-relay-station . The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).", 
            "title": "Communication Path"
        }, 
        {
            "location": "/groundstation/introduction/#what-is-javascript-and-nodejs", 
            "text": "As you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes.   Enter  Node.js  Node.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with  python script.py  you can run javascript scripts with  node script.js . It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it.", 
            "title": "What is Javascript and Node.js?"
        }, 
        {
            "location": "/groundstation/introduction/#what-is-nwjs", 
            "text": "Ok, so where does  NW.js  fit in all this? Why do we need it if we can already write native applications with node.js and javascript. You can think of NW.js as a GUI framework. Usually making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.  NW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.", 
            "title": "What is NW.js?"
        }, 
        {
            "location": "/groundstation/introduction/#installation", 
            "text": "The first step is cloning the repository. Open up the terminal and run:  git clone https://github.com/UWARG/WARG-Ground-Station    Then you need to install Node.js. You can download and install it  here . Download Node version 5 and above preferably. After you've installed node you should have the  node  command available for you to use in your terminal. Run  node help  to verify that you've successfuly installed node and make sure you're running the right version.    Now that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run  npm install  to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).    Now you're ready to start the app up. Run  npm start  to start the application. You should see a window appear of the groundsation.    Now you need to download the offline satelite files that the application uses for it's map.  Download them here. . Extract the zip into the  assets  folder of the project directory (so you should have a folder called  sat_tiles  in the assets folder).     Congratulations! You should now have the groundstation installed on your computer ready for you to develop on!", 
            "title": "Installation"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/", 
            "text": "What you need to know\n\n\nThis section will help to highlight \nmost\n of what you need to know before you can start developing. \n\n\nJavascript\n\n\nIf you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this \nCodeacademy Javascript Course\n. The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are: \n\n\n\n\nThe significance of var and when and when not to use it\n\n\nThat everything in javascript is an object, including functions\n\n\nThe 3 different ways of declaring javascript objects, and how they are different\n\n\n\n\nNode.js\n\n\nSo you don't need to read all of the gigantic \nNode.js API Documentation\n, though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.\n\n\nNode.js modules\n\n\nSo what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word \nrequire\n being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you. \n\n\nUsually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.\n\n\nSo what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling \nrequire('filelocation/filename)\n. But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.\n\n\nLets take an example comparing traditional methods and using require. \n\n\nUsing Regular Javascript\n\n\nhead\n\n    \nscript\n\n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n    \n/script\n\n    \nscript\n\n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n    \n/script\n\n\n/head\n\n\n\n\n\nThis is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.\n\n\nUsing Node.js Modules\n\n\n//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;\n\n\n\n\n//this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!\n\n\n\n\nYou may have noticed the \nmodule.exports=hello;\n line in the \nhello.js\n module. What this tells node is the result of calling \nrequire\n on the hello.js module will return the variable/function hello. In \napp.js\n we use this module by calling \nvar hello=require('hello')\n. The variable hello now contains whatever the \nhello.js\n module exported, which in this case is a function.\n\n\nYou can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling \nvar\n will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.\n\n\nNode Package Manager (npm)\n\n\nNPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the \nNPM registry\n. \n\n\nThe most important command of npm is \nnpm install \npackagename\n. This will install a package in your project directory. Doing an \nnpm install\n without any parameters at the project root will tell npm to look in your projects \npackage.json\n file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running \nnpm install -g nw\n. This will install the NW.js module globally on your computer, allowing you to use the \nnw\n command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running \nnw\n in the terminal.\n\n\nJavascript Frameworks\n\n\nThe groundstation uses \nBackbone\n and \nMarionette\n as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.\n\n\nYou don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation. \n\n\nLibraries Used\n\n\nOne of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include \nJquery\n for simple dom manipulations, and \nleaflet\n as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the \nLeaflet API Docs\n is pretty useful if you're working with the Map modules.", 
            "title": "What you need to know"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#what-you-need-to-know", 
            "text": "This section will help to highlight  most  of what you need to know before you can start developing.", 
            "title": "What you need to know"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#javascript", 
            "text": "If you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this  Codeacademy Javascript Course . The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are:    The significance of var and when and when not to use it  That everything in javascript is an object, including functions  The 3 different ways of declaring javascript objects, and how they are different", 
            "title": "Javascript"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs", 
            "text": "So you don't need to read all of the gigantic  Node.js API Documentation , though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.  Node.js modules  So what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word  require  being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you.   Usually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.  So what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling  require('filelocation/filename) . But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.  Lets take an example comparing traditional methods and using require.   Using Regular Javascript  head \n     script \n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n     /script \n     script \n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n     /script  /head   This is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.  Using Node.js Modules  //this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;  //this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!  You may have noticed the  module.exports=hello;  line in the  hello.js  module. What this tells node is the result of calling  require  on the hello.js module will return the variable/function hello. In  app.js  we use this module by calling  var hello=require('hello') . The variable hello now contains whatever the  hello.js  module exported, which in this case is a function.  You can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling  var  will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.  Node Package Manager (npm)  NPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the  NPM registry .   The most important command of npm is  npm install  packagename . This will install a package in your project directory. Doing an  npm install  without any parameters at the project root will tell npm to look in your projects  package.json  file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running  npm install -g nw . This will install the NW.js module globally on your computer, allowing you to use the  nw  command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running  nw  in the terminal.", 
            "title": "Node.js"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#javascript-frameworks", 
            "text": "The groundstation uses  Backbone  and  Marionette  as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.  You don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation.", 
            "title": "Javascript Frameworks"
        }, 
        {
            "location": "/groundstation/what-you-need-to-know/#libraries-used", 
            "text": "One of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include  Jquery  for simple dom manipulations, and  leaflet  as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the  Leaflet API Docs  is pretty useful if you're working with the Map modules.", 
            "title": "Libraries Used"
        }, 
        {
            "location": "/picpilot/", 
            "text": "Welcome to the PicPilot wiki!\n\n\nThis site is to document all the functions and required background knowledge about the autopilot system.\n\n\n\n\nIntroduction\n\n\nSetup\n\n\nC\n\n\nProgramming the Device\n\n\nAutopilot System Overview\n\n\nSchematics and Board Design\n\n\nProject Files\n\n\nCoding Convention\n\n\n\n\n\n\nPID Loops\n\n\nPWM I/O\n\n\nUniversal Asynchronous Receive/Transmit (UART)\n\n\nSerial Peripheral Interface (SPI)\n\n\nDirect Memory Access (DMA)\n\n\nInter-Interchip Communication (I2C)\n\n\nDatalink\n\n\nAnalog-to-Digital Converter (ADC)\n\n\nSensors and Peripherals\n\n\nGPS(MEDIATEK-3329)\n\n\nIMU (VectorNav-100)\n\n\nAltimeter (MPL3115A2)\n\n\nXBEE PRO S3B\n\n\nRC Receiever (EzUHF)\n\n\nAirspeed Sensor (To be implemented)\n\n\nUltrasonic Sensor (To be implemented)\n\n\n\n\n\n\nAttitude Control\n\n\nPath Management\n\n\nFAQ - WIP\n\n\n\n\nBackground Reading\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/picpilot/#welcome-to-the-picpilot-wiki", 
            "text": "This site is to document all the functions and required background knowledge about the autopilot system.   Introduction  Setup  C  Programming the Device  Autopilot System Overview  Schematics and Board Design  Project Files  Coding Convention    PID Loops  PWM I/O  Universal Asynchronous Receive/Transmit (UART)  Serial Peripheral Interface (SPI)  Direct Memory Access (DMA)  Inter-Interchip Communication (I2C)  Datalink  Analog-to-Digital Converter (ADC)  Sensors and Peripherals  GPS(MEDIATEK-3329)  IMU (VectorNav-100)  Altimeter (MPL3115A2)  XBEE PRO S3B  RC Receiever (EzUHF)  Airspeed Sensor (To be implemented)  Ultrasonic Sensor (To be implemented)    Attitude Control  Path Management  FAQ - WIP   Background Reading   Information on Model Aircraft  General Aerodynamic Principles  Git Help", 
            "title": "Welcome to the PicPilot wiki!"
        }, 
        {
            "location": "/picpilot/introduction/", 
            "text": "Introduction\n\n\nThe PICpilot is a software package meant to control fixed-wing aircraft and numerous \"copters\", among other vehicles. It requires the usage of a specific type of digital signal microcontroller. This microcontroller is produced by \nMicrochip\n. The microcontroller that is currently supported is the \ndspic33fj256gp710A\n. However, many other similar models can be easily adapted for support.\n\n\nThis software is designed to be used with two communicating microcontrollers (essential double cores). Due to the atypical nature of the software, it is recommended to view the board schematics \nhere\n. The schematics are also included in another section of this document.\n\n\nThe two processors are allocated to two individual tasks. The chip which is responsible for attitude management is often referred to as the \"main\" chip. It is responsible for making corrections to the planes orientation in space, which involves pitch, roll, yaw, heading, throttle, and altitude. It also manages a few additional tasks involving relaying communication with the ground station. The second processor is often referred to as the \"Path Manager\". This chip controls the where the plane should fly (path), and the transitions in altitude and heading between each waypoint (specific GPS coordinates). It also controls the GPS and altitude sensors. These two chips work asynchronously from one another in order to automate the plane.\n\n\nSetup\n\n\nTo get started, you will need three things:\n\n A Git Client - https://github.com/\n\n MPLAB XC16 Compiler (16-bit) - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2\n* (Optional) MPLAB X IDE - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2\n\n\nGithub Setup\n\n\nA similar powerpoint presentation can be found here:\nhttps://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing\n\n\nIf you are not using the GUI skip this section.\n\n\n\n\nSetup a \nGithub\n Account\n\n\nSelect \"Set up Git\"\n\n\nSelect \"Download GitHub for \n\"\n\n\nSelect \"Run\" and continue through the installation process\n\n\nOnce the installation is complete, launch the application.\n\n\nLog in\n\n\nFind the Git Bash shell and type in the following commands:\n\n\ngit config global user.name \"YOUR USERNAME HERE\"\n\n\ngit config global user.email \"YOUR EMAIL HERE\"\n\nThese set the default name and email you use when committing to GitHub.\n\n\nAt this point you will need to let one of the WARG team leads know your username, so that you can be added to the repository member's list.\n\n\nYou should then be able to clone the project using the clone button, or the project URL.  \n\n\n\n\nYou should now have the code. \n\n\nMPLAB Setup\n\n\nYou now need the libraries and compilers, as well as the optional MPLAB X IDE, in order to develop code.\n\n\nCompiler\n\n\n\n\nDownload the \ncompiler\n. You want the MPLAB XC16 Compiler V1.21 or newer. Unzip the file once it is completed.\n\n\nAccept the license agreement.\n\n\nSelect \"Install Compiler\".\n\n\nSelect \"Install MPLAB XC16 C Compiler on this computer.\n\n\nLeave the activation key blank. Confirm \"Yes\" when the dialog prompts you about using the free version.\n\n\nSelect \"Run the compiler in free mode\".\n\n\nSelect the installation directory.\n\n\n\n\nRun and finish the installation.\n\n\n\n\n\n\nNote whenever you make a new project, make sure the right compiler is selected, otherwise there will be a lot of indicated syntax errors (red underlines).\n\n\n\n\n\n\nIDE (The fancy word editor that lets you do some code-shenanigans)\n\n\n\n\nDownload the \nIDE Package\n. You want the MPLAB X IDE V2.10 or newer. Unzip the file once it is completed.\n\n\nProceed through the installation process (select installation directory, accept license agreement).\n\n\n\n\nGitHub Usage\n\n\nIf you don't know how to use Git or you need a reference, \nGitImmersion\n is a great website.\n\n\nGUI Usage:\n\n\n\n\nMake sure you have correctly set your default storage location in the Options menu.  \n\n\n\n\nSaving Files (Committing and Pushing)\n  \n\n\n\n\nSelect your Project\n\n\nSelect the files that are supposed to be committed.\n\n\nWrite a commit message, that gives a general overview about each change completed in this update.\n\n\nHit \"Commit\".\n\n\nOnce you are ready to sync the changes, hit the sync button (top of the window).\n\n\n\n\nReading Files from the Server (Pulling)\n\n* Simply click the sync button at top of the window.\n\n\nGeneral Syntax (Git Bash):\n\n\n\n\ngit add \nFilename\n or git add .\n stages the file for commit.\n\n\ngit status\n displays all changes being made.\n\n\ngit commit -m \"\nCommit message here\n\"\n makes the change.\n\n\ngit push\n sends the change to the server\n\n\ngit pull\n retrieves the latest change from the server.\n\n\ngit checkout \nHASH\n retrieves a SPECIFIC version from the server.\n\n\ngit checkout -b \nBranch Name\n creates a new branch.\n\n\ngit merge master\n merges the current branch with the latest code.\n\n\n\n\nGeneral Concepts:\n\n\n\n\nWhen making small changes it is okay to commit to the master branch.\n\n\nWhen making large changes (that take multiple days to complete), always make a branch, so that others can work concurrently without compiling broken code.\n\n\nAlways build your code before committing (To make sure it isn't broken).\n\n\nTry and get rid of warnings if possible.\n\n\n\n\nC (Programming Language)\n\n\nThe language being used in this project is C. If you are familiar with C++, the concepts are very similar. C is a low level programming language. This means that it does not have a large amount of \"built-in\" functionality, therefore learning C is quite straight forward.\n\n\nThe compiler used for this project is listed above. It is a modified version of the GCC Compiler.\n\n\nA set of well maintained tutorials can be found here: \nhttp://www.cprogramming.com/tutorial/c/lesson1.html\n\n\nTopics that one should be familiar with include (in order of importance):\n\n\n\n\nIf statements\n\n\nLooping\n\n\nFunctions\n\n\nVariable types and how they work\n\n\nArrays\n\n\nPointers\n\n\nStructures, Unions\n\n\n\n\nUnrelated topics:\n\n\n\n\nPrintf (There is no GUI)\n\n\nFile I/O (All I/O operations are specific to the chip)\n\n\n\n\nKnowledge of common data structures (binary trees, linked lists, etc.) is beneficial, but not mandatory.\n\n\nProgramming the Device\n\n\nIn order to program the device, you must have setup your account according to the Setup section. You should also refer to the Schematics and Board Design section for the ports required to complete the programming process. You will require an ICD 3 or a similar programming device.\n\n\nWhen using the MPLAB X GUI the process to program the device is as follows:\n\n\n-\n  1. Ensure the project you wish to program is the main project.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Click the \"Make and Program Device\" button in the top toolbar. Optionally, you can also press the debug button to use the debugging features of MPLAB X.\n\n\nWhen using your own editor and compiling from the command line:\n\n\n-\n  1. Have the binary file ready for programming.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Open the MPLAB IPE interface.\n  4. Select your chip model.\n  5. For the source option, browse to your binary file.\n  6. Press program and wait. Then optionally also use the verify option (recommended).\n\n\nIf you are using both chips of the PICpilot, ensure you correctly set the chip identifier pre-compiler in the main.h file, and ensure you program both chips.\n\n\nAutopilot System Overview\n\n\nThe autopilot system is meant to be adaptable to any aircraft including fixed-wing and multi-rotor aircraft (still WIP). This document mostly covers the software design of the system, although there are a few hardware notes made in this section and the next.\n\n\nFirst of all, the flowchart block diagram of the system is presented below:\n\n\n\n\nFrom this diagram you can see how the software combined with the hardware interacts to provide the final resulting UAV behaviour.\n\n\nThere are three chips. The main one is most commonly referred to as the attitude manager. It is also the communication manager, and the Master chip for all interchip communication. The other chip is referred to as the path manager. The third one has the dedicated task of managing the mechanical \"safety\" relays which ensure that a safety pilot can always regain control of the aircraft.\n\n\nThere are four sensors used in the original design of the aircraft. A GPS (Global Positioning System), IMU (Inertial Measurement Unit), Altimeter, and a camera are all part of the system. Additionally, 2 wireless interfaces are included in the design. A wireless Xbee transmitter/receiver provides telemetry data, whereas an additional (Ultra-high frequency [UHF]) receiver is used to attain control from a standard RC controller.\n\n\nThe outputs from the system include pictures and potentially video, telemetry data, and a functioning aircraft (with moving flaps, elevators, rudder, and ailerons).\n\n\nThis document only covers the PICpilot, however a system overview of a previously fully assembled system will be described in this section. In the past, the PICpilot has been expanded into a larger and more sophisticated system as seen below.\n\n\n\n\nSchematics and Board Design\n\n\nThe following schematic was last used at the time of the writing this document. The following schematic was last updated in 2011. You can check out the board schematics \nhere\n. They may also be available within the Github repository. You will require \nDiptrace\n in order to view the files. You can use the free version or use WARG's \"Pro\" license.\n\n\n\n\nThis board has 2 dspic33fj256710a chips. This is the PCB for the board. This is the labelled version:\n\n\n\n\n\n\n\n\nMicrocontroller 1 -\u0093 Attitude/Communication Manager\n\n\n\n\n\n\nMicrocontroller 2 -\u0093 Path Manager\n\n\n\n\n\n\nInput PWM\n\n\n\n\n\n\nOutput PWM\n\n\n\n\n\n\nOutput PWM Safety Relay\n\n\n\n\n\n\nOutput PWM Safety Relay Microcontroller\n\n\n\n\n\n\nOutput PWM Safety Relay Microcontroller Programming Port\n\n\n\n\n\n\nMicrocontroller 2 Programming Port\n\n\n\n\n\n\nSPI2 Port - VectorNav-100\n\n\n\n\n\n\nSPI2 Ports -\u0093 GPS\n\n\n\n\n\n\nSwitching Power Supply 1\n\n\n\n\n\n\nSwitching Power Supply 2\n\n\n\n\n\n\nVoltage Regulator\n\n\n\n\n\n\nSPI2 Port -\u0093 Used as a power source for the altimeter\n\n\n\n\n\n\nUART1 Port -\u0093 Debug\n\n\n\n\n\n\nUART2 Port -\u0093 Wireless Transmitter (Xbee)\n\n\n\n\n\n\nSPI2 Port -\u0093 Altimeter\n\n\n\n\n\n\nUART1 Port -\u0093 Debug\n\n\n\n\n\n\nUART2 Port -\u0093 Unused\n\n\n\n\n\n\nMicrocontroller 2 Programming Port\n\n\n\n\n\n\nPWM input/output -\u0093 Sonar\n\n\n\n\n\n\nThe important pins are listed below:\n\n\n\n\nThe schematics for the board are below:\n\n\n\n\n\n\n\n\n\n\nProject files\n\n\nAll the project files are hosted on Github. However, for convenience they are listed below (accurate at the time of writing of this document):\n\n\n\n\nAttitudeManager.c\n\n\nAttitudeManager.h\n\n\ncameraManager.c\n\n\ncameraManager.h\n\n\nClock.c\n\n\nClock.h\n\n\ncommands.h\n\n\ndebug.c\n\n\ndebug.h\n\n\ndelay.c\n\n\ndelay.h\n\n\nfmath.c\n\n\nfmath.h\n\n\nFullInitialize.c\n\n\nFullInitialize.h\n\n\nI2C.c\n\n\nI2C.h\n\n\nInputCapture.c\n\n\nInputCapture.h\n\n\nInterchipDMA.c\n\n\nInterchipDMA.h\n\n\nlcd.h\n\n\nmain.c\n\n\nmain.h\n\n\nMPL3115A2.c\n\n\nMPL3115A2.h\n\n\nnet.h\n\n\nnet_common.c\n\n\nnet_inbound.c\n\n\nnet_outbound.c\n\n\nOrientationControl.c\n\n\nOrientationControl.h\n\n\nOutputCompare.c\n\n\nOutputCompare.h\n\n\nPathManager.h\n\n\nPathManager.c\n\n\nPWM.c\n\n\nPWM.h\n\n\nSPI.c\n\n\nStartupErrorCodes.c\n\n\nStartupErrorCodes.h\n\n\nStringUtils.c\n\n\nStringUtils.h\n\n\nUART1.c\n\n\nUART1.h\n\n\nUART2.c\n\n\nUART2.h\n\n\nVN_lib.c\n\n\nVN_lib.h\n\n\nVN_math.c\n\n\nVN_math.h\n\n\nVN_type.h\n\n\nVN_user.c\n\n\nVN_user.h\n\n\nVN100.c\n\n\nVN100.h\n\n\nvoltageSensor.c\n\n\nvoltageSensor.h\n\n\n\n\nCoding Convention\n\n\nThe coding convention form this project follows the standard coding convention for the C language.\n\n\nThe rule-set for the coding format is not extremely specific. However, there are a few rules of thumb to be aware of. The rules of thumb are:\n\n\n\n\nNaming convention\n -\u0093 Use \ncamelCase\n notation for variables. Use capitals and \nunder_score_case\n for constants.\n\n\nIndentation Style\n -\u0093 Use tabs/indents to show the program structure.\n\n\nCommenting -\u0093 Be thorough with comments. Include a header at the beginning of every file describing the file, the author, the file name, and the date of creation. For headers, include comments describing any constants, and for each function prototype include the function name, function inputs and outputs, and a description of its functionality.\n\n\nNever hard-code values\n. Any constants should be defined together so that they can be easily changed through iterations of the code.", 
            "title": "Introduction"
        }, 
        {
            "location": "/picpilot/introduction/#introduction", 
            "text": "The PICpilot is a software package meant to control fixed-wing aircraft and numerous \"copters\", among other vehicles. It requires the usage of a specific type of digital signal microcontroller. This microcontroller is produced by  Microchip . The microcontroller that is currently supported is the  dspic33fj256gp710A . However, many other similar models can be easily adapted for support.  This software is designed to be used with two communicating microcontrollers (essential double cores). Due to the atypical nature of the software, it is recommended to view the board schematics  here . The schematics are also included in another section of this document.  The two processors are allocated to two individual tasks. The chip which is responsible for attitude management is often referred to as the \"main\" chip. It is responsible for making corrections to the planes orientation in space, which involves pitch, roll, yaw, heading, throttle, and altitude. It also manages a few additional tasks involving relaying communication with the ground station. The second processor is often referred to as the \"Path Manager\". This chip controls the where the plane should fly (path), and the transitions in altitude and heading between each waypoint (specific GPS coordinates). It also controls the GPS and altitude sensors. These two chips work asynchronously from one another in order to automate the plane.", 
            "title": "Introduction"
        }, 
        {
            "location": "/picpilot/introduction/#setup", 
            "text": "To get started, you will need three things:  A Git Client - https://github.com/  MPLAB XC16 Compiler (16-bit) - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2\n* (Optional) MPLAB X IDE - http://www.microchip.com/pagehandler/en-us/family/mplabx/home.html?tab=t2#tab-2", 
            "title": "Setup"
        }, 
        {
            "location": "/picpilot/introduction/#github-setup", 
            "text": "A similar powerpoint presentation can be found here: https://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing  If you are not using the GUI skip this section.   Setup a  Github  Account  Select \"Set up Git\"  Select \"Download GitHub for  \"  Select \"Run\" and continue through the installation process  Once the installation is complete, launch the application.  Log in  Find the Git Bash shell and type in the following commands:  git config global user.name \"YOUR USERNAME HERE\"  git config global user.email \"YOUR EMAIL HERE\" \nThese set the default name and email you use when committing to GitHub.  At this point you will need to let one of the WARG team leads know your username, so that you can be added to the repository member's list.  You should then be able to clone the project using the clone button, or the project URL.     You should now have the code.", 
            "title": "Github Setup"
        }, 
        {
            "location": "/picpilot/introduction/#mplab-setup", 
            "text": "You now need the libraries and compilers, as well as the optional MPLAB X IDE, in order to develop code.  Compiler   Download the  compiler . You want the MPLAB XC16 Compiler V1.21 or newer. Unzip the file once it is completed.  Accept the license agreement.  Select \"Install Compiler\".  Select \"Install MPLAB XC16 C Compiler on this computer.  Leave the activation key blank. Confirm \"Yes\" when the dialog prompts you about using the free version.  Select \"Run the compiler in free mode\".  Select the installation directory.   Run and finish the installation.    Note whenever you make a new project, make sure the right compiler is selected, otherwise there will be a lot of indicated syntax errors (red underlines).    IDE (The fancy word editor that lets you do some code-shenanigans)   Download the  IDE Package . You want the MPLAB X IDE V2.10 or newer. Unzip the file once it is completed.  Proceed through the installation process (select installation directory, accept license agreement).", 
            "title": "MPLAB Setup"
        }, 
        {
            "location": "/picpilot/introduction/#github-usage", 
            "text": "If you don't know how to use Git or you need a reference,  GitImmersion  is a great website.  GUI Usage:   Make sure you have correctly set your default storage location in the Options menu.     Saving Files (Committing and Pushing)      Select your Project  Select the files that are supposed to be committed.  Write a commit message, that gives a general overview about each change completed in this update.  Hit \"Commit\".  Once you are ready to sync the changes, hit the sync button (top of the window).   Reading Files from the Server (Pulling) \n* Simply click the sync button at top of the window.  General Syntax (Git Bash):   git add  Filename  or git add .  stages the file for commit.  git status  displays all changes being made.  git commit -m \" Commit message here \"  makes the change.  git push  sends the change to the server  git pull  retrieves the latest change from the server.  git checkout  HASH  retrieves a SPECIFIC version from the server.  git checkout -b  Branch Name  creates a new branch.  git merge master  merges the current branch with the latest code.   General Concepts:   When making small changes it is okay to commit to the master branch.  When making large changes (that take multiple days to complete), always make a branch, so that others can work concurrently without compiling broken code.  Always build your code before committing (To make sure it isn't broken).  Try and get rid of warnings if possible.", 
            "title": "GitHub Usage"
        }, 
        {
            "location": "/picpilot/introduction/#c-programming-language", 
            "text": "The language being used in this project is C. If you are familiar with C++, the concepts are very similar. C is a low level programming language. This means that it does not have a large amount of \"built-in\" functionality, therefore learning C is quite straight forward.  The compiler used for this project is listed above. It is a modified version of the GCC Compiler.  A set of well maintained tutorials can be found here:  http://www.cprogramming.com/tutorial/c/lesson1.html  Topics that one should be familiar with include (in order of importance):   If statements  Looping  Functions  Variable types and how they work  Arrays  Pointers  Structures, Unions   Unrelated topics:   Printf (There is no GUI)  File I/O (All I/O operations are specific to the chip)   Knowledge of common data structures (binary trees, linked lists, etc.) is beneficial, but not mandatory.", 
            "title": "C (Programming Language)"
        }, 
        {
            "location": "/picpilot/introduction/#programming-the-device", 
            "text": "In order to program the device, you must have setup your account according to the Setup section. You should also refer to the Schematics and Board Design section for the ports required to complete the programming process. You will require an ICD 3 or a similar programming device.  When using the MPLAB X GUI the process to program the device is as follows:  -\n  1. Ensure the project you wish to program is the main project.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Click the \"Make and Program Device\" button in the top toolbar. Optionally, you can also press the debug button to use the debugging features of MPLAB X.  When using your own editor and compiling from the command line:  -\n  1. Have the binary file ready for programming.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Open the MPLAB IPE interface.\n  4. Select your chip model.\n  5. For the source option, browse to your binary file.\n  6. Press program and wait. Then optionally also use the verify option (recommended).  If you are using both chips of the PICpilot, ensure you correctly set the chip identifier pre-compiler in the main.h file, and ensure you program both chips.", 
            "title": "Programming the Device"
        }, 
        {
            "location": "/picpilot/introduction/#autopilot-system-overview", 
            "text": "The autopilot system is meant to be adaptable to any aircraft including fixed-wing and multi-rotor aircraft (still WIP). This document mostly covers the software design of the system, although there are a few hardware notes made in this section and the next.  First of all, the flowchart block diagram of the system is presented below:   From this diagram you can see how the software combined with the hardware interacts to provide the final resulting UAV behaviour.  There are three chips. The main one is most commonly referred to as the attitude manager. It is also the communication manager, and the Master chip for all interchip communication. The other chip is referred to as the path manager. The third one has the dedicated task of managing the mechanical \"safety\" relays which ensure that a safety pilot can always regain control of the aircraft.  There are four sensors used in the original design of the aircraft. A GPS (Global Positioning System), IMU (Inertial Measurement Unit), Altimeter, and a camera are all part of the system. Additionally, 2 wireless interfaces are included in the design. A wireless Xbee transmitter/receiver provides telemetry data, whereas an additional (Ultra-high frequency [UHF]) receiver is used to attain control from a standard RC controller.  The outputs from the system include pictures and potentially video, telemetry data, and a functioning aircraft (with moving flaps, elevators, rudder, and ailerons).  This document only covers the PICpilot, however a system overview of a previously fully assembled system will be described in this section. In the past, the PICpilot has been expanded into a larger and more sophisticated system as seen below.", 
            "title": "Autopilot System Overview"
        }, 
        {
            "location": "/picpilot/introduction/#schematics-and-board-design", 
            "text": "The following schematic was last used at the time of the writing this document. The following schematic was last updated in 2011. You can check out the board schematics  here . They may also be available within the Github repository. You will require  Diptrace  in order to view the files. You can use the free version or use WARG's \"Pro\" license.   This board has 2 dspic33fj256710a chips. This is the PCB for the board. This is the labelled version:     Microcontroller 1 -\u0093 Attitude/Communication Manager    Microcontroller 2 -\u0093 Path Manager    Input PWM    Output PWM    Output PWM Safety Relay    Output PWM Safety Relay Microcontroller    Output PWM Safety Relay Microcontroller Programming Port    Microcontroller 2 Programming Port    SPI2 Port - VectorNav-100    SPI2 Ports -\u0093 GPS    Switching Power Supply 1    Switching Power Supply 2    Voltage Regulator    SPI2 Port -\u0093 Used as a power source for the altimeter    UART1 Port -\u0093 Debug    UART2 Port -\u0093 Wireless Transmitter (Xbee)    SPI2 Port -\u0093 Altimeter    UART1 Port -\u0093 Debug    UART2 Port -\u0093 Unused    Microcontroller 2 Programming Port    PWM input/output -\u0093 Sonar    The important pins are listed below:   The schematics for the board are below:", 
            "title": "Schematics and Board Design"
        }, 
        {
            "location": "/picpilot/introduction/#project-files", 
            "text": "All the project files are hosted on Github. However, for convenience they are listed below (accurate at the time of writing of this document):   AttitudeManager.c  AttitudeManager.h  cameraManager.c  cameraManager.h  Clock.c  Clock.h  commands.h  debug.c  debug.h  delay.c  delay.h  fmath.c  fmath.h  FullInitialize.c  FullInitialize.h  I2C.c  I2C.h  InputCapture.c  InputCapture.h  InterchipDMA.c  InterchipDMA.h  lcd.h  main.c  main.h  MPL3115A2.c  MPL3115A2.h  net.h  net_common.c  net_inbound.c  net_outbound.c  OrientationControl.c  OrientationControl.h  OutputCompare.c  OutputCompare.h  PathManager.h  PathManager.c  PWM.c  PWM.h  SPI.c  StartupErrorCodes.c  StartupErrorCodes.h  StringUtils.c  StringUtils.h  UART1.c  UART1.h  UART2.c  UART2.h  VN_lib.c  VN_lib.h  VN_math.c  VN_math.h  VN_type.h  VN_user.c  VN_user.h  VN100.c  VN100.h  voltageSensor.c  voltageSensor.h", 
            "title": "Project files"
        }, 
        {
            "location": "/picpilot/introduction/#coding-convention", 
            "text": "The coding convention form this project follows the standard coding convention for the C language.  The rule-set for the coding format is not extremely specific. However, there are a few rules of thumb to be aware of. The rules of thumb are:   Naming convention  -\u0093 Use  camelCase  notation for variables. Use capitals and  under_score_case  for constants.  Indentation Style  -\u0093 Use tabs/indents to show the program structure.  Commenting -\u0093 Be thorough with comments. Include a header at the beginning of every file describing the file, the author, the file name, and the date of creation. For headers, include comments describing any constants, and for each function prototype include the function name, function inputs and outputs, and a description of its functionality.  Never hard-code values . Any constants should be defined together so that they can be easily changed through iterations of the code.", 
            "title": "Coding Convention"
        }, 
        {
            "location": "/picpilot/pid-loops/", 
            "text": "PID Loops\n\n\nPID Loops are vital to the functionality of the PICpilot Autopilot software. UAV systems (especially fixed-wing) are difficult to characterize through a mathematical model. Hence, a control algorithm, such as a PID loop, simplifies the process. It does so by making small changes to the system at regular intervals. The algorithm tracks changes in the past (short term and long term) and the present to be adaptive to future conditions. For instance, if a sudden disturbance is introduced into the system, differential control will compensate and attempt to stabilize the system.\n\n\nThe letters \"PID\" stand for:\n\n\n\n\n\n\nProportional Control \u2013 This stabilizes any instantaneous changes to the system\n\n\n\n\n\n\nIntegral Control \u2013 This stabilizes and reduces long-term error in the system\n\n\n\n\n\n\nDerivative Control \u2013 This stabilizes abrupt changes (large derivative values).\n\n\n\n\n\n\nPI systems are usually more common than PID systems. Nonetheless, a common PID system would look like this:\n\n\n\n\nA common PID control loop\n\n\nIn a PID system, the input, r(t), is compared with the output, y(t), in the time domain. The subtraction between these two values yields the error, e(t). The error is then fed into the PID modules. Note each module contains a constant Kd, Kp, Ki. These are scaling factors. They determine the proportions in which each module adds together.\n\n\nFor the proportional module, the error is simply multiplied by a factor.\n\n\nFor the integral module, the error is integrated over time, before being multiplied by its corresponding factor.\n\n\nFor the derivative module, the error is differentiated at each time step, before being multiplied by its corresponding factor.\n\n\nThese three values are added together to determine u(t), which controls the system (plane, quadcopter, etc.). This can be expressed through the following code segment:\n\n\nint controlSignal = (int)(HEADING_ROLL_SCALE_FACTOR * ((dValue * kd_gain[HEADING]) + (error * kp_gain[HEADING]) + (sum_gain[HEADING] * ki_gain[HEADING])));\n\n\nWhere \nHEADING_ROLL_SCALE _FACTOR\n is a dimensionless scale factor.\n\n\nWhere \ndValue\n is the derivative.\n\n\nWhere \nsum_gain\n is the integral summation over time.\n\n\nWhere \nerror\n is the setpoint minus the output.\n\n\nWhere \nkd_gain\n is the derivative gain.\n\n\nWhere \nkp_gain\n is the proportional gain.\n\n\nWhere \nki_gain\n is the integral gain.\n\n\nNote that abrupt changes would affect the derivative term, gradual drift would affect the integral term, and anything in between would affect the proportional term.\n\n\nThe PID model used in the PICpilot is slightly different. Some modules are rearranged, and a hierarchy of PID loops is present.\n\n\nRate Control\n\n\nRate control is the basis of most aerial aircraft. The flaps on the wings of a plane control the rate at which it turns or rotates, but not the actual angle of the aircraft. For instance, if the flaps on a fixed wing aircraft were fully deflected, the aircraft would continuously spin out of control. It will not stop at a certain angle. In that sense, you control the \nrate of angular rotation\n, also known as the derivative. Likewise, the sensors on the aircraft (gyroscopes), measure the rate of rotation (derivative). This provides an interesting PID system. This PID loop only contains the derivative term. Hence the name \"rate control\".  The rate control diagram looks like this:\n\n\n\n\nRate control PID loop\n\n\nThe equation that relates the input with the output is:\n\n\nControl Signal = (dx \u2013 dy) * Kd\n\n\nControl Signal = de * Kd\n\n\nRate Control - In The Code\n\n\nRate Control takes place at the end of the program execution cycle. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function that completes the calculation is called:\n\n\nint controlSignal(float setpoint, float output, unsigned char type)\n\n\nThis function is responsible for the angular rates of the plane. It contains the differential equations that are part of the PID control system. It calculates the derivative term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg/s or rad/s). The units depend on the value of SERVO_SCALE_FACTOR which can be changed for various units. The original value was degrees per second.\n\n\nAngular Control\n\n\nOnce the roll, pitch, and yaw of the aircraft are empirically controlled (using the rate control code), the roll, pitch, and yaw can then be controlled in terms of angles. In other words, this PI controller allows the aircraft to be commanded to maintain a certain angle in the air, such as a 30 degree bank angle. This allows the aircraft to be controlled by the autopilot to turn, as well as alter its altitude.\n\n\nAn Inertial Measurement Unit (IMU) provides the sensory information required to control the plane in this manner. The IMU usually uses a Kalman filter and state estimation (using integration) to determine the position of the unit.\n\n\nThe resulting angular control PI loop incorporates the rate control loop from the section above. The angular control diagram looks like this:\n\n\n\n\nAngular Control PID Loop\n\n\nThe equations that relate r(t) and dx(t) are:\n\n\ndx(t) = (r \u2013 y) * Kp + Ki * integral(r-y,dt)\n\n\ndx(t) = e * Kp + Ki * integral(e,dt)\n\n\nAngular Control \u2013 In The Code\n\n\nAngular control code takes place right before the rate control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:\n\n\nint controlSignalAngles(float setpoint, float output, unsigned char type, float SERVO_SCALE_FACTOR_ANGLES)\n\n\nThis function is responsible for the orientation of the plane. It contains the equations that model a PID control system. It calculates the proportional and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg or rad), where the units depend on the value of SERVO_SCALE_FACTOR_ANGLES which can be changed for various units.\n\n\nHeading Control\n\n\nOnce rudimentary control of the aircraft is attained using the angular control loop and the rate control loop, the position of the aircraft can be controlled. As a result, the next control loop controls the heading of the aircraft. For instance, the plane can be directed at a 30 degree magnetic heading, and it will maintain that heading for as long as is required.\n\n\nThe measurements come from an external GPS sensor. The sensor measurements can also come from other sources, but they need to be in units of degrees. Currently, the calculations are done in degrees.\n\n\nThis control system uses the commonly recognized PID loop structure:\n\n\n\n\nHeading Control PID Loop\n\n\nThe equations that relate r(t) and h(t) are:\n\n\nr(t) = Kd * d(h \u2013 \u03b8)/dt + (h \u2013 \u03b8) * Kp + Ki * integral(h \u2013 \u03b8,dt)\n\n\nr(t) = Kd * de/dt + e * Kp + Ki * integral(e,dt)\n\n\nHeading Control \u2013 In The Code\n\n\nHeading control code takes place right before the angular control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:\n\n\nint controlSignalHeading(int setpoint, int output)\n\n\nThis function is responsible for steering the plane in the correct direction. It contains the equations that model a PID control system. It calculates the derivative, proportional, and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (currently in degrees).\n\n\nThis function completes a comparison between the setpoint and the output, and then decides if it should turn left or right. When the setpoint and the output are subtracted, the resulting error is set to be between -180 and +180, where -180 degrees indicates the requirement to bank left and +180 degrees indicates the requirement to bank right.\n\n\nThe remainder of the PID control is the same. An integrator, derivative, and proportional term is present.\n\n\nAltitude and Throttle Control\n\n\nAltitude and Throttle control are two separate control loops. However, they are highly dependent on one another. For instance, if the throttle is increased, the plane has a natural tendency to gain altitude. Likewise, if the throttle is decreased, the plane has a natural tendency to lose altitude. Likewise, the opposite is true; if the plane gains or losses altitude, the airspeed of the aircraft changes.\n\n\nBoth altitude and throttle control is established by the use of PID loops. Currently, altitude uses the \nproportional\n and _derivative _terms, whereas, throttle uses only the _proportional _term. You can determine this by looking at the gain settings for each PID loop (if the gain is zero, the respective PID term is unused).\n\n\nGenerally, the throttle control should be regulated using an airspeed sensor, in order to keep the airspeed constant. However, in cases where there is no airspeed sensor (such as in SPIKE), altitude is used directly to calculate both the throttle and the pitch angle (to change the altitude). This directly affects airspeed and altitude, and if properly tuned is quite effective. This is the appropriate PID diagram for a non-airspeed sensor setup:\n\n\n\n\nAltitude and Throttle Control PID Loop \u2013 No airspeed sensor\n\n\n\n\nAltitude and Throttle Control PID Loop \u2013 Airspeed sensor\n\n\nAltitude and Throttle Control \u2013 In The Code\n\n\nIn the PIC pilot software, altitude control is dependent on a PID loop. Currently, the integral term is implemented, but unused. On the other hand, the throttle control only uses the proportional term and the integral term. The derivative term is negligible. Currently, the integral term is unused (for SPIKE) and thus only the proportional term is used. The function responsible for the PID control of the altitude is:\n\n\nint controlSignalAltitude(int sp_Altitude,int gps_Altitude);\n\n\nThis function is responsible for the altitude control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of meters above the initial starting point.\n\n\nThe two parameters used to call the function are the setpoint (sp_Altitude) and the sensor output (gps_Altitude). These are then used to calculate the corresponding error.\n\n\nThe function responsible for the PID control of the throttle is:\n\n\nint controlSignalThrottle(int setpoint, int output);\n\n\nThis function is responsible for the throttle control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of percentage from no throttle (0%) to full throttle (100%).\n\n\nThe two parameters used to call the function are the setpoint and the sensor output. These are then used to calculate the corresponding error.\n\n\nTotal PID Control Overview\n\n\nThe total control diagram can be approximated with the flow chart below:\n\n\n\n\nTuning PID Loops\n\n\nAs explained above, PID loops keep unstable systems stable via input through (primarily) electronic means. In order to do so, one must analyze the transfer functions of the system and determine PID control gains, or more practically develop these gains from empirically testing the system.\n\n\nThe empirical method which WARG employs in the PID tuning is called the \nZieger-Nichols Method\n. This method involves a tuning procedure with the assistance of the following chart:\n\n\n\n\n\n\n\n\nControl Type\n\n\nKp\n\n\nKi\n\n\nKd\n\n\n\n\n\n\n\n\n\n\nP\n\n\n0.5Ku\n\n\n-\n\n\n-\n\n\n\n\n\n\nPI\n\n\n0.45Ku\n\n\n1.2Kp/Tu\n\n\n-\n\n\n\n\n\n\nPD\n\n\n0.8Ku\n\n\n-\n\n\nKpTu/8\n\n\n\n\n\n\nClassic PID\n\n\n0.6Ku\n\n\n2Kp/Tu\n\n\nKpTu/8\n\n\n\n\n\n\nPessen Integral Rule\n\n\n0.7Ku\n\n\n2.5Kp/Tu\n\n\n3KpTu/20\n\n\n\n\n\n\nSome Overshoot\n\n\n0.33Ku\n\n\n2Kp/Tu\n\n\nKpTu/3\n\n\n\n\n\n\nNo Overshoot\n\n\n0.2Ku\n\n\n2Kp/Tu\n\n\nKpTu/3\n\n\n\n\n\n\n\n\nAs a general rule, flying a vehicle requires minimal overshoot and maximum disturbance rejection. The \"Some Overshoot\" control type is unwanted in aerial applications.\n\n\nThe tuning procedure is as follows:\n\n\n\n\nBegin with roll. Increase the proportional gain until the plane oscillates with a constant period and amplitude.\n\n\nRetrieve the data, plot it in excel and determine the period of oscillation (Tu\u00ad). The proportional gain at which the vehicle began to oscillate is the Ultimate Gain (Ku). Use the above chart to determine the appropriate gain values.\n\n\nReset all the gains. Repeat steps 1 and 2 for pitch and yaw (if need be).\n\n\nRepeat steps 1 and 2, but with all the calculated gains running on the system. This step will fine tune all the values since pitch, roll, and yaw are interdependent. You will only need to repeat this step, whenever making changes to the PID setup or any crucial component on the system itself.", 
            "title": "PID Loops"
        }, 
        {
            "location": "/picpilot/pid-loops/#pid-loops", 
            "text": "PID Loops are vital to the functionality of the PICpilot Autopilot software. UAV systems (especially fixed-wing) are difficult to characterize through a mathematical model. Hence, a control algorithm, such as a PID loop, simplifies the process. It does so by making small changes to the system at regular intervals. The algorithm tracks changes in the past (short term and long term) and the present to be adaptive to future conditions. For instance, if a sudden disturbance is introduced into the system, differential control will compensate and attempt to stabilize the system.  The letters \"PID\" stand for:    Proportional Control \u2013 This stabilizes any instantaneous changes to the system    Integral Control \u2013 This stabilizes and reduces long-term error in the system    Derivative Control \u2013 This stabilizes abrupt changes (large derivative values).    PI systems are usually more common than PID systems. Nonetheless, a common PID system would look like this:   A common PID control loop  In a PID system, the input, r(t), is compared with the output, y(t), in the time domain. The subtraction between these two values yields the error, e(t). The error is then fed into the PID modules. Note each module contains a constant Kd, Kp, Ki. These are scaling factors. They determine the proportions in which each module adds together.  For the proportional module, the error is simply multiplied by a factor.  For the integral module, the error is integrated over time, before being multiplied by its corresponding factor.  For the derivative module, the error is differentiated at each time step, before being multiplied by its corresponding factor.  These three values are added together to determine u(t), which controls the system (plane, quadcopter, etc.). This can be expressed through the following code segment:  int controlSignal = (int)(HEADING_ROLL_SCALE_FACTOR * ((dValue * kd_gain[HEADING]) + (error * kp_gain[HEADING]) + (sum_gain[HEADING] * ki_gain[HEADING])));  Where  HEADING_ROLL_SCALE _FACTOR  is a dimensionless scale factor.  Where  dValue  is the derivative.  Where  sum_gain  is the integral summation over time.  Where  error  is the setpoint minus the output.  Where  kd_gain  is the derivative gain.  Where  kp_gain  is the proportional gain.  Where  ki_gain  is the integral gain.  Note that abrupt changes would affect the derivative term, gradual drift would affect the integral term, and anything in between would affect the proportional term.  The PID model used in the PICpilot is slightly different. Some modules are rearranged, and a hierarchy of PID loops is present.", 
            "title": "PID Loops"
        }, 
        {
            "location": "/picpilot/pid-loops/#rate-control", 
            "text": "Rate control is the basis of most aerial aircraft. The flaps on the wings of a plane control the rate at which it turns or rotates, but not the actual angle of the aircraft. For instance, if the flaps on a fixed wing aircraft were fully deflected, the aircraft would continuously spin out of control. It will not stop at a certain angle. In that sense, you control the  rate of angular rotation , also known as the derivative. Likewise, the sensors on the aircraft (gyroscopes), measure the rate of rotation (derivative). This provides an interesting PID system. This PID loop only contains the derivative term. Hence the name \"rate control\".  The rate control diagram looks like this:   Rate control PID loop  The equation that relates the input with the output is:  Control Signal = (dx \u2013 dy) * Kd  Control Signal = de * Kd", 
            "title": "Rate Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#rate-control-in-the-code", 
            "text": "Rate Control takes place at the end of the program execution cycle. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function that completes the calculation is called:  int controlSignal(float setpoint, float output, unsigned char type)  This function is responsible for the angular rates of the plane. It contains the differential equations that are part of the PID control system. It calculates the derivative term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg/s or rad/s). The units depend on the value of SERVO_SCALE_FACTOR which can be changed for various units. The original value was degrees per second.", 
            "title": "Rate Control - In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#angular-control", 
            "text": "Once the roll, pitch, and yaw of the aircraft are empirically controlled (using the rate control code), the roll, pitch, and yaw can then be controlled in terms of angles. In other words, this PI controller allows the aircraft to be commanded to maintain a certain angle in the air, such as a 30 degree bank angle. This allows the aircraft to be controlled by the autopilot to turn, as well as alter its altitude.  An Inertial Measurement Unit (IMU) provides the sensory information required to control the plane in this manner. The IMU usually uses a Kalman filter and state estimation (using integration) to determine the position of the unit.  The resulting angular control PI loop incorporates the rate control loop from the section above. The angular control diagram looks like this:   Angular Control PID Loop  The equations that relate r(t) and dx(t) are:  dx(t) = (r \u2013 y) * Kp + Ki * integral(r-y,dt)  dx(t) = e * Kp + Ki * integral(e,dt)", 
            "title": "Angular Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#angular-control-in-the-code", 
            "text": "Angular control code takes place right before the rate control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:  int controlSignalAngles(float setpoint, float output, unsigned char type, float SERVO_SCALE_FACTOR_ANGLES)  This function is responsible for the orientation of the plane. It contains the equations that model a PID control system. It calculates the proportional and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg or rad), where the units depend on the value of SERVO_SCALE_FACTOR_ANGLES which can be changed for various units.", 
            "title": "Angular Control \u2013 In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#heading-control", 
            "text": "Once rudimentary control of the aircraft is attained using the angular control loop and the rate control loop, the position of the aircraft can be controlled. As a result, the next control loop controls the heading of the aircraft. For instance, the plane can be directed at a 30 degree magnetic heading, and it will maintain that heading for as long as is required.  The measurements come from an external GPS sensor. The sensor measurements can also come from other sources, but they need to be in units of degrees. Currently, the calculations are done in degrees.  This control system uses the commonly recognized PID loop structure:   Heading Control PID Loop  The equations that relate r(t) and h(t) are:  r(t) = Kd * d(h \u2013 \u03b8)/dt + (h \u2013 \u03b8) * Kp + Ki * integral(h \u2013 \u03b8,dt)  r(t) = Kd * de/dt + e * Kp + Ki * integral(e,dt)", 
            "title": "Heading Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#heading-control-in-the-code", 
            "text": "Heading control code takes place right before the angular control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:  int controlSignalHeading(int setpoint, int output)  This function is responsible for steering the plane in the correct direction. It contains the equations that model a PID control system. It calculates the derivative, proportional, and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (currently in degrees).  This function completes a comparison between the setpoint and the output, and then decides if it should turn left or right. When the setpoint and the output are subtracted, the resulting error is set to be between -180 and +180, where -180 degrees indicates the requirement to bank left and +180 degrees indicates the requirement to bank right.  The remainder of the PID control is the same. An integrator, derivative, and proportional term is present.", 
            "title": "Heading Control \u2013 In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#altitude-and-throttle-control", 
            "text": "Altitude and Throttle control are two separate control loops. However, they are highly dependent on one another. For instance, if the throttle is increased, the plane has a natural tendency to gain altitude. Likewise, if the throttle is decreased, the plane has a natural tendency to lose altitude. Likewise, the opposite is true; if the plane gains or losses altitude, the airspeed of the aircraft changes.  Both altitude and throttle control is established by the use of PID loops. Currently, altitude uses the  proportional  and _derivative _terms, whereas, throttle uses only the _proportional _term. You can determine this by looking at the gain settings for each PID loop (if the gain is zero, the respective PID term is unused).  Generally, the throttle control should be regulated using an airspeed sensor, in order to keep the airspeed constant. However, in cases where there is no airspeed sensor (such as in SPIKE), altitude is used directly to calculate both the throttle and the pitch angle (to change the altitude). This directly affects airspeed and altitude, and if properly tuned is quite effective. This is the appropriate PID diagram for a non-airspeed sensor setup:   Altitude and Throttle Control PID Loop \u2013 No airspeed sensor   Altitude and Throttle Control PID Loop \u2013 Airspeed sensor", 
            "title": "Altitude and Throttle Control"
        }, 
        {
            "location": "/picpilot/pid-loops/#altitude-and-throttle-control-in-the-code", 
            "text": "In the PIC pilot software, altitude control is dependent on a PID loop. Currently, the integral term is implemented, but unused. On the other hand, the throttle control only uses the proportional term and the integral term. The derivative term is negligible. Currently, the integral term is unused (for SPIKE) and thus only the proportional term is used. The function responsible for the PID control of the altitude is:  int controlSignalAltitude(int sp_Altitude,int gps_Altitude);  This function is responsible for the altitude control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of meters above the initial starting point.  The two parameters used to call the function are the setpoint (sp_Altitude) and the sensor output (gps_Altitude). These are then used to calculate the corresponding error.  The function responsible for the PID control of the throttle is:  int controlSignalThrottle(int setpoint, int output);  This function is responsible for the throttle control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of percentage from no throttle (0%) to full throttle (100%).  The two parameters used to call the function are the setpoint and the sensor output. These are then used to calculate the corresponding error.", 
            "title": "Altitude and Throttle Control \u2013 In The Code"
        }, 
        {
            "location": "/picpilot/pid-loops/#total-pid-control-overview", 
            "text": "The total control diagram can be approximated with the flow chart below:", 
            "title": "Total PID Control Overview"
        }, 
        {
            "location": "/picpilot/pid-loops/#tuning-pid-loops", 
            "text": "As explained above, PID loops keep unstable systems stable via input through (primarily) electronic means. In order to do so, one must analyze the transfer functions of the system and determine PID control gains, or more practically develop these gains from empirically testing the system.  The empirical method which WARG employs in the PID tuning is called the  Zieger-Nichols Method . This method involves a tuning procedure with the assistance of the following chart:     Control Type  Kp  Ki  Kd      P  0.5Ku  -  -    PI  0.45Ku  1.2Kp/Tu  -    PD  0.8Ku  -  KpTu/8    Classic PID  0.6Ku  2Kp/Tu  KpTu/8    Pessen Integral Rule  0.7Ku  2.5Kp/Tu  3KpTu/20    Some Overshoot  0.33Ku  2Kp/Tu  KpTu/3    No Overshoot  0.2Ku  2Kp/Tu  KpTu/3     As a general rule, flying a vehicle requires minimal overshoot and maximum disturbance rejection. The \"Some Overshoot\" control type is unwanted in aerial applications.  The tuning procedure is as follows:   Begin with roll. Increase the proportional gain until the plane oscillates with a constant period and amplitude.  Retrieve the data, plot it in excel and determine the period of oscillation (Tu\u00ad). The proportional gain at which the vehicle began to oscillate is the Ultimate Gain (Ku). Use the above chart to determine the appropriate gain values.  Reset all the gains. Repeat steps 1 and 2 for pitch and yaw (if need be).  Repeat steps 1 and 2, but with all the calculated gains running on the system. This step will fine tune all the values since pitch, roll, and yaw are interdependent. You will only need to repeat this step, whenever making changes to the PID setup or any crucial component on the system itself.", 
            "title": "Tuning PID Loops"
        }, 
        {
            "location": "/picpilot/pwm-io/", 
            "text": "PWM and IO\n\n\nPWM stands for Pulse Width Modulation. This means that digital or analog data is encoded through the use of square wave electrical signals, where the width of the square wave determines the value of the data. For instance, in UAVs, a larger square wave will add more throttle, whereas a smaller square wave will add less throttle. The same concepts apply to the ailerons, flaps, rudder, and elevators. A PWM signal can be plotted on a voltage - time plot to attain the following graph:\n\n\n\n\nFor this application, the most common pulse width for a square wave is 1.5 milliseconds. This value represents the zero position for all control surfaces. The maximum value for the square wave is 2 milliseconds. The minimum value is 1 millisecond. Likewise, when using throttle, a 1 millisecond square wave is 0% throttle, and a 2 millisecond square wave is 100% throttle. For instance, here is a diagram of 3 consecutive pulses, which command the plane to throttle to 100%, followed by 50%, followed by 0%:\n\n\n\n\nThe duty cycle or period specifies the frequency of the pulses. For servo motors, the period is 22.5 milliseconds. This means that one square wave should be detected every 22.5 milliseconds. If the period is unreasonably short, or unreasonably long, the servo motor may seize, until the data is corrected. The allowable error range varies between speed controllers, but it is generally very forgiving (from experience). In general, make sure the period is more than 12 milliseconds and less than 25 milliseconds.\n\n\nThese PWM signals can be used to convey information as input and output to a digital signal controller (DSC). The input is often referred to as \"Input Capture\". The output is often referred to as \"Output Capture\". Each wire connection can handle one channel. The current implementation of the PICpilot supports 8 input channels and 8 output channels. Out of the 8 input channels, 6 are currently used. Out of the 8 output channels, 6 are currently used. The roll, pitch, throttle, yaw and the autopilot on/off channels are the most critical in order for the UAV to work. This encompasses 9 channels in total (5 inputs, 4 outputs).\n\n\nHardware\n\n\nThe dspic33fj256gp710a chip supports 16 channels (8 inputs and 8 outputs):\n\n\n\n\n\n\n\n\nChannel\n\n\nFunction\n\n\nPin/Port\n\n\nInput/Output\n\n\n\n\n\n\n\n\n\n\n1\n\n\nRoll\n\n\n68/RD8\n\n\nInput\n\n\n\n\n\n\n2\n\n\nPitch\n\n\n69/RD9\n\n\nInput\n\n\n\n\n\n\n3\n\n\nThrottle\n\n\n70/RD10\n\n\nInput\n\n\n\n\n\n\n4\n\n\nYaw\n\n\n71/RD11\n\n\nInput\n\n\n\n\n\n\n5\n\n\nUHF Switch\n\n\n79/RD12\n\n\nInput\n\n\n\n\n\n\n6\n\n\nN/A\n\n\n80/RD13\n\n\nInput\n\n\n\n\n\n\n7\n\n\nN/A\n\n\n47/RD14\n\n\nInput\n\n\n\n\n\n\n8\n\n\nAutopilot On/Off\n\n\n48/RD15\n\n\nInput\n\n\n\n\n\n\n1\n\n\nRoll\n\n\n72/RD0\n\n\nOutput\n\n\n\n\n\n\n2\n\n\nPitch\n\n\n76/RD1\n\n\nOutput\n\n\n\n\n\n\n3\n\n\nThrottle\n\n\n77/RD2\n\n\nOutput\n\n\n\n\n\n\n4\n\n\nYaw\n\n\n78/RD3\n\n\nOutput\n\n\n\n\n\n\n5\n\n\nCamera Shutter\n\n\n81/RD4\n\n\nOutput\n\n\n\n\n\n\n6\n\n\nCamera Gimbal\n\n\n82/RD5\n\n\nOutput\n\n\n\n\n\n\n7\n\n\nN/A\n\n\n83/RD6\n\n\nOutput\n\n\n\n\n\n\n8\n\n\nN/A\n\n\n84/RD7\n\n\nOutput\n\n\n\n\n\n\n\n\nEach pin has corresponding registers to determine the configuration for each pin. The input capture settings that can be configured include the clock source (for timing and comparison), edge detection (trigger on rising, falling or both), and interrupts (every event, or every 2, 3, or 4). For output compare, the settings that can be configured include the clock source, pulse type (single, continuous, high/low initialization).\n\n\nFor detailed hardware specifications see the Microchip website: \ndspic33fj256gp710A\n\n\nIn the Code\n\n\nThree files are in charge of controlling all the PWM signals. InputCapture.c, which contains all the functions used to manage input capture, OutputCompare.C, which contains all the functions used to manage output compare. Finally, PWM.c links these files together.\n\n\nPWM.c combines both input capture and output compare into a simple interface that is easy to manage and consistent to use. It then applies scaling factors to the arbitrary timer units, which map the Input Capture and Output Capture values to variables that range between -100 and 100.\n\n\nPWM.c contains 7 functions:\n\n\n\n\n\n\n\n\nFunction Name\n\n\nInput Variables\n\n\nOutput\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\ninitPWM\n\n\ninputChannels, outputChannels\n\n\nNone.\n\n\nThis function MUST be called before any other functions used below.The variables must be in binary representation. For example, channel 1, 2, and 5 enabled is: 0b00010011\n\n\n\n\n\n\nPWMInputCalibration\n\n\nchannel, signalScaleFactor, signalOffset\n\n\nNone.\n\n\nCalibrates the input from the controller so that the range outputs from -100 to 100.\n\n\n\n\n\n\nPWMOutputCalibration\n\n\nchannel, signalScaleFactor, signalOffset\n\n\nNone.\n\n\nCalibrates the output from the controller so that the range outputs from -100 to 100.\n\n\n\n\n\n\ngetPWM\n\n\nchannel\n\n\nInteger\n\n\nReturns the value (scaled) from the input of a certain channel.\n\n\n\n\n\n\ngetPWMArray\n\n\nNone.\n\n\nNone.\n\n\nReturns the value (scaled) from the input of all channels.\n\n\n\n\n\n\nsetPWM\n\n\nchannel, pwm\n\n\nNone.\n\n\nSets a certain output compare channel to a certain value according to the pwm range between -100 and 100.\n\n\n\n\n\n\nsetPWMArray\n\n\nocArray\n\n\nNone.\n\n\nSets all output compare channels to values stored in an array. These should be between -100 and 100.\n\n\n\n\n\n\n\n\nFor future use, the calibration functions should be coordinated with the ground station, in order to be able to calibrate the controller/plane sensitivities and limits \"on the go\".\n\n\nIt should be noted that the initialization procedure is necessary for the PWM IO functions to work.\n\n\nFor input capture, the settings that are initialized include (for channel 1):\n\n\n   IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module\n\n   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base\n\n   IC1CONbits.ICI = 0b11; // Interrupt on every capture event\n\n   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising and Falling edge\n\n   // Enable Capture Interrupt And Timer2\n\n   IPC0bits.IC1IP = 7; // Setup IC1 interrupt priority level - Highest\n\n   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag\n\n   IEC0bits.IC1IE = 1; // Enable IC1 interrupt\n\n\n\nThe initialization procedure selects a timer, setting for frequency of capture events, interrupt frequency, as well as other interrupt settings.\n\n\nFor output capture, the settings that are initialized include (for channel 1):\n\n\n// Initialize Output Compare Module\n\nOC1CONbits.OCM = 0b000; // Disable Output Compare Module\n\nOC1R = MIDDLE\\_PWM; // Write the duty cycle for the first PWM pulse = 1.5ms/4688\n\nOC1RS = MIDDLE\\_PWM; // Write the duty cycle for the second PWM pulse] = 1.5ms/4688\n\nOC1CONbits.OCTSEL = 0; // Select Timer 2 as output compare time base\n\nOC1CONbits.OCM = 0b110; // Select the Output Compare mode (without fault protection)\n\n\n\nThe initialization procedure selects a timer, initial duty cycle (this changes after the first program cycle), and output compare mode.\n\n\nLikewise, since both IC and OC use \ntimer2\n. An initialization of this component is also required:\n\n\nT2CONbits.TON = 0; // Disable Timer\n\nT2CONbits.TCS = 0; // Select internal instruction cycle clock\n\nT2CONbits.TGATE = 0; // Disable Gated Timer mode\n\nT2CONbits.TCKPS = 0b01; // Select 1:8 Prescaler\n\nTMR2 = 0x00; // Clear timer register\n\nsetPeriod(20);\n\nIPC1bits.T2IP = 0x01; // Set Timer 2 Interrupt Priority Level - Lowest\n\nIFS0bits.T2IF = 0; // Clear Timer 2 Interrupt Flag\n\nIEC0bits.T2IE = 1; // Enable Timer 2 interrupt\n\nT2CONbits.TON = 1; // Start Timer\n\n\n\nThe initialization procedure selects the clock source (internal instruction clock), selects a scaling amount (determined via oscilloscope measurements), sets the period of the pulse cycle (20ms), and enables the Timer2  interrupt (this is not used for PWM signals, it is used to keep track of the runtime of the chip).", 
            "title": "PWM and IO"
        }, 
        {
            "location": "/picpilot/pwm-io/#pwm-and-io", 
            "text": "PWM stands for Pulse Width Modulation. This means that digital or analog data is encoded through the use of square wave electrical signals, where the width of the square wave determines the value of the data. For instance, in UAVs, a larger square wave will add more throttle, whereas a smaller square wave will add less throttle. The same concepts apply to the ailerons, flaps, rudder, and elevators. A PWM signal can be plotted on a voltage - time plot to attain the following graph:   For this application, the most common pulse width for a square wave is 1.5 milliseconds. This value represents the zero position for all control surfaces. The maximum value for the square wave is 2 milliseconds. The minimum value is 1 millisecond. Likewise, when using throttle, a 1 millisecond square wave is 0% throttle, and a 2 millisecond square wave is 100% throttle. For instance, here is a diagram of 3 consecutive pulses, which command the plane to throttle to 100%, followed by 50%, followed by 0%:   The duty cycle or period specifies the frequency of the pulses. For servo motors, the period is 22.5 milliseconds. This means that one square wave should be detected every 22.5 milliseconds. If the period is unreasonably short, or unreasonably long, the servo motor may seize, until the data is corrected. The allowable error range varies between speed controllers, but it is generally very forgiving (from experience). In general, make sure the period is more than 12 milliseconds and less than 25 milliseconds.  These PWM signals can be used to convey information as input and output to a digital signal controller (DSC). The input is often referred to as \"Input Capture\". The output is often referred to as \"Output Capture\". Each wire connection can handle one channel. The current implementation of the PICpilot supports 8 input channels and 8 output channels. Out of the 8 input channels, 6 are currently used. Out of the 8 output channels, 6 are currently used. The roll, pitch, throttle, yaw and the autopilot on/off channels are the most critical in order for the UAV to work. This encompasses 9 channels in total (5 inputs, 4 outputs).", 
            "title": "PWM and IO"
        }, 
        {
            "location": "/picpilot/pwm-io/#hardware", 
            "text": "The dspic33fj256gp710a chip supports 16 channels (8 inputs and 8 outputs):     Channel  Function  Pin/Port  Input/Output      1  Roll  68/RD8  Input    2  Pitch  69/RD9  Input    3  Throttle  70/RD10  Input    4  Yaw  71/RD11  Input    5  UHF Switch  79/RD12  Input    6  N/A  80/RD13  Input    7  N/A  47/RD14  Input    8  Autopilot On/Off  48/RD15  Input    1  Roll  72/RD0  Output    2  Pitch  76/RD1  Output    3  Throttle  77/RD2  Output    4  Yaw  78/RD3  Output    5  Camera Shutter  81/RD4  Output    6  Camera Gimbal  82/RD5  Output    7  N/A  83/RD6  Output    8  N/A  84/RD7  Output     Each pin has corresponding registers to determine the configuration for each pin. The input capture settings that can be configured include the clock source (for timing and comparison), edge detection (trigger on rising, falling or both), and interrupts (every event, or every 2, 3, or 4). For output compare, the settings that can be configured include the clock source, pulse type (single, continuous, high/low initialization).  For detailed hardware specifications see the Microchip website:  dspic33fj256gp710A  In the Code  Three files are in charge of controlling all the PWM signals. InputCapture.c, which contains all the functions used to manage input capture, OutputCompare.C, which contains all the functions used to manage output compare. Finally, PWM.c links these files together.  PWM.c combines both input capture and output compare into a simple interface that is easy to manage and consistent to use. It then applies scaling factors to the arbitrary timer units, which map the Input Capture and Output Capture values to variables that range between -100 and 100.  PWM.c contains 7 functions:     Function Name  Input Variables  Output  Notes      initPWM  inputChannels, outputChannels  None.  This function MUST be called before any other functions used below.The variables must be in binary representation. For example, channel 1, 2, and 5 enabled is: 0b00010011    PWMInputCalibration  channel, signalScaleFactor, signalOffset  None.  Calibrates the input from the controller so that the range outputs from -100 to 100.    PWMOutputCalibration  channel, signalScaleFactor, signalOffset  None.  Calibrates the output from the controller so that the range outputs from -100 to 100.    getPWM  channel  Integer  Returns the value (scaled) from the input of a certain channel.    getPWMArray  None.  None.  Returns the value (scaled) from the input of all channels.    setPWM  channel, pwm  None.  Sets a certain output compare channel to a certain value according to the pwm range between -100 and 100.    setPWMArray  ocArray  None.  Sets all output compare channels to values stored in an array. These should be between -100 and 100.     For future use, the calibration functions should be coordinated with the ground station, in order to be able to calibrate the controller/plane sensitivities and limits \"on the go\".  It should be noted that the initialization procedure is necessary for the PWM IO functions to work.  For input capture, the settings that are initialized include (for channel 1):     IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module\n\n   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base\n\n   IC1CONbits.ICI = 0b11; // Interrupt on every capture event\n\n   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising and Falling edge\n\n   // Enable Capture Interrupt And Timer2\n\n   IPC0bits.IC1IP = 7; // Setup IC1 interrupt priority level - Highest\n\n   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag\n\n   IEC0bits.IC1IE = 1; // Enable IC1 interrupt  The initialization procedure selects a timer, setting for frequency of capture events, interrupt frequency, as well as other interrupt settings.  For output capture, the settings that are initialized include (for channel 1):  // Initialize Output Compare Module\n\nOC1CONbits.OCM = 0b000; // Disable Output Compare Module\n\nOC1R = MIDDLE\\_PWM; // Write the duty cycle for the first PWM pulse = 1.5ms/4688\n\nOC1RS = MIDDLE\\_PWM; // Write the duty cycle for the second PWM pulse] = 1.5ms/4688\n\nOC1CONbits.OCTSEL = 0; // Select Timer 2 as output compare time base\n\nOC1CONbits.OCM = 0b110; // Select the Output Compare mode (without fault protection)  The initialization procedure selects a timer, initial duty cycle (this changes after the first program cycle), and output compare mode.  Likewise, since both IC and OC use  timer2 . An initialization of this component is also required:  T2CONbits.TON = 0; // Disable Timer\n\nT2CONbits.TCS = 0; // Select internal instruction cycle clock\n\nT2CONbits.TGATE = 0; // Disable Gated Timer mode\n\nT2CONbits.TCKPS = 0b01; // Select 1:8 Prescaler\n\nTMR2 = 0x00; // Clear timer register\n\nsetPeriod(20);\n\nIPC1bits.T2IP = 0x01; // Set Timer 2 Interrupt Priority Level - Lowest\n\nIFS0bits.T2IF = 0; // Clear Timer 2 Interrupt Flag\n\nIEC0bits.T2IE = 1; // Enable Timer 2 interrupt\n\nT2CONbits.TON = 1; // Start Timer  The initialization procedure selects the clock source (internal instruction clock), selects a scaling amount (determined via oscilloscope measurements), sets the period of the pulse cycle (20ms), and enables the Timer2  interrupt (this is not used for PWM signals, it is used to keep track of the runtime of the chip).", 
            "title": "Hardware"
        }, 
        {
            "location": "/picpilot/uart/", 
            "text": "UART\n\n\nUART stands for Universal Asynchronous Receive Transmit. It is a protocol for chips to be able to communicate between on another. It is a serial form of communication, where each bit of data is transmitted along the same connection. The minimum hardware requirements look like this:\n\n\n\n\nNote that Tx represents the transmit port, Rx represents the receive port, and the GND represents the required ground connection.\n\n\nUART is convenient due to its simplicity. Note that the interface does not have a clock line or any special signalling channels. Most other methods of communication require a pulsing clock to determine the rate at which data is transferred from one component to another. UART is \"asynchronous\" and therefore the bits on the transfer line and the receive line do not need to be transmitted at the same instance in time. Instead, both chips have a predefined rate at which they transfer binary information to one another. This predefined rate is often determined by the user, or sometimes (very rarely) restricted by the manufacturer. This rate is referred to as the \nbaud rate\n. It is very similar to a bit rate.\n\n\nAs a side note (don't worry if you are confused), Bit rate is the number of \nbits_transferred per second. Baud rate is the number of _symbols\n transferred per second. A bit can be 0 or 1. A symbol carries different amounts of information in different technologies. For instance, in certain communication protocols, there can be 64 possible values for a single symbol. 64 values required 6 bits to be represented. Therefore, the baud rate is 6 times less than the bit rate.\n\n\nFor the UART communication protocol, the baud rate is equivalent to the bit rate, although \"baud\" is the correct terminology.\n\n\nAlthough UART can be used in both 8 bit mode and 16 bit mode, the PICpilot uses the 8 bit mode of communication as displayed below.\n\n\n\n\nFirst a start bit is sent\n\n\nThe message is then relayed in series\n\n\nThe stop bit(s) are then sent. (There can be 1 or 2 stop bits)\n\n\n\n\nThe stop and end bits indicate the beginning and the end of communication.\n\n\n\n\n\n\n\n\nBit number\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n\n\n\n\n\n\n\n\n\n\nStart bit\n\n\n5\u20138 data bits\n\n\nStop bit(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStart\n\n\nData 0\n\n\nData 1\n\n\nData 2\n\n\nData 3\n\n\nData 4\n\n\nData 5\n\n\nData 6\n\n\nData 7\n\n\nStop\n\n\n\n\n\n\n\n\n\n\n\n\nThe most common settings for the UART protocol include 8 data bits, no parity, 1 stop bit, and no flow control. Remember to make sure that the baud rate matches up, and NEVER connect Tx to Tx or Rx to Rx.\n\n\nIn case you do not know, parity is a special bit used to check the integrity of the data sent. It indicates whether or not the sum of the 8 bits must be odd or even. If this result does not match the parity bit, the microcontroller would know that the information is garbled.\n\n\nSecondly, flow control requires additional pins, where each peripheral signals the other one before it transmits and receives. This ensures that both chips are ready to communicate.\n\n\nThirdly, the terms full duplex and half duplex refer to a chip being able to multitask. Full duplex indicates that both chips send and receive at the same time. Half duplex indicates that only one chip sends and receives at a time. Usually, some type of flow control is required for half duplex systems.\n\n\nThis form of communication is used for two purposes on the PICpilot. It is used for the data link, as well as the debugging interface. The settings are listed below.\n\n\nIn the code\n\n\nEach dspic33fj256gp710a has two UART interfaces. They are labeled UART1 and UART2. In the code, two corresponding files are present: UART1.c and UART2.c (as well as their header files). UART1 and UART2 have nearly the same configuration settings, but with slight discrepancies. UART1 is used for debugging purposes. UART2 is used for the wireless transmitter (datalink).\n\n\nFor detailed register maps and specifications of the UART interface, see the \ndspic33fj256gp710A\n datasheet.\n\n\nThe most important settings are listed below.\n\n\nUART1\n\n\nU1MODEbits.UEN = 0;\n\nU1MODEbits.PDSEL = 0b00;\n\nU1MODEbits.STSEL = 0;\n\nU1BRG = 1;\n\nIPC7 = 0x4400;\n\nIFS0bits.U1TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC0bits.U1TXIE = 0;        // Enable Transmit Interrupts\n\nIFS0bits.U1RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC0bits.U1RXIE = 0;        // Enable Recieve Interrupts\n\nU1MODEbits.UARTEN = 1;        //Enable UART\n\nU1STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nU1MODEbits.UEN\n\n\n0\n\n\nEnables the Rx and Tx pins and disables the CTS and RTS pins.\n\n\n\n\n\n\nU1MODEbits.PDSEL\n\n\n0\n\n\nConfigures 8 bit messages with no parity bits.\n\n\n\n\n\n\nU1MODEbits.STSEL\n\n\n0\n\n\nConfigures 1 stop bit.\n\n\n\n\n\n\nU1BRG\n\n\n1\n\n\nSets the Baud Rate to 115200 Baud.\n\n\n\n\n\n\nIPC7\n\n\n17408\n\n\nSets the priority level for UART interrupts.\n\n\n\n\n\n\nIFS0bits.U1TXIF\n\n\n0\n\n\nClears the transmit interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the transmit interrupt event.\n\n\n\n\n\n\nIFS0bits.U1RXIF\n\n\n0\n\n\nClears the receive interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the receive interrupt event.\n\n\n\n\n\n\nU1MODEbits.UARTEN\n\n\n1\n\n\nTurns UART on.\n\n\n\n\n\n\nU1STAbits.UTXEN\n\n\n1\n\n\nAllows transmission (Tx) to take place.\n\n\n\n\n\n\n\n\nUART2\n\n\nU2MODEbits.UEN = 0;\n\nU2MODEbits.PDSEL = 0b00;\n\nU2MODEbits.STSEL = 0;\n\nU2BRG = 5;\n\nIPC7 = 0x4400;\n\nIFS1bits.U2TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC1bits.U2TXIE = 0;        // Enable Transmit Interrupts\n\nIFS1bits.U2RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC1bits.U2RXIE = 0;        // Enable Recieve Interrupts\n\nU2MODEbits.UARTEN = 1;        //Enable UART\n\nU2STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nU1MODEbits.UEN\n\n\n0\n\n\nEnables the Rx and Tx pins and disables the CTS and RTS pins.\n\n\n\n\n\n\nU1MODEbits.PDSEL\n\n\n0\n\n\nConfigures 8 bit messages with no parity bits.\n\n\n\n\n\n\nU1MODEbits.STSEL\n\n\n0\n\n\nConfigures 1 stop bit.\n\n\n\n\n\n\nU1BRG\n\n\n5\n\n\nSets the Baud Rate to 38400 Baud.\n\n\n\n\n\n\nIPC7\n\n\n17408\n\n\nSets the priority level for UART interrupts.\n\n\n\n\n\n\nIFS0bits.U1TXIF\n\n\n0\n\n\nClears the transmit interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the transmit interrupt event.\n\n\n\n\n\n\nIFS0bits.U1RXIF\n\n\n0\n\n\nClears the receive interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the receive interrupt event.\n\n\n\n\n\n\nU1MODEbits.UARTEN\n\n\n1\n\n\nTurns UART on.\n\n\n\n\n\n\nU1STAbits.UTXEN\n\n\n1\n\n\nAllows transmission (Tx) to take place.\n\n\n\n\n\n\n\n\nNote that the only difference between the data link (UART2) and the debugging interface (UART1), is the rate at which information is sent (baud rate).", 
            "title": "UART"
        }, 
        {
            "location": "/picpilot/uart/#uart", 
            "text": "UART stands for Universal Asynchronous Receive Transmit. It is a protocol for chips to be able to communicate between on another. It is a serial form of communication, where each bit of data is transmitted along the same connection. The minimum hardware requirements look like this:   Note that Tx represents the transmit port, Rx represents the receive port, and the GND represents the required ground connection.  UART is convenient due to its simplicity. Note that the interface does not have a clock line or any special signalling channels. Most other methods of communication require a pulsing clock to determine the rate at which data is transferred from one component to another. UART is \"asynchronous\" and therefore the bits on the transfer line and the receive line do not need to be transmitted at the same instance in time. Instead, both chips have a predefined rate at which they transfer binary information to one another. This predefined rate is often determined by the user, or sometimes (very rarely) restricted by the manufacturer. This rate is referred to as the  baud rate . It is very similar to a bit rate.  As a side note (don't worry if you are confused), Bit rate is the number of  bits_transferred per second. Baud rate is the number of _symbols  transferred per second. A bit can be 0 or 1. A symbol carries different amounts of information in different technologies. For instance, in certain communication protocols, there can be 64 possible values for a single symbol. 64 values required 6 bits to be represented. Therefore, the baud rate is 6 times less than the bit rate.  For the UART communication protocol, the baud rate is equivalent to the bit rate, although \"baud\" is the correct terminology.  Although UART can be used in both 8 bit mode and 16 bit mode, the PICpilot uses the 8 bit mode of communication as displayed below.   First a start bit is sent  The message is then relayed in series  The stop bit(s) are then sent. (There can be 1 or 2 stop bits)   The stop and end bits indicate the beginning and the end of communication.     Bit number  1  2  3  4  5  6  7  8  9  10  11       Start bit  5\u20138 data bits  Stop bit(s)             Start  Data 0  Data 1  Data 2  Data 3  Data 4  Data 5  Data 6  Data 7  Stop       The most common settings for the UART protocol include 8 data bits, no parity, 1 stop bit, and no flow control. Remember to make sure that the baud rate matches up, and NEVER connect Tx to Tx or Rx to Rx.  In case you do not know, parity is a special bit used to check the integrity of the data sent. It indicates whether or not the sum of the 8 bits must be odd or even. If this result does not match the parity bit, the microcontroller would know that the information is garbled.  Secondly, flow control requires additional pins, where each peripheral signals the other one before it transmits and receives. This ensures that both chips are ready to communicate.  Thirdly, the terms full duplex and half duplex refer to a chip being able to multitask. Full duplex indicates that both chips send and receive at the same time. Half duplex indicates that only one chip sends and receives at a time. Usually, some type of flow control is required for half duplex systems.  This form of communication is used for two purposes on the PICpilot. It is used for the data link, as well as the debugging interface. The settings are listed below.", 
            "title": "UART"
        }, 
        {
            "location": "/picpilot/uart/#in-the-code", 
            "text": "Each dspic33fj256gp710a has two UART interfaces. They are labeled UART1 and UART2. In the code, two corresponding files are present: UART1.c and UART2.c (as well as their header files). UART1 and UART2 have nearly the same configuration settings, but with slight discrepancies. UART1 is used for debugging purposes. UART2 is used for the wireless transmitter (datalink).  For detailed register maps and specifications of the UART interface, see the  dspic33fj256gp710A  datasheet.  The most important settings are listed below.  UART1  U1MODEbits.UEN = 0;\n\nU1MODEbits.PDSEL = 0b00;\n\nU1MODEbits.STSEL = 0;\n\nU1BRG = 1;\n\nIPC7 = 0x4400;\n\nIFS0bits.U1TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC0bits.U1TXIE = 0;        // Enable Transmit Interrupts\n\nIFS0bits.U1RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC0bits.U1RXIE = 0;        // Enable Recieve Interrupts\n\nU1MODEbits.UARTEN = 1;        //Enable UART\n\nU1STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.     Register  Value  Function      U1MODEbits.UEN  0  Enables the Rx and Tx pins and disables the CTS and RTS pins.    U1MODEbits.PDSEL  0  Configures 8 bit messages with no parity bits.    U1MODEbits.STSEL  0  Configures 1 stop bit.    U1BRG  1  Sets the Baud Rate to 115200 Baud.    IPC7  17408  Sets the priority level for UART interrupts.    IFS0bits.U1TXIF  0  Clears the transmit interrupt flag.    IEC0bits.U1TXIE  0  Enables the transmit interrupt event.    IFS0bits.U1RXIF  0  Clears the receive interrupt flag.    IEC0bits.U1TXIE  0  Enables the receive interrupt event.    U1MODEbits.UARTEN  1  Turns UART on.    U1STAbits.UTXEN  1  Allows transmission (Tx) to take place.     UART2  U2MODEbits.UEN = 0;\n\nU2MODEbits.PDSEL = 0b00;\n\nU2MODEbits.STSEL = 0;\n\nU2BRG = 5;\n\nIPC7 = 0x4400;\n\nIFS1bits.U2TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC1bits.U2TXIE = 0;        // Enable Transmit Interrupts\n\nIFS1bits.U2RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC1bits.U2RXIE = 0;        // Enable Recieve Interrupts\n\nU2MODEbits.UARTEN = 1;        //Enable UART\n\nU2STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.     Register  Value  Function      U1MODEbits.UEN  0  Enables the Rx and Tx pins and disables the CTS and RTS pins.    U1MODEbits.PDSEL  0  Configures 8 bit messages with no parity bits.    U1MODEbits.STSEL  0  Configures 1 stop bit.    U1BRG  5  Sets the Baud Rate to 38400 Baud.    IPC7  17408  Sets the priority level for UART interrupts.    IFS0bits.U1TXIF  0  Clears the transmit interrupt flag.    IEC0bits.U1TXIE  0  Enables the transmit interrupt event.    IFS0bits.U1RXIF  0  Clears the receive interrupt flag.    IEC0bits.U1TXIE  0  Enables the receive interrupt event.    U1MODEbits.UARTEN  1  Turns UART on.    U1STAbits.UTXEN  1  Allows transmission (Tx) to take place.     Note that the only difference between the data link (UART2) and the debugging interface (UART1), is the rate at which information is sent (baud rate).", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/spi/", 
            "text": "SPI\n\n\nSPI stands for Serial Peripheral Interface. It is similar to UART, with the exception that it is a \nsynchronous\n method of communication. Once again, SPI is a protocol for chips to be able to communicate between on another through serial connections (data on a single wire). It always operates in full duplex mode. This means that both chips \nalways\n transmit and receive at the same time. The minimum hardware requirements include a clock line (SCLK), a Master Out/Slave In (MOSI), a Master In/Slave Out (MISO), and a Slave Select (SS). The Master Out/In and Slave In/Out refer to the transmit and receive pins on both chips. The connections should looks like this:\n\n\n\n\nNote that there is a \"Master\" and a \"Slave\". The master always initiates communication. The slave always responds first. The SCLK (clock) line counts pulses, which are synchronized to the data bits on the MOSI and MISO lines. The SS (Slave Select) line is used to notify an external chip that communication is taking place. This enables multiple chips to be connected on the same data and clock lines. This is depicted here:\n\n\n\n\nIn the PICpilot, there is never more than one slave per data port. In other words, one does not have to worry about scenarios (multiple slaves) such as the one depicted above.\n\n\nThe SPI interface transfers 8 bits per packet. The protocol is straight forward:\n\n\n\n\nThe start condition is initiated. The clock starts and the (selected) slave prepares to read and the master prepares to write.\n\n\nOn the next 8 clock pulses, the slave and master both exchange data (read and write)\n\n\nAfter transmission, the stop condition is set. This occurs when the clock stops (high or low depending on the settings).\n\n\n\n\nThe PIC microcontroller specifications depict the SPI interface as follows:\n\n\n\n\nUnlike UART, there is no parity bits, start bits, or stop bits. The beginning and the end of the message are commonly referred to as the \nStart Condition\n and the \nStop Condition\n, because they don't actually refer to any bits, but instead they refer to the signal of multiple lines (CLK, SS).\n\n\nIn the PICpilot, SPI is used for communication with the GPS, VectorNav (IMU), and the two individual cores (CPU/Microcontrollers). The GPS uses SPI2, the VectorNav uses SPI2, and the crosstalk between chips uses SPI1.\n\n\nIn the code\n\n\nEach dspic33fj256gp710a has two SPI interfaces. They are labeled SPI1 and SPI2. In the code, you won't find any SPI files present. The initialization functions are embedded in the corresponding peripheral files. The SPI1 configuration can be found on both chips, in the file, InterchipDMA.c, as well as the corresponding .h file. The function in those files is init_SPI1. In addition, on the secondary chip (in other words, the path management chip), the SPI2 (GPS) interface is also enabled in the InterchipDMA.c file, as well as the header file. The function is called init_SPI2.\n\n\nThe SPI2 configuration on the main chip (or more precisely, the attitude management chip) can be found in the VN100.c file, as well as the corresponding header file. The function name is VN100_initSPI. It initializes SPI2.\n\n\nThis table summarizes the configuration:\n\n\n\n\n\n\n\n\n\n\nSPI1\n\n\nSPI2\n\n\nSPI2\n\n\n\n\n\n\n\n\n\n\nUse\n\n\nInterchip Communication\n\n\nGPS Communication\n\n\nVectorNav Communication\n\n\n\n\n\n\nChip\n\n\nBoth chips\n\n\nSecondary (Path Managing) Chip\n\n\nPrimary (Attitude Managing) Chip\n\n\n\n\n\n\nFunction\n\n\nIn InterchipDMA.c,Init_SPI1()\n\n\nIn InterchipDMA.c,Init_SPI2()\n\n\nIn VN100.c,VN100_initSPI()\n\n\n\n\n\n\n\n\nFor detailed register maps and specifications of the SPI interface, see the \ndspic33fj256gp710A\n datasheet.\n\n\nThe most important settings are listed below.\n\n\nSPI1 \u2013 DMA and SPI2 - GPS\n\n\n//Set interrupts\n\nIFS0bits.SPI1IF = 0;\n\nIEC0bits.SPI1IE = 1;\n\nIPC2bits.SPI1IP = 4;\n\nSPI1BUF = 0;\n\n//SPI clock controlled by this module\n\nSPI1CON1bits.DISSCK = 0;\n\n//Output pins are controlled by this module\n\nSPI1CON1bits.DISSDO = 0;\n\n//16/8 bit communication mode (1/0)\n\nSPI1CON1bits.MODE16 = 1; //16\n\n//Master mode(1)/Slave mode(0)\n\nSPI1CON1bits.MSTEN = 0; //Slave\n\n//Enable Slave Select\n\nSPI1CON1bits.SSEN = 0;\n\n//Sample Phase (end/middle)\n\nSPI1CON1bits.SMP = 0; //Sample the input at the middle of the square wave\n\n//Clock Edge Select\n\nSPI1CON1bits.CKE = 0; //Output data changes from idle state to active clock state (1 is the opposite)\n\n//Clock Polarity\n\nSPI1CON1bits.CKP = 0; //Idle clock state is low, active clock state is high\n\n//Enable SPI\n\nSPI1STATbits.SPIEN = 1;\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nIFS0bits.SPI1IF\n\n\n0\n\n\nThis is the interrupt flag for the SPI1 interface.\n\n\n\n\n\n\nIEC0bits.SPI1IE\n\n\n1 (0 for GPS)\n\n\nThis is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur.\n\n\n\n\n\n\nIPC2bits.SPI1IP\n\n\n4 (0 for GPS)\n\n\nThis determines the priority of every interrupt that occurs from the SPI1 interface.\n\n\n\n\n\n\nSPI1BUF\n\n\n0\n\n\nThis is the buffer that is used for sending and receiving data. This is buffer is for both reading and writing.\n\n\n\n\n\n\nSPI1CON1bits.DISSCK\n\n\n0\n\n\nThis bit allows the SPI1 module to control the clock.\n\n\n\n\n\n\nSPI1CON1bits.DISSDO\n\n\n0\n\n\nThis bit allows the SPI1 module to convert the usual GPIO pins into SPI1 pins.\n\n\n\n\n\n\nSPI1CON1bits.MODE16\n\n\n1\n\n\nThis allows 16 bits to be transmitted per message.\n\n\n\n\n\n\nSPI1CON1bits.MSTEN\n\n\n0 or 1\n\n\nThis determines if the chip is the master (attitude manager) or the slave (path manager).\n\n\n\n\n\n\nSPI1CON1bits.SSEN\n\n\n0\n\n\nThis value enables the slave select pin.\n\n\n\n\n\n\nSPI1CON1bits.SMP\n\n\n0\n\n\nThis determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.\n\n\n\n\n\n\nSPI1CON1bits.CKE\n\n\n0\n\n\nThis bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.\n\n\n\n\n\n\nSPI1CON1bits.CKP\n\n\n0\n\n\nDetermines the clock polarity. 0 means that active clock state is high, idle state is low. 1 is the opposite.\n\n\n\n\n\n\nSPI1STATbits.SPIEN\n\n\n1\n\n\nEnables the entire SPI module.\n\n\n\n\n\n\n\n\nSPI2 - VectorNav\n\n\nThe VectorNav SPI configuration is very similar. The differences are listed below:\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nIEC0bits.SPI2IE\n\n\n0\n\n\nThis is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur. The interrupt is disabled here.\n\n\n\n\n\n\nSPI2CON1bits.MODE16\n\n\n0\n\n\nThis allows 8 bits to be transmitted per message.\n\n\n\n\n\n\nSPI2CON1bits.MSTEN\n\n\n1\n\n\nThis determines that the chip is the master and the VectorNav is the slave.\n\n\n\n\n\n\nSPI2CON1bits.SSEN\n\n\n0\n\n\nThis value enables the slave select pin.\n\n\n\n\n\n\nSPI2CON1bits.SMP\n\n\n0\n\n\nThis determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.\n\n\n\n\n\n\nSPI2CON1bits.CKE\n\n\n0\n\n\nThis bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.\n\n\n\n\n\n\nSPI2CON1bits.CKP\n\n\n1\n\n\nDetermines the clock polarity. 1 means that active clock state is low, idle state is high. 0 is the opposite.\n\n\n\n\n\n\nSPI2CON1bits.PPRE\n\n\n2\n\n\nPrescales the clock. It reduces the clock frequency at a 4:1 ratio.\n\n\n\n\n\n\nSPI2CON1bits.SPRE\n\n\n6\n\n\nThe secondary prescaler, prescales the output frequency from the primary prescaler. This one is set to reduce the frequency at a ratio of 2:1.", 
            "title": "SPI"
        }, 
        {
            "location": "/picpilot/spi/#spi", 
            "text": "SPI stands for Serial Peripheral Interface. It is similar to UART, with the exception that it is a  synchronous  method of communication. Once again, SPI is a protocol for chips to be able to communicate between on another through serial connections (data on a single wire). It always operates in full duplex mode. This means that both chips  always  transmit and receive at the same time. The minimum hardware requirements include a clock line (SCLK), a Master Out/Slave In (MOSI), a Master In/Slave Out (MISO), and a Slave Select (SS). The Master Out/In and Slave In/Out refer to the transmit and receive pins on both chips. The connections should looks like this:   Note that there is a \"Master\" and a \"Slave\". The master always initiates communication. The slave always responds first. The SCLK (clock) line counts pulses, which are synchronized to the data bits on the MOSI and MISO lines. The SS (Slave Select) line is used to notify an external chip that communication is taking place. This enables multiple chips to be connected on the same data and clock lines. This is depicted here:   In the PICpilot, there is never more than one slave per data port. In other words, one does not have to worry about scenarios (multiple slaves) such as the one depicted above.  The SPI interface transfers 8 bits per packet. The protocol is straight forward:   The start condition is initiated. The clock starts and the (selected) slave prepares to read and the master prepares to write.  On the next 8 clock pulses, the slave and master both exchange data (read and write)  After transmission, the stop condition is set. This occurs when the clock stops (high or low depending on the settings).   The PIC microcontroller specifications depict the SPI interface as follows:   Unlike UART, there is no parity bits, start bits, or stop bits. The beginning and the end of the message are commonly referred to as the  Start Condition  and the  Stop Condition , because they don't actually refer to any bits, but instead they refer to the signal of multiple lines (CLK, SS).  In the PICpilot, SPI is used for communication with the GPS, VectorNav (IMU), and the two individual cores (CPU/Microcontrollers). The GPS uses SPI2, the VectorNav uses SPI2, and the crosstalk between chips uses SPI1.", 
            "title": "SPI"
        }, 
        {
            "location": "/picpilot/spi/#in-the-code", 
            "text": "Each dspic33fj256gp710a has two SPI interfaces. They are labeled SPI1 and SPI2. In the code, you won't find any SPI files present. The initialization functions are embedded in the corresponding peripheral files. The SPI1 configuration can be found on both chips, in the file, InterchipDMA.c, as well as the corresponding .h file. The function in those files is init_SPI1. In addition, on the secondary chip (in other words, the path management chip), the SPI2 (GPS) interface is also enabled in the InterchipDMA.c file, as well as the header file. The function is called init_SPI2.  The SPI2 configuration on the main chip (or more precisely, the attitude management chip) can be found in the VN100.c file, as well as the corresponding header file. The function name is VN100_initSPI. It initializes SPI2.  This table summarizes the configuration:      SPI1  SPI2  SPI2      Use  Interchip Communication  GPS Communication  VectorNav Communication    Chip  Both chips  Secondary (Path Managing) Chip  Primary (Attitude Managing) Chip    Function  In InterchipDMA.c,Init_SPI1()  In InterchipDMA.c,Init_SPI2()  In VN100.c,VN100_initSPI()     For detailed register maps and specifications of the SPI interface, see the  dspic33fj256gp710A  datasheet.  The most important settings are listed below.  SPI1 \u2013 DMA and SPI2 - GPS  //Set interrupts\n\nIFS0bits.SPI1IF = 0;\n\nIEC0bits.SPI1IE = 1;\n\nIPC2bits.SPI1IP = 4;\n\nSPI1BUF = 0;\n\n//SPI clock controlled by this module\n\nSPI1CON1bits.DISSCK = 0;\n\n//Output pins are controlled by this module\n\nSPI1CON1bits.DISSDO = 0;\n\n//16/8 bit communication mode (1/0)\n\nSPI1CON1bits.MODE16 = 1; //16\n\n//Master mode(1)/Slave mode(0)\n\nSPI1CON1bits.MSTEN = 0; //Slave\n\n//Enable Slave Select\n\nSPI1CON1bits.SSEN = 0;\n\n//Sample Phase (end/middle)\n\nSPI1CON1bits.SMP = 0; //Sample the input at the middle of the square wave\n\n//Clock Edge Select\n\nSPI1CON1bits.CKE = 0; //Output data changes from idle state to active clock state (1 is the opposite)\n\n//Clock Polarity\n\nSPI1CON1bits.CKP = 0; //Idle clock state is low, active clock state is high\n\n//Enable SPI\n\nSPI1STATbits.SPIEN = 1;     Register  Value  Function      IFS0bits.SPI1IF  0  This is the interrupt flag for the SPI1 interface.    IEC0bits.SPI1IE  1 (0 for GPS)  This is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur.    IPC2bits.SPI1IP  4 (0 for GPS)  This determines the priority of every interrupt that occurs from the SPI1 interface.    SPI1BUF  0  This is the buffer that is used for sending and receiving data. This is buffer is for both reading and writing.    SPI1CON1bits.DISSCK  0  This bit allows the SPI1 module to control the clock.    SPI1CON1bits.DISSDO  0  This bit allows the SPI1 module to convert the usual GPIO pins into SPI1 pins.    SPI1CON1bits.MODE16  1  This allows 16 bits to be transmitted per message.    SPI1CON1bits.MSTEN  0 or 1  This determines if the chip is the master (attitude manager) or the slave (path manager).    SPI1CON1bits.SSEN  0  This value enables the slave select pin.    SPI1CON1bits.SMP  0  This determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.    SPI1CON1bits.CKE  0  This bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.    SPI1CON1bits.CKP  0  Determines the clock polarity. 0 means that active clock state is high, idle state is low. 1 is the opposite.    SPI1STATbits.SPIEN  1  Enables the entire SPI module.     SPI2 - VectorNav  The VectorNav SPI configuration is very similar. The differences are listed below:     Register  Value  Function      IEC0bits.SPI2IE  0  This is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur. The interrupt is disabled here.    SPI2CON1bits.MODE16  0  This allows 8 bits to be transmitted per message.    SPI2CON1bits.MSTEN  1  This determines that the chip is the master and the VectorNav is the slave.    SPI2CON1bits.SSEN  0  This value enables the slave select pin.    SPI2CON1bits.SMP  0  This determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.    SPI2CON1bits.CKE  0  This bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.    SPI2CON1bits.CKP  1  Determines the clock polarity. 1 means that active clock state is low, idle state is high. 0 is the opposite.    SPI2CON1bits.PPRE  2  Prescales the clock. It reduces the clock frequency at a 4:1 ratio.    SPI2CON1bits.SPRE  6  The secondary prescaler, prescales the output frequency from the primary prescaler. This one is set to reduce the frequency at a ratio of 2:1.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/direct-memory-access/", 
            "text": "Direct Memory Access\n\n\nDirect Memory Access (or DMA), is a microcontroller feature, which allows peripheral interfaces to directly access memory, completely bypassing the CPU. The CPU only needs to setup the transfer of data. The rest of the process is done without it.\n\n\nDMA is a commonly used in graphic, network, and sound cards. More importantly, it is used in multi-core processors, which is essentially the usage of DMA in the PICpilot.\n\n\nOne DMA cycle follows this procedure:\n\n\n\n\nIn the PICpilot, the only peripheral that uses DMA is the SPI interface, although many other ones are supported.\n\n\nWhen a DMA transfer occurs, first a peripheral makes a request to the DMA controller (based on a predefined channel number). The request causes the DMA controller to read or write to a preconfigured peripheral address. Once this is completed, the DMA controller writes the data to the DPSRAM location (this is RAM dedicated to the DMA controller) or reads from it. The direction in which this transfer occurs depends on the register value corresponding to the predefined settings of the DMA controller.\n\n\nIn the PICpilot, the Direct Memory Access module is constantly active through the SPI1 module. This means that the data transmission is continuous between both chips. Essentially, when this process is continuous it provides a way to share global variables between two physical microcontrollers simultaneously. This is how path data gets transmitted to the attitude manager. The path data is made global between the two chips.\n\n\nIt should be noted that DMA is also used between the path manager chip and the GPS.\n\n\nOn the PIC microcontroller, the DMA must only be initialized. The DMA controller continues operation automatically without direct processor input. The code to initialize the interface is below.\n\n\nIn the code\n\n\nIn order to transfer data using DMA, both chips must have been initialized. In the PICpilot, only the DMA interface is initialized for data transfer between the GPS and the Path Management Chip (PM Chip), as well as the PM Chip and the Attitude Management Chip (AM Chip). Both of these connections are enabled using SPI (see previous section).\n\n\nThe GPS continuously sends data as soon as it is plugged in. It sends data in the following data format:\n\n\ntypedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;\n\n\n\nIn order to properly configure this connection the following code is used:\n\n\nGPSData gpsData __attribute__((space(dma)));\n\n/*\n\n *\n\n */\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){\n\n    newGPSDataAvailable = 1;\n\n    IFS1bits.DMA2IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA2(){\n\n    IFS1bits.DMA2IF = 0;\n\n    IEC1bits.DMA2IE = 1;\n\n    DMA2CONbits.AMODE = 0b00; //Register Indirect Mode\n\n    DMA2CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA2CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA2CONbits.SIZE = 1; //Transfer bytes (8 bits)\n\n    DMA2STA = __builtin_dmaoffset(\ngpsData); //Primary Transfer Buffer\n\n    DMA2PAD = (volatile unsigned int) \nSPI2BUF; //Peripheral Address\n\n    DMA2CNT = sizeof(GPSData) - 1; //+1 for checksum //DMA Transfer Count Length\n\n    DMA2REQ = 0b0100001; //IRQ code for SPI2\n\n    DMA2CONbits.CHEN = 1; //Enable the channel\n\n}\n\n\n\nNote how a block of memory (\"GPSData\") is reserved for the incoming data from the GPS unit.  The register values are configured as follows:\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nDMA2CONbits.AMODE\n\n\n0\n\n\nThis enables Register Indirect with Post Increment Mode. This enables data to be stored in chunks one after another (incremented locations).\n\n\n\n\n\n\nDMA2CONbits.DIR\n\n\n0\n\n\nThis indicates the direction that data travels on the bus. In this case, the data is always \nincoming\n. Therefore, it is copied from the SPI interface to the DSPRAM.\n\n\n\n\n\n\nDMA2CONbits.MODE\n\n\n0\n\n\nThis indicates if the transfer occurs a single time, or continuously, and whether a ping pong buffer should be used. It is currently enabled for continuous usage without a ping pong buffer.\n\n\n\n\n\n\nDMA2CONbits.SIZE\n\n\n1\n\n\nIndicates if each DMA transfer is 8 bits or 16 bits. In this case, it is 8 bits.\n\n\n\n\n\n\nDMA2STA\n\n\ngpsData with an added DMA offset\n\n\nThis indicates where the primary buffer is located. This memory block was initialized at the beginning of the above code snippet, where \"space(dma)\" is called.\n\n\n\n\n\n\nDMA2PAD\n\n\nSPI2BUF\n\n\nThis stores the referenced location from where the data is obtained. (This DMA channel will use the SPI2 buffer to get the data).\n\n\n\n\n\n\nDMA2CNT\n\n\nNumber of bytes in GPSData - 1\n\n\nThis is a counter variable, which indicates the number of transfers that need to be completed per DMA request.\n\n\n\n\n\n\nDMA2REQ\n\n\n0b0100001\n\n\nThis is the IRQ (Interrupt Request) code for the SPI2 interface. This allows the peripheral to send an interrupt request to the DMA controller instead of the CPU.\n\n\n\n\n\n\nDMA2CONbits.CHEN\n\n\n1\n\n\nEnables the DMA channel.\n\n\n\n\n\n\n\n\nOn the other hand, the setup between the PM chip and the AM chip is slightly different. These two chips communicate with each other simultaneously through the SPI1 interface. The code controlling the initialization found in InterchipDMA.c/.h.\n\n\nThe data being sent to the PM chip from the AM chip is in the form of:\n\n\ntypedef struct _AMData {\n\n    WaypointWrapper waypoint;\n\n    float pathGain;\n\n    float orbitGain;\n\n    float calibrationHeight;\n\n    char command;\n\n    char checksum;\n\n} AMData;\n\n\n\nVice-versa, the data being sent to the AM chip from the PM chip is in the form of:\n\n\ntypedef struct _PMData {\n\n    float time;     //4 Bytes   -  hhmmss.ssss\n\n    long double latitude;  //8 Bytes - ddd.mmmmmm\n\n    long double longitude; //8 Bytes - ddd.mmmmmm\n\n    float speed;    //KM/H\n\n    float altitude;\n\n    int sp_Altitude; // Meters\n\n    int heading;  //Degrees\n\n    int sp_Heading; //Degrees\n\n    char satellites;    //1 Byte\n\n    char positionFix;   //0 = No GPS, 1 = GPS fix, 2 = DGSP Fix\n\n    char targetWaypoint;\n\n    char batteryLevel;\n\n } PMData;\n\n\n\nThe initialization process is extremely similar for both chips (PM and AM). Each chip requires a DMA channel to read the incoming data, as well as to write the outgoing data. As a result, both the AM chip and the PM chip have the same setup with a few different variables names:\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){\n\n#if !PATH_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n#endif\n\n    newDataAvailable = 1;\n\n    IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA1Interrupt(void){\n\n    IFS0bits.DMA1IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA0(){\n\n    IFS0bits.DMA0IF = 0;\n\n    IEC0bits.DMA0IE = 1;\n\n    IPC1bits.DMA0IP = 7; //Highest Priority\n\n    DMACS0 = 0; //Clear any IO error flags\n\n    DMA0CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA0CONbits.AMODE = 0b00; //With post increment mode\n\n    DMA0CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA0CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA0STA = __builtin_dmaoffset(\namData); //Primary Transfer Buffer\n\n#else\n\n    DMA0STA = __builtin_dmaoffset(\npmData); //Primary Transfer Buffer\n\n#endif\n\n    DMA0PAD = (volatile unsigned int) \nSPI1BUF; //Peripheral Address\n\n    DMA0CNT = PATH_MANAGER?(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1):(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA0REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA0CONbits.CHEN = 1; //Enable the channel\n\n}\n\nvoid init_DMA1(){\n\n    IFS0bits.DMA1IF = 0;\n\n    IEC0bits.DMA1IE = 1;\n\n    IPC3bits.DMA1IP = 7;\n\n    DMACS1 = 0; //Clear any IO error flags\n\n    DMA1CONbits.DIR = 1; //Transfer from DSPRAM to SPI\n\n    DMA1CONbits.AMODE = 0b00; //Without post increment mode\n\n    DMA1CONbits.MODE = 0b00; //Transfer continuously, ping ponging between buffers\n\n    DMA1CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA1STA = __builtin_dmaoffset(\npmData); //Primary Transfer Buffer\n\n#else\n\n    DMA1STA = __builtin_dmaoffset(\namData); //Primary Transfer Buffer\n\n#endif\n\n    DMA1PAD = (volatile unsigned int) \nSPI1BUF; //Peripheral Address\n\n    DMA1CNT = PATH_MANAGER?(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1):(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA1REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA1CONbits.CHEN = 1; //Enable the channel\n\n}\n\n\n\nThe above code is very similar to the first example with the GPS. The differences include the direction of data transfer, the buffer variables, the IRQ codes, as well as the 16 bit mode interfacing.\n\n\nAlso, in order to initialize transfer, the SPI master must send the first packet. This is evident in the DMA0 interrupt routine:\n\n\n#if !PATH\\_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n #endif\n\n\n\nA DMA request is forced by setting the DMA1REQbits.FORCE bit to 1. The following sets of data do not need to be forced, they happen automatically (since continuous mode was enabled).", 
            "title": "Direct Memory Access"
        }, 
        {
            "location": "/picpilot/direct-memory-access/#direct-memory-access", 
            "text": "Direct Memory Access (or DMA), is a microcontroller feature, which allows peripheral interfaces to directly access memory, completely bypassing the CPU. The CPU only needs to setup the transfer of data. The rest of the process is done without it.  DMA is a commonly used in graphic, network, and sound cards. More importantly, it is used in multi-core processors, which is essentially the usage of DMA in the PICpilot.  One DMA cycle follows this procedure:   In the PICpilot, the only peripheral that uses DMA is the SPI interface, although many other ones are supported.  When a DMA transfer occurs, first a peripheral makes a request to the DMA controller (based on a predefined channel number). The request causes the DMA controller to read or write to a preconfigured peripheral address. Once this is completed, the DMA controller writes the data to the DPSRAM location (this is RAM dedicated to the DMA controller) or reads from it. The direction in which this transfer occurs depends on the register value corresponding to the predefined settings of the DMA controller.  In the PICpilot, the Direct Memory Access module is constantly active through the SPI1 module. This means that the data transmission is continuous between both chips. Essentially, when this process is continuous it provides a way to share global variables between two physical microcontrollers simultaneously. This is how path data gets transmitted to the attitude manager. The path data is made global between the two chips.  It should be noted that DMA is also used between the path manager chip and the GPS.  On the PIC microcontroller, the DMA must only be initialized. The DMA controller continues operation automatically without direct processor input. The code to initialize the interface is below.", 
            "title": "Direct Memory Access"
        }, 
        {
            "location": "/picpilot/direct-memory-access/#in-the-code", 
            "text": "In order to transfer data using DMA, both chips must have been initialized. In the PICpilot, only the DMA interface is initialized for data transfer between the GPS and the Path Management Chip (PM Chip), as well as the PM Chip and the Attitude Management Chip (AM Chip). Both of these connections are enabled using SPI (see previous section).  The GPS continuously sends data as soon as it is plugged in. It sends data in the following data format:  typedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;  In order to properly configure this connection the following code is used:  GPSData gpsData __attribute__((space(dma)));\n\n/*\n\n *\n\n */\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){\n\n    newGPSDataAvailable = 1;\n\n    IFS1bits.DMA2IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA2(){\n\n    IFS1bits.DMA2IF = 0;\n\n    IEC1bits.DMA2IE = 1;\n\n    DMA2CONbits.AMODE = 0b00; //Register Indirect Mode\n\n    DMA2CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA2CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA2CONbits.SIZE = 1; //Transfer bytes (8 bits)\n\n    DMA2STA = __builtin_dmaoffset( gpsData); //Primary Transfer Buffer\n\n    DMA2PAD = (volatile unsigned int)  SPI2BUF; //Peripheral Address\n\n    DMA2CNT = sizeof(GPSData) - 1; //+1 for checksum //DMA Transfer Count Length\n\n    DMA2REQ = 0b0100001; //IRQ code for SPI2\n\n    DMA2CONbits.CHEN = 1; //Enable the channel\n\n}  Note how a block of memory (\"GPSData\") is reserved for the incoming data from the GPS unit.  The register values are configured as follows:     Register  Value  Function      DMA2CONbits.AMODE  0  This enables Register Indirect with Post Increment Mode. This enables data to be stored in chunks one after another (incremented locations).    DMA2CONbits.DIR  0  This indicates the direction that data travels on the bus. In this case, the data is always  incoming . Therefore, it is copied from the SPI interface to the DSPRAM.    DMA2CONbits.MODE  0  This indicates if the transfer occurs a single time, or continuously, and whether a ping pong buffer should be used. It is currently enabled for continuous usage without a ping pong buffer.    DMA2CONbits.SIZE  1  Indicates if each DMA transfer is 8 bits or 16 bits. In this case, it is 8 bits.    DMA2STA  gpsData with an added DMA offset  This indicates where the primary buffer is located. This memory block was initialized at the beginning of the above code snippet, where \"space(dma)\" is called.    DMA2PAD  SPI2BUF  This stores the referenced location from where the data is obtained. (This DMA channel will use the SPI2 buffer to get the data).    DMA2CNT  Number of bytes in GPSData - 1  This is a counter variable, which indicates the number of transfers that need to be completed per DMA request.    DMA2REQ  0b0100001  This is the IRQ (Interrupt Request) code for the SPI2 interface. This allows the peripheral to send an interrupt request to the DMA controller instead of the CPU.    DMA2CONbits.CHEN  1  Enables the DMA channel.     On the other hand, the setup between the PM chip and the AM chip is slightly different. These two chips communicate with each other simultaneously through the SPI1 interface. The code controlling the initialization found in InterchipDMA.c/.h.  The data being sent to the PM chip from the AM chip is in the form of:  typedef struct _AMData {\n\n    WaypointWrapper waypoint;\n\n    float pathGain;\n\n    float orbitGain;\n\n    float calibrationHeight;\n\n    char command;\n\n    char checksum;\n\n} AMData;  Vice-versa, the data being sent to the AM chip from the PM chip is in the form of:  typedef struct _PMData {\n\n    float time;     //4 Bytes   -  hhmmss.ssss\n\n    long double latitude;  //8 Bytes - ddd.mmmmmm\n\n    long double longitude; //8 Bytes - ddd.mmmmmm\n\n    float speed;    //KM/H\n\n    float altitude;\n\n    int sp_Altitude; // Meters\n\n    int heading;  //Degrees\n\n    int sp_Heading; //Degrees\n\n    char satellites;    //1 Byte\n\n    char positionFix;   //0 = No GPS, 1 = GPS fix, 2 = DGSP Fix\n\n    char targetWaypoint;\n\n    char batteryLevel;\n\n } PMData;  The initialization process is extremely similar for both chips (PM and AM). Each chip requires a DMA channel to read the incoming data, as well as to write the outgoing data. As a result, both the AM chip and the PM chip have the same setup with a few different variables names:  void __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){\n\n#if !PATH_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n#endif\n\n    newDataAvailable = 1;\n\n    IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA1Interrupt(void){\n\n    IFS0bits.DMA1IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA0(){\n\n    IFS0bits.DMA0IF = 0;\n\n    IEC0bits.DMA0IE = 1;\n\n    IPC1bits.DMA0IP = 7; //Highest Priority\n\n    DMACS0 = 0; //Clear any IO error flags\n\n    DMA0CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA0CONbits.AMODE = 0b00; //With post increment mode\n\n    DMA0CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA0CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA0STA = __builtin_dmaoffset( amData); //Primary Transfer Buffer\n\n#else\n\n    DMA0STA = __builtin_dmaoffset( pmData); //Primary Transfer Buffer\n\n#endif\n\n    DMA0PAD = (volatile unsigned int)  SPI1BUF; //Peripheral Address\n\n    DMA0CNT = PATH_MANAGER?(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1):(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA0REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA0CONbits.CHEN = 1; //Enable the channel\n\n}\n\nvoid init_DMA1(){\n\n    IFS0bits.DMA1IF = 0;\n\n    IEC0bits.DMA1IE = 1;\n\n    IPC3bits.DMA1IP = 7;\n\n    DMACS1 = 0; //Clear any IO error flags\n\n    DMA1CONbits.DIR = 1; //Transfer from DSPRAM to SPI\n\n    DMA1CONbits.AMODE = 0b00; //Without post increment mode\n\n    DMA1CONbits.MODE = 0b00; //Transfer continuously, ping ponging between buffers\n\n    DMA1CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA1STA = __builtin_dmaoffset( pmData); //Primary Transfer Buffer\n\n#else\n\n    DMA1STA = __builtin_dmaoffset( amData); //Primary Transfer Buffer\n\n#endif\n\n    DMA1PAD = (volatile unsigned int)  SPI1BUF; //Peripheral Address\n\n    DMA1CNT = PATH_MANAGER?(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1):(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA1REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA1CONbits.CHEN = 1; //Enable the channel\n\n}  The above code is very similar to the first example with the GPS. The differences include the direction of data transfer, the buffer variables, the IRQ codes, as well as the 16 bit mode interfacing.  Also, in order to initialize transfer, the SPI master must send the first packet. This is evident in the DMA0 interrupt routine:  #if !PATH\\_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n #endif  A DMA request is forced by setting the DMA1REQbits.FORCE bit to 1. The following sets of data do not need to be forced, they happen automatically (since continuous mode was enabled).", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/i2c/", 
            "text": "I2C\n\n\nI2C stands for Inter-Integrated Circuit. It is pronounced \"I-two-C\" or \"I-squared-C\". It is similar to SPI, with the exception that it does not require a slave select line. All communication takes place on one data line, and one clock line. I2C is a \nsynchronous\n method of communication, indicating that a clock line is present. Once again, I2C is a protocol for chips to be able to communicate between one another through serial connections (data on a single wire). It cannot operate in full duplex mode, unlike SPI. This means that both chips take turns transmitting and receiving and cannot do so at the same time. The minimum hardware requirements include a clock line (SCL), a data line (SDA), and both lines connected to Vdd via a pull-up resistor. The connections should looks like this:\n\n\n\n\nThis protocol is extremely simple from a hardware point of view. However, it is significantly slower than SPI, which is the main disadvantage. If you require high speed communication, I2C is not the best choice.\n\n\nIn a similar fashion to SPI, I2C also has Master and Slave devices. I2C protocol dictates that the master must always initialize communication.\n\n\nThere are two types of messages that a master device can send. It can be a read or a write message. Both messages are similar in structure; however, the read message requires the slave to respond, whereas the write message does not.\n\n\nThe write message is structured in the following order:\n\n\n\n\nStart condition is specified on SDA and SCL (depends on the settings but typically involves the master pulling the data line low, shortly followed by the clock line being pulled low)\n\n\nAn 8-bit message is then sent, which contains a 7-bit (unique) identifying address, which determines what slave will engage in the data transfer. The 8th bit of the message is a read or write bit. When the bit is low (0), this indicates a write. When the bit is high (1), this indicates a read. In this scenario, we express the write bit (0).\n\n\nThe master waits for an acknowledgment from the slave. The acknowledgment is the slave pulling the data line low (0), while the master listens. If the acknowledgment is not received, there is likely a problem with the device or the connection.\n\n\nAt this point data is written 8 bits at a time, until the stop condition is expressed by the master. After each bit, the slave must acknowledge (ACK).\n\n\nThe stop condition is expressed. (SDA is pulled low, then the SCL is pulled high and it stops pulsing. The SDA is then also pulled high.)\n\n\n\n\nThe read message is very similar to the write message. The start condition and the first byte (address and write bit) must always be present. If a read condition is to exist, a repeated restart must be executed followed by the address of the slave with the read bit (1). The second byte/message may be a command message. Following the message, for the next 8 bytes, the master will expect a response to the command.\n\n\nAssuming that the write message from above was never stopped, the read message would be as follows:\n\n\n\n\nExecute a repeated restart.\n\n\nSend the slave address with a read bit (1).\n\n\nThe slave will respond with 8 bits of data. These 8 bits of data depend on the message sent prior to the repeated restart.\n\n\nThe master will not acknowledge (Yes I know, laugh all you want)\n\n\nThe stop condition or a repeated restart is executed.\n\n\n\n\nA visual depiction of a common I2C message is below:\n\n\n\n\nOn the PICpilot, the only I2C peripheral currently in use is the altimeter. The altimeter is connected to the path managing chip.\n\n\nIn the code\n\n\nThe initialization of I2C on the dspic33fj256710a is very simple. There are only a few necessary choices to make:\n\n\nI2C2CONbits.A10M = 0;   //7 bit address mode\n\nI2C2CONbits.DISSLW = 1; //Slew Rate control disabled for 100KHz\n\nI2C2CONbits.SMEN = 0;   //Do NOT use SMBus voltage configuration\n\n///I2C1BRG  - BAUD RATE GENERATOR\n\n///MPL3115A2 requires Max 4MHz\n\nI2C2BRG = 19;           //~118KHz clock rate; FCY = 4MHz\n\n//Enable the I2C module\n\nI2C2CONbits.I2CEN = 1;\n\n\n\nAs you can see, there are only a few important distinctions to make. Firstly, you can have a 10 bit addressing mode or a 7 bit addressing mode. On the PICpilot we use the 7 bit mode.\n\n\nSecondly, the clock rate is set via the I2C2BRG register. This could be upgraded to a faster communication speed in the future. The I2C module is then enabled.\n\n\nAt this point reading and writing can take place. The function to do so is called \nsendMessage()\n:\n\n\nchar sendMessage(char devAddress, char address, char\\* data, char length, char rw)\n\n{\n\n    char rData = 0;\n\n    I2CIdle();\n\n    I2C2CONbits.SEN = 1;  //Send Start condition\n\n    I2CIdle();\n\n    //SET Slave Address \n write (Address shifted one bit left and then the write(0) bit is added)\n\n    I2C2TRN = devAddress \n 1; //If reading, the read process is specified after the dummy bytes.\n\n    if (rw == READ) //If in reading mode\n\n    {\n\n        rData = readMessage(devAddress, address);\n\n    }\n\n    else //Otherwise go into writing mode\n\n    {\n\n       writeMessage(address,data, length);\n\n    }\n\n    I2CIdle();\n\n    I2C2CONbits.PEN = 1; //Send Stop condition\n\n    I2CIdle();\n\n    return rData;\n\n}\n\n\n\nIn the above code, the I2CIdle(); command is a while loop, which waits until the module is ready to transmit:\n\n\nwhile((I2C2CON \n 0x1F ) || I2C2STATbits.TRSTAT == 1);\n\n\n\nIn the code, it is evident that the start condition is asserted (using control register 2), followed by loading the device address and the write bit into the \nI2C2TRN\n transmit buffer. At this point the read or write functions are executed, depending on the request, before finally sending the stop condition.\n\n\nThe write command is extremely simple. It simply loops through the data, waiting for an acknowledgment after each one.\n\n\nvoid writeMessage(char address, char\\* data, char length)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the address.\n\n    //Write each byte of data\n\n    int i = 0;\n\n    for(i = 0; i \n length; i++)\n\n    {\n\n        I2CIdle();//Check until transmition was completed\n\n        I2C2TRN = (char)data[i];\n\n    }\n\n}\n\n\n\nNote, that the register address is first specified, followed by the iteration of bits that is sent to the buffer.\n\n\nOn the contrary the read message is a bit more complicated:\n\n\nchar readMessage(char devAddress, char address)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the local address.\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2CONbits.RSEN = 1; //Resend the start condition\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2TRN = (devAddress \n 1) + 1; //Shift and add the read bit(1) - Prep for restart\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    ///THE MESSAGE FROM THE SLAVE IS SENT HERE\n\n    I2C2CONbits.RCEN = 1; //Enable receive mode\n\n    I2CIdle(); //Wait until all 8 bits have been acquired\n\n    while (I2C2STATbits.RBF != 1);\n\n    char data = I2C2RCV;\n\n    //Send back a NACK\n\n    I2C2CONbits.ACKDT = 1; //Send NACK\n\n    I2C2CONbits.ACKEN = 1; //Start the acknowledge sequence\n\n    I2CIdle(); //Wait until done\n\n    return data;\n\n}\n\n\n\nThe register address is sent, which is followed by a restart condition. Then the device address is sent, BUT this time, the read bit is sent. At this point, the master enables receiving and waits until all data is received. A NACK (Not Acknowledgement) is sent prior to returning the data.\n\n\nThe device and register addresses depend on the device and its functionality.", 
            "title": "I2C"
        }, 
        {
            "location": "/picpilot/i2c/#i2c", 
            "text": "I2C stands for Inter-Integrated Circuit. It is pronounced \"I-two-C\" or \"I-squared-C\". It is similar to SPI, with the exception that it does not require a slave select line. All communication takes place on one data line, and one clock line. I2C is a  synchronous  method of communication, indicating that a clock line is present. Once again, I2C is a protocol for chips to be able to communicate between one another through serial connections (data on a single wire). It cannot operate in full duplex mode, unlike SPI. This means that both chips take turns transmitting and receiving and cannot do so at the same time. The minimum hardware requirements include a clock line (SCL), a data line (SDA), and both lines connected to Vdd via a pull-up resistor. The connections should looks like this:   This protocol is extremely simple from a hardware point of view. However, it is significantly slower than SPI, which is the main disadvantage. If you require high speed communication, I2C is not the best choice.  In a similar fashion to SPI, I2C also has Master and Slave devices. I2C protocol dictates that the master must always initialize communication.  There are two types of messages that a master device can send. It can be a read or a write message. Both messages are similar in structure; however, the read message requires the slave to respond, whereas the write message does not.  The write message is structured in the following order:   Start condition is specified on SDA and SCL (depends on the settings but typically involves the master pulling the data line low, shortly followed by the clock line being pulled low)  An 8-bit message is then sent, which contains a 7-bit (unique) identifying address, which determines what slave will engage in the data transfer. The 8th bit of the message is a read or write bit. When the bit is low (0), this indicates a write. When the bit is high (1), this indicates a read. In this scenario, we express the write bit (0).  The master waits for an acknowledgment from the slave. The acknowledgment is the slave pulling the data line low (0), while the master listens. If the acknowledgment is not received, there is likely a problem with the device or the connection.  At this point data is written 8 bits at a time, until the stop condition is expressed by the master. After each bit, the slave must acknowledge (ACK).  The stop condition is expressed. (SDA is pulled low, then the SCL is pulled high and it stops pulsing. The SDA is then also pulled high.)   The read message is very similar to the write message. The start condition and the first byte (address and write bit) must always be present. If a read condition is to exist, a repeated restart must be executed followed by the address of the slave with the read bit (1). The second byte/message may be a command message. Following the message, for the next 8 bytes, the master will expect a response to the command.  Assuming that the write message from above was never stopped, the read message would be as follows:   Execute a repeated restart.  Send the slave address with a read bit (1).  The slave will respond with 8 bits of data. These 8 bits of data depend on the message sent prior to the repeated restart.  The master will not acknowledge (Yes I know, laugh all you want)  The stop condition or a repeated restart is executed.   A visual depiction of a common I2C message is below:   On the PICpilot, the only I2C peripheral currently in use is the altimeter. The altimeter is connected to the path managing chip.", 
            "title": "I2C"
        }, 
        {
            "location": "/picpilot/i2c/#in-the-code", 
            "text": "The initialization of I2C on the dspic33fj256710a is very simple. There are only a few necessary choices to make:  I2C2CONbits.A10M = 0;   //7 bit address mode\n\nI2C2CONbits.DISSLW = 1; //Slew Rate control disabled for 100KHz\n\nI2C2CONbits.SMEN = 0;   //Do NOT use SMBus voltage configuration\n\n///I2C1BRG  - BAUD RATE GENERATOR\n\n///MPL3115A2 requires Max 4MHz\n\nI2C2BRG = 19;           //~118KHz clock rate; FCY = 4MHz\n\n//Enable the I2C module\n\nI2C2CONbits.I2CEN = 1;  As you can see, there are only a few important distinctions to make. Firstly, you can have a 10 bit addressing mode or a 7 bit addressing mode. On the PICpilot we use the 7 bit mode.  Secondly, the clock rate is set via the I2C2BRG register. This could be upgraded to a faster communication speed in the future. The I2C module is then enabled.  At this point reading and writing can take place. The function to do so is called  sendMessage() :  char sendMessage(char devAddress, char address, char\\* data, char length, char rw)\n\n{\n\n    char rData = 0;\n\n    I2CIdle();\n\n    I2C2CONbits.SEN = 1;  //Send Start condition\n\n    I2CIdle();\n\n    //SET Slave Address   write (Address shifted one bit left and then the write(0) bit is added)\n\n    I2C2TRN = devAddress   1; //If reading, the read process is specified after the dummy bytes.\n\n    if (rw == READ) //If in reading mode\n\n    {\n\n        rData = readMessage(devAddress, address);\n\n    }\n\n    else //Otherwise go into writing mode\n\n    {\n\n       writeMessage(address,data, length);\n\n    }\n\n    I2CIdle();\n\n    I2C2CONbits.PEN = 1; //Send Stop condition\n\n    I2CIdle();\n\n    return rData;\n\n}  In the above code, the I2CIdle(); command is a while loop, which waits until the module is ready to transmit:  while((I2C2CON   0x1F ) || I2C2STATbits.TRSTAT == 1);  In the code, it is evident that the start condition is asserted (using control register 2), followed by loading the device address and the write bit into the  I2C2TRN  transmit buffer. At this point the read or write functions are executed, depending on the request, before finally sending the stop condition.  The write command is extremely simple. It simply loops through the data, waiting for an acknowledgment after each one.  void writeMessage(char address, char\\* data, char length)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the address.\n\n    //Write each byte of data\n\n    int i = 0;\n\n    for(i = 0; i   length; i++)\n\n    {\n\n        I2CIdle();//Check until transmition was completed\n\n        I2C2TRN = (char)data[i];\n\n    }\n\n}  Note, that the register address is first specified, followed by the iteration of bits that is sent to the buffer.  On the contrary the read message is a bit more complicated:  char readMessage(char devAddress, char address)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the local address.\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2CONbits.RSEN = 1; //Resend the start condition\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2TRN = (devAddress   1) + 1; //Shift and add the read bit(1) - Prep for restart\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    ///THE MESSAGE FROM THE SLAVE IS SENT HERE\n\n    I2C2CONbits.RCEN = 1; //Enable receive mode\n\n    I2CIdle(); //Wait until all 8 bits have been acquired\n\n    while (I2C2STATbits.RBF != 1);\n\n    char data = I2C2RCV;\n\n    //Send back a NACK\n\n    I2C2CONbits.ACKDT = 1; //Send NACK\n\n    I2C2CONbits.ACKEN = 1; //Start the acknowledge sequence\n\n    I2CIdle(); //Wait until done\n\n    return data;\n\n}  The register address is sent, which is followed by a restart condition. Then the device address is sent, BUT this time, the read bit is sent. At this point, the master enables receiving and waits until all data is received. A NACK (Not Acknowledgement) is sent prior to returning the data.  The device and register addresses depend on the device and its functionality.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/datalink/", 
            "text": "Datalink\n\n\nThe datalink is one of the most important peripheral components in an unmanned system. It provides information on the status of the aircraft (telemetry) and provides the crucial functionality of an uplink, in order to be able to communicate with the system and make changes to its overall functionality.\n\n\nMake note that the details of this system can change frequently due to the requirements of each user. The telemetry data may change from the ones present in this document. Likewise, uplink commands may change based on newly implemented features and requirements. Although, this document should be updated whenever there is a change, this may not always occur. Therefore, be careful when referencing data in this section.\n\n\nTelemetry (Downlink) Data\n\n\n\n\n\n\n\n\nData\n\n\nProgramming Variable\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLatitude\n\n\nLat\n\n\nLong double (64bit floating point)\n\n\nThe latitude location of the airplane in degrees.\n\n\n\n\n\n\nLongitude\n\n\nLon\n\n\nLong double (64bit floating point)\n\n\nThe longitude location of the airplane in degrees.\n\n\n\n\n\n\nTime\n\n\nTime\n\n\nFloat (32 bit floating point)\n\n\nThe time as a UTC time stamp.\n\n\n\n\n\n\nPitch\n\n\nPitch\n\n\nFloat\n\n\nThe current state estimation of the pitch of the aircraft in degrees.\n\n\n\n\n\n\nRoll\n\n\nRoll\n\n\nFloat\n\n\nThe current state estimation of the roll of the aircraft in degrees.\n\n\n\n\n\n\nYaw\n\n\nYaw\n\n\nFloat\n\n\nThe current state estimation of the yaw of the aircraft according to the magnetometer in degrees.\n\n\n\n\n\n\nPitch Rate\n\n\nPitch_rate\n\n\nFloat\n\n\nThe gyroscope sensor data. The rate of rotation of the aircraft in radians per second.\n\n\n\n\n\n\nRoll Rate\n\n\nRoll_rate\n\n\nFloat\n\n\nThe gyroscope sensor data. The rate of rotation of the aircraft in radians per second.\n\n\n\n\n\n\nYaw Rate\n\n\nYaw_rate\n\n\nFloat\n\n\nThe gyroscope sensor data. The rate of rotation of the aircraft in radians per second.\n\n\n\n\n\n\nDerivative Gain\n\n\nKd_gain\n\n\nFloat\n\n\nA predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.\n\n\n\n\n\n\nProportional Gain\n\n\nKp_gain\n\n\nFloat\n\n\nA predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.\n\n\n\n\n\n\nIntegral Gain\n\n\nKi_gain\n\n\nFloat\n\n\nA predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.\n\n\n\n\n\n\nHeading\n\n\nHeading\n\n\nFloat\n\n\nThe GPS heading of the aircraft in degrees ranging from 0 to 360.\n\n\n\n\n\n\nGround Speed\n\n\nGround_speed\n\n\nFloat\n\n\nThe ground speed of the aircraft in meters per second.\n\n\n\n\n\n\nPitch Setpoint\n\n\nPitch_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the pitch angle in degrees.\n\n\n\n\n\n\nRoll Setpoint\n\n\nRoll_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the Roll angle in degrees.\n\n\n\n\n\n\nHeading Setpoint\n\n\nheading_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the heading angle in degrees.\n\n\n\n\n\n\nThrottle Setpoint\n\n\nThrottle_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the propeller speed in terms of percentage (0-100%)\n\n\n\n\n\n\nAltitude Setpoint\n\n\naltitude_setpoint\n\n\nFloat\n\n\nThe autopilot-controlled setpoint for the altitude above mean sea level. (in meters)\n\n\n\n\n\n\nAltitude\n\n\naltitude\n\n\nFloat\n\n\nThe altitude of the plane above the mean sea level (in meters)\n\n\n\n\n\n\nPitch Setpoint (Controller)\n\n\nint_pitch_setpoint\n\n\nFloat\n\n\nThe user input for the Pitch angle in arbitrary timer tick units.\n\n\n\n\n\n\nRoll Setpoint(Controller)\n\n\nint_roll_setpoint\n\n\nFloat\n\n\nThe user input for the Roll angle in arbitrary timer tick units.\n\n\n\n\n\n\nYaw Setpoint (Controller)\n\n\nint_yaw_setpoint\n\n\nFloat\n\n\nThe user input for the yaw angle in arbitrary timer tick units.\n\n\n\n\n\n\nLast Wireless Command Sent\nReceived\n\n\nlastCommandSent\n\n\nint\n\n\nThis is a combination of the command number (commands.h) multiplied by 100. For every subsequent call, the number is incremented by 1.For example, if the return home command was called 5 times, this variable would be equal to: \n4105\n\n\n\n\n\n\nError Codes\n\n\nerrorCodes\n\n\nUnsigned int\n\n\nSignals any problems that may be occurring or have occurred.This value is retrieved from StartupErrorCodes.c. The possible values are (and any binary combination):0b0000000000000000: No Errors0b0000000000000001:Power on reset occurred.0b0000000000000010:Brown out reset occurred.0b0000000000000100:Idle Mode Reset Occurred.0b0000000000001000:Sleep Mode Reset Occurred.0b0000000000010000:Software Watch Dog Timer Reset Occurred.0b0000000000100000:Software Reset Occurred.0b0000000001000000:External Reset Occurred.0b0000000010000000:Voltage Regulator Reset Occurred.0b0000000100000000:Illegal Opcode Reset Occurred.0b0000001000000000:Trap Reset Occurred.0b1000000000000000:UHF Switch is ON (Can be used to indicate joystick controller connection)\n\n\n\n\n\n\nCamera Counter\n\n\ncameraCounter\n\n\nUnsigned Int\n\n\nEvery time the camera is triggered, this value increases by one. This allows one to keep track which picture corresponds to what data.\n\n\n\n\n\n\nWaypoint Index\n\n\nwaypointIndex\n\n\nChar\n\n\nIndicates what waypoint the vehicle is attempting to get to.-1 - indicates that the vehicle is going \"HOME\"Any other value indicates the waypoint in the order that it was added.\n\n\n\n\n\n\nController Status Indicator\n\n\nEditing_gain\n\n\nChar\n\n\nAn indicator that depicts which gain values are currently being changed.0x00 = Manual Mode0x01 = Yaw0x02 = Pitch0x03 = Roll0x04 = Heading0x05 = Altitude0x06 = Throttle\n\n\n\n\n\n\nGPS Status Indicator\n\n\nGps_status\n\n\nChar\n\n\nAn indicator that depicts the number of satellites connected, as well as the status of the gps fix. Format:0x\n For example:0x00 = No GPS Fix, 0 Satellites0x1A = GPS Fix, 10 Satellites0x24 = DGPS Fix, 4 Satellites\n\n\n\n\n\n\nBattery Level Indicator\n\n\nbatteryLevel\n\n\nChar\n\n\nThis indicator provides the battery level as a percentage (%) of the original battery capacity specified in the voltageSensor.c/h files.\n\n\n\n\n\n\n\n\nNote that all telemetry data must be visible within the scope of the AttitudeManager.c file.\n\n\nCommand (Uplink) Data\n\n\nEvery command that is sent to the UAV must be predefined with an ID, as well as an associated function. Some commands only change variable values, whereas some call functions with the associated data as a parameter.\n\n\n\n\n\n\n\n\nCommand ID\n\n\nSocket Command\n\n\nAssociated Function\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\ndebug:\n\n\nUART1_SendString(\n)\n\n\nChar Array\n\n\nThe debugging command, which writes to the UART1 port.\n\n\n\n\n\n\n1\n\n\nset_pitchKDGain:\n\n\nsetGain(PITCH, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for pitch control.\n\n\n\n\n\n\n2\n\n\nset_rollKDGain:\n\n\nsetGain(ROLL, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for roll control.\n\n\n\n\n\n\n3\n\n\nset_yawKDGain:\n\n\nsetGain(YAW, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for yaw control.\n\n\n\n\n\n\n4\n\n\nset_pitchKPGain:\n\n\nsetGain(PITCH, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for pitch control.\n\n\n\n\n\n\n5\n\n\nset_rollKPGain:\n\n\nsetGain(ROLL, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for roll control.\n\n\n\n\n\n\n6\n\n\nset_yawKPGain:\n\n\nsetGain(YAW, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for yaw control.\n\n\n\n\n\n\n7\n\n\nset_pitchKIGain:\n\n\nsetGain(PITCH, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for pitch control.\n\n\n\n\n\n\n8\n\n\nset_rollKIGain:\n\n\nsetGain(ROLL, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for roll control.\n\n\n\n\n\n\n9\n\n\nset_yawKIGain:\n\n\nsetGain(YAW, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for yaw control.\n\n\n\n\n\n\n10\n\n\nset_headingKDGain:\n\n\nsetGain(HEADING, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for heading control.\n\n\n\n\n\n\n11\n\n\nset_headingKPGain:\n\n\nsetGain(HEADING, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for heading control.\n\n\n\n\n\n\n12\n\n\nset_headingKIGain:\n\n\nsetGain(HEADING, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for heading control.\n\n\n\n\n\n\n13\n\n\nset_altitudeKDGain:\n\n\nsetGain(ALTITUDE, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for altitude control.\n\n\n\n\n\n\n14\n\n\nset_altitudeKPGain:\n\n\nsetGain(ALTITUDE, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the proportional gain for altitude control.\n\n\n\n\n\n\n15\n\n\nset_altitudeKIGain:\n\n\nsetGain(ALTITUDE, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for altitude control.\n\n\n\n\n\n\n16\n\n\nset_throttleKDGain:\n\n\nsetGain(THROTTLE, KD_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for throttle control (speed).\n\n\n\n\n\n\n17\n\n\nset_throttleKPGain:\n\n\nsetGain(THROTTLE, KP_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the derivative gain for throttle control (speed).\n\n\n\n\n\n\n18\n\n\nset_throttleKIGain:\n\n\nsetGain(THROTTLE, KI_GAIN, \n)\n\n\nFloat\n\n\nThe command to set the integral gain for throttle control (speed).\n\n\n\n\n\n\n19\n\n\nset_pathGain:\n\n\n\n\nFloat\n\n\nThe command used to set the gain that scales lateral positional control around a path.\n\n\n\n\n\n\n20\n\n\nset_orbitGain:\n\n\n\n\nFloat\n\n\nThe command used to set the gain that scales orbital convergence.\n\n\n\n\n\n\n21\n\n\nset_showGain:\n\n\ndisplayGain = \n\n\nChar\n\n\nThe command used to switch the output between multiple gain types:0x00 = Yaw0x01 = Pitch0x02 = Roll0x03 = Heading0x04 = Altitude0x05 = Throttle*Note that there is no support for the path gain or orbital gain yet.\n\n\n\n\n\n\n22\n\n\nset_pitchRate:\n\n\nsp_PitchRate = \n\n\nInt\n\n\nThe user input for the pitch rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]). Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n23\n\n\nset_rollRate:\n\n\nsp_RollRate = \n\n\nInt\n\n\nThe user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n24\n\n\nset_yawRate:\n\n\nsp_YawRate = \n\n\nInt\n\n\nThe user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n25\n\n\nset_pitchAngle:\n\n\nsp_PitchAngle = \n\n\nFloat\n\n\nThe user input for the pitch angle in degrees. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n26\n\n\nset_rollAngle:\n\n\nsp_RollAngle = \n\n\nFloat\n\n\nThe user input for the roll angle in degrees. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n27\n\n\nset_yawAngle:\n\n\nsp_YawAngle = \n\n\nFloat\n\n\nThe user input for the yaw angle in degrees. WILL LIKELY BE REMOVED IN THE FUTURE IF UNEEDED. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n28\n\n\nset_altitude:\n\n\nsp_Altitude = \n\n\nFloat\n\n\nThe user input for the altitude in meters above sea level. Note you must set command 32 greater than 6 to use this.\n\n\n\n\n\n\n29\n\n\nset_heading:\n\n\n = \n\n\nFloat\n\n\nThe user input for the heading in standard compass bearing degrees. Note you must set command 32 greater than 7 to use this.\n\n\n\n\n\n\n30\n\n\nset_throttle:\n\n\n = \n\n\nInt\n\n\nThe user input for the throttle as a percentage. Note you must set command 32 to 8 to use this.\n\n\n\n\n\n\n31\n\n\nset_autonomousLevel:\n\n\ncontrolLevel = \n\n\nInt\n\n\nThis sets the source of control input between the autopilot, the remote control, and the ground stations:0b00000000 = Full manual control (default)0b00000001 = Set Pitch Rate(0), Pitch Angle(1)0b00000010 = Pitch Control Source: Controller(0), Ground Station(1) 0b00000100 = Roll Control Type: Roll Rate(0), Roll Angle(1)0b00001000 = Roll Control Sources: Controller(0), Ground Station(1)0b00110000 = Throttle control source: Controller(0), Ground Station(1), Autopilot(2) 0b01000000 = Altitude Source: Ground Station(0), Autopilot(1)0b10000000 = Altitude Control On(1) or Off(0)0b100000000 = Heading control source: Ground Station(0), Autopilot(1)0b1000000000=  To fly with Ground Station Control of the Pitch Rate and Roll Angle:set_autonomousLevel:14To fly with Ground Station Control of the Pitch Rate, Roll Angle, and Throttle:set_autonomousLevel:30To fly with Ground Station Control of Altitude, and Throttle (Roll controlled by controller):set_autonomousLevel:134To fly with Ground Station Control of Altitude, Throttle, Roll Angle:set_autonomousLevel:156To reset everything and fly with controller:set_autonomousLevel:0\n\n\n\n\n\n\n32\n\n\nset_angularWalkVariance:\n\n\nsetAngularWalkVariance(\n)\n\n\nFloat\n\n\nSets the Kalman Filter parameter that determines how fast the gyro bias estimates converge.\n\n\n\n\n\n\n33\n\n\nSet_gyroVariance:\n\n\nsetGyroVariance(\n)\n\n\nFloat\n\n\nSets the Kalman filter parameter that determines the weighting of the gryo in the attitude estimates of the plane.\n\n\n\n\n\n\n34\n\n\nset_magneticVariance:\n\n\nsetMagneticVariance(\n)\n\n\nFloat\n\n\nSets the Kalman filter parameter that determines the weighting of the magnetometers in the attitude estimates of the plane.\n\n\n\n\n\n\n35\n\n\nset_accelVariance:\n\n\nsetAccelVariance(\n)\n\n\nFloat\n\n\nSets the Kalman filter parameter that determines the weighting of the accelerometers in the attitude estimates of the plane.\n\n\n\n\n\n\n36\n\n\nset_scaleFactor:\n\n\npitchScaleFactor = \n\n\nFloat\n\n\nSets the value for the feed-forward term of pitch, when the aircraft is turning. In other words, when the aircraft is turning, this proportion is added to the elevators to prevent the airplane from losing altitude.\n\n\n\n\n\n\n37\n\n\ncalibrate_altimeter:\n\n\namData.calibrationHeight = \namData.command = PM_CALIBRATE_ALTIMETER\n\n\nFloat\n\n\nThis sets the reference height on the altimeter to a predefined value. This allows one to choose a \nrelative\n value for the height aircraft. For example, one may set 0m to refer to the starting or landing terrain height.\n\n\n\n\n\n\n38\n\n\nclear_waypoints:\n\n\namData.waypoint.id = \namData.command = PM_CLEAR_WAYPOINTS\n\n\nByte\n\n\nThis command clears ALL waypoints. The \n is just a dummy variable.\n\n\n\n\n\n\n39\n\n\nremove_waypoint:\n\n\namData.waypoint.id = \namData.command = PM_REMOVE_WAYPOINT\n\n\nByte\n\n\nThis command removes a specific waypoint given a specific ID as the parameter.\n\n\n\n\n\n\n40\n\n\nset_targetWaypoint:\n\n\namData.waypoint.id = \namData.command = PM_SET_TARGET_WAYPOINT\n\n\nByte\n\n\nThe target waypoint is the waypoint which the UAV is trying to currently get to. If this command is called, it can be used to skip waypoints, or return to waypoints. The \n is the specified ID for the new target.\n\n\n\n\n\n\n41\n\n\nreturn_home:\n\n\namData.command = PM_RETURN_HOME\n\n\nByte\n\n\nThis tells the plane to go to the \"home\" coordinates. The \n is just a dummy variable.\n\n\n\n\n\n\n42\n\n\ncancel_returnHome:\n\n\namData.command = PM_CANCEL_RETURN_HOME\n\n\nByte\n\n\nThis tells the plane to return back to its original path after being called to the \"home\" coordinates.\n\n\n\n\n\n\n43\n\n\nsend_heartbeat:\n\n\nheartbeatTimer = time\n\n\nByte\n\n\nThis sends a \"heartbeat\" (verification ping) to the plane to tell it that a data connection is still present. If this command is not received after a certain amount of time, emergency maneuvers will be used.\n\n\n\n\n\n\n44\n\n\ntrigger_camera:\n\n\ntriggerCamera(\n)\n\n\nInt\n\n\nThis manually triggers the camera via a \"fake\" PWM signal. The \n is the integer value of the PWM signal.\n\n\n\n\n\n\n45\n\n\nset_triggerDistance:\n\n\nsetTriggerDistance(\n)\n\n\nFloat\n\n\nThis sets the trigger distance (how often a picture is taken based on distance). This \n is a value in meters.\n\n\n\n\n\n\n46\n\n\nset_gimbleOffset:\n\n\nsetGimbleOffset(\n)\n\n\nInt\n\n\nThis provides an offset to the gimbal. If the gimbal is misaligned on start up, this function can correct it.\n\n\n\n\n\n\n47\n\n\nkill_plane:\n\n\nif (\n == 1234)                    killingPlane = 1;\n\n\nInt\n\n\nThis crashes the plane into the ground (in emergencies). This requires a password (\n = \"1234\") to ensure this isn't an accident.\n\n\n\n\n\n\n48\n\n\nunkill_plane:\n\n\nif (\n == 1234)                    killingPlane = 0;\n\n\nInt\n\n\nThis changes the state of the plane from \"I'm crashing\" to \"Nevermind, this was just a test\". This requires a password (\n = \"1234\") to ensure this isn't an accident.\n\n\n\n\n\n\n128\n\n\nnew_waypoint:\n,\n,\n,\n\n\namData.command = PM_NEW_WAYPOINTamData.waypoint = \n\n\n4 floats\n\n\nThis uploads and appends a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius).\n\n\n\n\n\n\n129\n\n\ninsert_Waypoint:\n\n\namData.command = PM_INSERT_WAYPOINT amData.waypoint = \n\n\n4 floats followed by 2 Bytes\n\n\nThis uploads and inserts a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius,nextID,previousID).\n\n\n\n\n\n\n130\n\n\nset_ReturnHomeCoordinates:\n\n\namData.command = PM_SET_RETURN_HOME_COORDINATESamData.waypoint = \n\n\n3 Floats\n\n\nThis sets the home coordinates, to which the plane will return in case of an emergency. The format is (longitude, latitude, altitude).\n\n\n\n\n\n\n131\n\n\ntare_IMU:\n,\n,\n\n\nadjustVNOrientationMatrix(float* adjustment);\n\n\n3 Floats\n\n\nThis adds a bias adjustment to the matrix based on the last setting. The 3 data values are the x,y,z components of the aircraft.\n\n\n\n\n\n\n132\n\n\nSet_IMU:\n,\n,\n\n\nsetVNOrientationMatrix(float* adjustment);\n\n\n3 Floats\n\n\nThis is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.\n\n\n\n\n\n\n\n\nIn the code\n\n\nPrior to usage, the datalink must be initialized.  This is done so in \nmain.c _using _initDataLink()\n. This simply initializes the UART2 interface (see UART section) for appropriate usage with the datalink.\n\n\nAfter initialization, the data link can be used. The interface used to queue data to the datalink is present in the AttitudeManager.c file.\n\n\nIn the code \u2013 Downlink/Telemetry\n\n\nData is exported to the data link at a certain frequency (according to a clock). This is done by calling \nwriteDatalink(frequency)\n, where frequency is the time between packets. This subroutine creates a structure (defined in \nnet.h\n) which contains memory locations for every variable. This data is then pushed to be processed in \nnet_outbound.c\n.\n\n\nif (time - lastTime \n frequency) {\n\n    lastTime = time;\n\n    struct telem_block* statusData = createTelemetryBlock();\n\n    statusData-\nlat = gps_Latitude;\n\n    statusData-\nlon = gps_Longitude;\n\n    ...\n\nreturn pushOutboundTelemetryQueue(statusData);\n\n}\n\n\n\nWhen all the data is assembled in the struct, \npushOutboundTelemetryQueue(statusData)\n is called. This pushes the data onto a queue to be processed later:\n\n\nint pushOutboundTelemetryQueue(struct telem_block *telem) {\n\n    if (getOutboundQueueLength() \n= OUTBOUND_QUEUE_SIZE) {\n\n        return -1;\n\n    }\n\n    outBuffer[outbuff_end] = telem;\n\n    outbuff_end++;\n\n    outbuff_end = outbuff_end % OUTBOUND_QUEUE_SIZE;\n\n    return getOutboundQueueLength();\n\n}\n\n\n\nNote that this is a circular buffer. When the buffer reaches the OUTBOUND_QUEUE_SIZE, the outbuff_end variable starts from 0 and overwrites the old data.\n\n\nEvery once in a while, the data accumulated must be processed. As a result, every iteration of the program runs a subroutine to maintain and cleanup the circular buffer. For the outgoing buffer, this method is \noutboundBufferMaintenance()\n:\n\n\nif ( stagingBuffer.sendIndex \n= PACKET_LENGTH ) {\n\n    destroyTelemetryBlock(stagingBuffer.telemetry.asStruct);\n\n    if ( getOutboundQueueLength() ) {\n\n        stageTelemetryBlock(popOutboundTelemetryQueue());\n\n    }\n\n} else if ( stagingBuffer.telemetry.asStruct == 0 \n getOutboundQueueLength() ) {\n\n    stageTelemetryBlock(popOutboundTelemetryQueue());\n\n}\n\n\n\nNote that the structure of \nstagingBuffer\n is as follows:\n\n\nstruct telem_buffer {\n\n    unsigned int sendIndex;             // index into telemetry to send\n\n    unsigned char header[API_HEADER_LENGTH];    // The header for the telem\n\n    union {\n\n        struct telem_block *asStruct;   // The telemetry block being sent\n\n        unsigned char *asArray;         // The telemetry intepreted as an array\n\n    } telemetry;\n\n    unsigned char checksum;             // The checksum so far\n\n};\n\n\n\nNote that the \nstagingBuffer _converts the data into a data link friendly format. The data link hardware requires that each data packet must be sent with a header, the data, and a checksum (For more specification see the XBEE section). These are 3 components of the _telem_buffer\n structure. The 4th component is the \nsendIndex\n variable. This value is used to keep track (index) what data has already been sent or still needs to be sent.\n\n\nAfter sufficient error checking (making sure \nsendIndex\n is less than the allowed packet size), stageTelemetryBlock(popOutboundTelemetryQueue()) is called. This method takes (pops) the next struct of data and stages it to be sent. \nstageTelemetryBlock()\n is responsible for converting the telemetry data into a \ntelem_buffer\n structure.\n\n\nvoid stageTelemetryBlock(struct telem_block *telem) {\n\n    stagingBuffer.telemetry.asStruct = telem;\n\n    generateApiHeader(stagingBuffer.header, 0);\n\n    stagingBuffer.checksum = 0;\n\n    // Send index should be reset last for reasons\n\n    stagingBuffer.sendIndex = 0;\n\n    sendNextByte();\n\n}\n\n\n\nThe first line of the subroutine adds the data into the packet. The second line (\ngenerateApiHeader(stagingBuffer.header,0))\n creates an appropriate header in the \nstagingBuffer.header\n memory address with a data frame of 0. (See the XBEE section for the datasheet). The API header includes information involving which device the packet should be sent to, the length of the packet, as well as acknowledgement options, and packet types (data packet, configuration packet, status packet). After the \nchecksum\n and \nsendIndex\n are explicitly reset, the sending process begins with \nsendNextByte()\n:\n\n\nvoid sendNextByte(void) {\n\n    unsigned char sendByte; // The byte to send\n\n    if ( stagingBuffer.sendIndex \n API_HEADER_LENGTH ) {\n\n        //while (U2STAbits.TRMT == 0);\n\n        sendByte = stagingBuffer.header[stagingBuffer.sendIndex] \n 0xFF;\n\n        // Compute checksum\n\n        if (stagingBuffer.sendIndex \n= 3) {\n\n            stagingBuffer.checksum += sendByte \n 0xFF;\n\n        }\n\n    } else if ( stagingBuffer.sendIndex \n PACKET_LENGTH - 1 ) {\n\n        sendByte = stagingBuffer.telemetry.asArray[stagingBuffer.sendIndex - API_HEADER_LENGTH] \n 0xFF;\n\n        stagingBuffer.checksum += sendByte \n 0xFF;\n\n    } else if ( stagingBuffer.sendIndex == PACKET_LENGTH - 1) {\n\n        sendByte = 0xFF - (stagingBuffer.checksum \n 0xFF);\n\n    } else {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    stagingBuffer.sendIndex++;\n\n    IFS1bits.U2TXIF = 0;\n\n    U2TXREG = sendByte;\n\n}\n\n\n\nAll the \"\nif\n\" statements above, compile the header, the data and the checksum together. Note that the checksum is the bitwise inverse of the actual sum: sendByte = 0xFF - (stagingBuffer.checksum \n 0xFF). The most important part of this process is the last line, where each byte is sent to the UART transmit buffer. Since the UART transmit process is interrupt-based, each interrupt keeps calling \nsendNextByte()\n, until there is no more data left:\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {\n\n    // Short circuit if nothing in the staging area yet\n\n    if ( stagingBuffer.telemetry.asStruct == 0 ) {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    sendNextByte();\n\n}\n\n\n\nThe process can be described through this flowchart:\n\n\n\n\nIn the code \u2013 Uplink\n\n\nOnce every iteration, a command is read from the uplink queue. This is done by calling readDatalink(). The command \npopCommand()\n is called. If any new commands have been received, \npopCommand()\n will return a \ncommand\n struct (defined in \nnet.h\n):\n\n\nstruct command {\n\n    unsigned char cmd;\n\n    unsigned char data\\_length;\n\n    unsigned char data[101];\n\n};\n\n\n\nIt is fairly straight forward. The structure contains a \ncmd.cmd _which indicates the command ID. This ID corresponds to a certain function that needs to be completed. Following the pop command are a series of case statements (one for each command ID). For instance, if the command ID is 30, the following command is run (in _net_inbound.c\n):\n\n\nstruct command* cmd = popCommand();\n\n//TODO: Add rudimentary input validation\n\nif ( cmd ) {\n\n    if (lastCommandSentCode == cmd-\ncmd){\n\n        lastCommandSentCode++;\n\n    }\n\n    else{\n\n        lastCommandSentCode = cmd-\ncmd * 100;\n\n    }\n\n    switch (cmd-\ncmd) {\n\n        ...\n\n        case SET_THROTTLE:\n\n            sp_ThrottleRate = (int)(*(int*)(\ncmd-\ndata) / 100.0  * (890 - 454) + 454);\n\n            break;\n\n        ...\n    }\n\n}\n\n\n\nThe throttle ends up being set to the value indicated in the \ncmd.data\n location. In addition, the last command read is stored and sent to the ground station as verification that the command was received.\n\n\nThe \npopCommand() _function waits and reads the next available command from a circular buffer (note the _INBOUND_QUEUE_SIZE\n variable). If the command doesn't exist, it exits the function.\n\n\nIn order for the command structure to exist, the \nU2RXInterrupt\n must have been triggered. This occurs when new data is sent.\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {\n\n    unsigned char data = U2RXREG;\n\n    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        IFS1bits.U2RXIF = 0;\n\n        return;\n\n    }\n\n    switch ( payloadPos ) {\n\n        case 0:\n\n            if ( data != START_DELIMITER ) {\n\n                IFS1bits.U2RXIF = 0;\n\n                return;\n\n            }\n\n            break;\n\n        case 1:\n\n            if ( data != 0 ) {\n\n                payloadPos = 0;\n\n                IFS1bits.U2RXIF = 0;\n\n                return;                 // packet length \n 100 bytes, so msb == 0\n\n            }\n\n            break;\n\n        case 2:\n\n            payloadLength[packetPos] = data;\n\n            break;\n\n        default:        // Normally, don't do anything special\n\n            break;\n\n    }\n\n    rawPackets[packetPos][payloadPos++] = data;\n\n    if ( payloadPos \n payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet\n\n        rawPacketStatus[packetPos] = READY;\n\n        payloadPos = 0;\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        if ( rawPacketStatus[packetPos] == EMPTY ) {\n\n            rawPacketStatus[packetPos] = BUSY;\n\n        }\n\n    }\n\n    IFS1bits.U2RXIF = 0;\n\n}\n\n\n\nThe first thing that occurs when new data arrives is a check to see if there is enough memory to store the data. A \nif statement\n is used to check if the buffer (rawPacketStatus) is busy or not.  Note that the interrupt will only record the data, if the current \npacketPos\n marked busy.\n\n\nIf the buffer is full, the next buffer location is checked. Otherwise, the packet is parsed byte by byte.\n\n\nFirstly, the start delimiter is looked for using a case statement. Until the start delimiter is found, nothing happens. Secondly, for case 1 and 2, the length of the packet is check and recorded. Once the length of the packet is known, the \ndata\n is read into a 2d array called \nrawPackets\n. This array contains each byte of every packet in the circular buffer. Once all the data is copied into the array, the packet is marked as \nREADY\n, and the next one is marked \nBUSY\n if it is \nEMPTY\n, and the processing of the data begins on the next maintenance cycle when \ninboundBufferMaintenance()\n is called from \nmain.c\n:\n\n\nvoid inboundBufferMaintenance(void) {\n\n    int i;\n\n    for ( i = 0; i \n RAW_PACKET_BUFFER_SIZE; i++ ) {\n\n        if ( rawPacketStatus[i] == READY \n checkPacket(rawPackets[i]) ) {\n\n            struct command\\* cmd = createCommand( rawPackets[i] );\n\n            if ( cmd ) {            // create command was successful ?\n\n                pushCommand( cmd ); // queue it up\n\n                rawPacketStatus[i] = EMPTY;         // buffer is now good for writing another packet\n\n            }\n\n        }\n\n    }\n\n    if ( rawPacketStatus[0] == EMPTY ) {\n\n        rawPacketStatus[0] = BUSY;\n\n    }\n\n}\n\n\n\nThis subroutine iterates through each buffer location and checks for any \nREADY\n packets. If one is found, and it has been verified through a checksum, the command structure is created from the data using the \ncreateCommand(rawPackets[i])\n method. Once this is done, the previous spot is marked \nEMPTY\n. The first buffer is always primed if it is empty.", 
            "title": "Datalink"
        }, 
        {
            "location": "/picpilot/datalink/#datalink", 
            "text": "The datalink is one of the most important peripheral components in an unmanned system. It provides information on the status of the aircraft (telemetry) and provides the crucial functionality of an uplink, in order to be able to communicate with the system and make changes to its overall functionality.  Make note that the details of this system can change frequently due to the requirements of each user. The telemetry data may change from the ones present in this document. Likewise, uplink commands may change based on newly implemented features and requirements. Although, this document should be updated whenever there is a change, this may not always occur. Therefore, be careful when referencing data in this section.", 
            "title": "Datalink"
        }, 
        {
            "location": "/picpilot/datalink/#telemetry-downlink-data", 
            "text": "Data  Programming Variable  Format  Description      Latitude  Lat  Long double (64bit floating point)  The latitude location of the airplane in degrees.    Longitude  Lon  Long double (64bit floating point)  The longitude location of the airplane in degrees.    Time  Time  Float (32 bit floating point)  The time as a UTC time stamp.    Pitch  Pitch  Float  The current state estimation of the pitch of the aircraft in degrees.    Roll  Roll  Float  The current state estimation of the roll of the aircraft in degrees.    Yaw  Yaw  Float  The current state estimation of the yaw of the aircraft according to the magnetometer in degrees.    Pitch Rate  Pitch_rate  Float  The gyroscope sensor data. The rate of rotation of the aircraft in radians per second.    Roll Rate  Roll_rate  Float  The gyroscope sensor data. The rate of rotation of the aircraft in radians per second.    Yaw Rate  Yaw_rate  Float  The gyroscope sensor data. The rate of rotation of the aircraft in radians per second.    Derivative Gain  Kd_gain  Float  A predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.    Proportional Gain  Kp_gain  Float  A predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.    Integral Gain  Ki_gain  Float  A predetermined gain value for a PID loop. Typically used for tuning and debugging purposes.    Heading  Heading  Float  The GPS heading of the aircraft in degrees ranging from 0 to 360.    Ground Speed  Ground_speed  Float  The ground speed of the aircraft in meters per second.    Pitch Setpoint  Pitch_setpoint  Float  The autopilot-controlled setpoint for the pitch angle in degrees.    Roll Setpoint  Roll_setpoint  Float  The autopilot-controlled setpoint for the Roll angle in degrees.    Heading Setpoint  heading_setpoint  Float  The autopilot-controlled setpoint for the heading angle in degrees.    Throttle Setpoint  Throttle_setpoint  Float  The autopilot-controlled setpoint for the propeller speed in terms of percentage (0-100%)    Altitude Setpoint  altitude_setpoint  Float  The autopilot-controlled setpoint for the altitude above mean sea level. (in meters)    Altitude  altitude  Float  The altitude of the plane above the mean sea level (in meters)    Pitch Setpoint (Controller)  int_pitch_setpoint  Float  The user input for the Pitch angle in arbitrary timer tick units.    Roll Setpoint(Controller)  int_roll_setpoint  Float  The user input for the Roll angle in arbitrary timer tick units.    Yaw Setpoint (Controller)  int_yaw_setpoint  Float  The user input for the yaw angle in arbitrary timer tick units.    Last Wireless Command Sent Received  lastCommandSent  int  This is a combination of the command number (commands.h) multiplied by 100. For every subsequent call, the number is incremented by 1.For example, if the return home command was called 5 times, this variable would be equal to:  4105    Error Codes  errorCodes  Unsigned int  Signals any problems that may be occurring or have occurred.This value is retrieved from StartupErrorCodes.c. The possible values are (and any binary combination):0b0000000000000000: No Errors0b0000000000000001:Power on reset occurred.0b0000000000000010:Brown out reset occurred.0b0000000000000100:Idle Mode Reset Occurred.0b0000000000001000:Sleep Mode Reset Occurred.0b0000000000010000:Software Watch Dog Timer Reset Occurred.0b0000000000100000:Software Reset Occurred.0b0000000001000000:External Reset Occurred.0b0000000010000000:Voltage Regulator Reset Occurred.0b0000000100000000:Illegal Opcode Reset Occurred.0b0000001000000000:Trap Reset Occurred.0b1000000000000000:UHF Switch is ON (Can be used to indicate joystick controller connection)    Camera Counter  cameraCounter  Unsigned Int  Every time the camera is triggered, this value increases by one. This allows one to keep track which picture corresponds to what data.    Waypoint Index  waypointIndex  Char  Indicates what waypoint the vehicle is attempting to get to.-1 - indicates that the vehicle is going \"HOME\"Any other value indicates the waypoint in the order that it was added.    Controller Status Indicator  Editing_gain  Char  An indicator that depicts which gain values are currently being changed.0x00 = Manual Mode0x01 = Yaw0x02 = Pitch0x03 = Roll0x04 = Heading0x05 = Altitude0x06 = Throttle    GPS Status Indicator  Gps_status  Char  An indicator that depicts the number of satellites connected, as well as the status of the gps fix. Format:0x  For example:0x00 = No GPS Fix, 0 Satellites0x1A = GPS Fix, 10 Satellites0x24 = DGPS Fix, 4 Satellites    Battery Level Indicator  batteryLevel  Char  This indicator provides the battery level as a percentage (%) of the original battery capacity specified in the voltageSensor.c/h files.     Note that all telemetry data must be visible within the scope of the AttitudeManager.c file.", 
            "title": "Telemetry (Downlink) Data"
        }, 
        {
            "location": "/picpilot/datalink/#command-uplink-data", 
            "text": "Every command that is sent to the UAV must be predefined with an ID, as well as an associated function. Some commands only change variable values, whereas some call functions with the associated data as a parameter.     Command ID  Socket Command  Associated Function  Format  Description      0  debug:  UART1_SendString( )  Char Array  The debugging command, which writes to the UART1 port.    1  set_pitchKDGain:  setGain(PITCH, KD_GAIN,  )  Float  The command to set the derivative gain for pitch control.    2  set_rollKDGain:  setGain(ROLL, KD_GAIN,  )  Float  The command to set the derivative gain for roll control.    3  set_yawKDGain:  setGain(YAW, KD_GAIN,  )  Float  The command to set the derivative gain for yaw control.    4  set_pitchKPGain:  setGain(PITCH, KP_GAIN,  )  Float  The command to set the proportional gain for pitch control.    5  set_rollKPGain:  setGain(ROLL, KP_GAIN,  )  Float  The command to set the proportional gain for roll control.    6  set_yawKPGain:  setGain(YAW, KP_GAIN,  )  Float  The command to set the proportional gain for yaw control.    7  set_pitchKIGain:  setGain(PITCH, KI_GAIN,  )  Float  The command to set the integral gain for pitch control.    8  set_rollKIGain:  setGain(ROLL, KI_GAIN,  )  Float  The command to set the proportional gain for roll control.    9  set_yawKIGain:  setGain(YAW, KI_GAIN,  )  Float  The command to set the proportional gain for yaw control.    10  set_headingKDGain:  setGain(HEADING, KD_GAIN,  )  Float  The command to set the derivative gain for heading control.    11  set_headingKPGain:  setGain(HEADING, KP_GAIN,  )  Float  The command to set the proportional gain for heading control.    12  set_headingKIGain:  setGain(HEADING, KI_GAIN,  )  Float  The command to set the integral gain for heading control.    13  set_altitudeKDGain:  setGain(ALTITUDE, KD_GAIN,  )  Float  The command to set the derivative gain for altitude control.    14  set_altitudeKPGain:  setGain(ALTITUDE, KP_GAIN,  )  Float  The command to set the proportional gain for altitude control.    15  set_altitudeKIGain:  setGain(ALTITUDE, KI_GAIN,  )  Float  The command to set the integral gain for altitude control.    16  set_throttleKDGain:  setGain(THROTTLE, KD_GAIN,  )  Float  The command to set the derivative gain for throttle control (speed).    17  set_throttleKPGain:  setGain(THROTTLE, KP_GAIN,  )  Float  The command to set the derivative gain for throttle control (speed).    18  set_throttleKIGain:  setGain(THROTTLE, KI_GAIN,  )  Float  The command to set the integral gain for throttle control (speed).    19  set_pathGain:   Float  The command used to set the gain that scales lateral positional control around a path.    20  set_orbitGain:   Float  The command used to set the gain that scales orbital convergence.    21  set_showGain:  displayGain =   Char  The command used to switch the output between multiple gain types:0x00 = Yaw0x01 = Pitch0x02 = Roll0x03 = Heading0x04 = Altitude0x05 = Throttle*Note that there is no support for the path gain or orbital gain yet.    22  set_pitchRate:  sp_PitchRate =   Int  The user input for the pitch rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]). Note you must set command 32 greater than 4 to use this.    23  set_rollRate:  sp_RollRate =   Int  The user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.    24  set_yawRate:  sp_YawRate =   Int  The user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.    25  set_pitchAngle:  sp_PitchAngle =   Float  The user input for the pitch angle in degrees. Note you must set command 32 greater than 5 to use this.    26  set_rollAngle:  sp_RollAngle =   Float  The user input for the roll angle in degrees. Note you must set command 32 greater than 5 to use this.    27  set_yawAngle:  sp_YawAngle =   Float  The user input for the yaw angle in degrees. WILL LIKELY BE REMOVED IN THE FUTURE IF UNEEDED. Note you must set command 32 greater than 5 to use this.    28  set_altitude:  sp_Altitude =   Float  The user input for the altitude in meters above sea level. Note you must set command 32 greater than 6 to use this.    29  set_heading:   =   Float  The user input for the heading in standard compass bearing degrees. Note you must set command 32 greater than 7 to use this.    30  set_throttle:   =   Int  The user input for the throttle as a percentage. Note you must set command 32 to 8 to use this.    31  set_autonomousLevel:  controlLevel =   Int  This sets the source of control input between the autopilot, the remote control, and the ground stations:0b00000000 = Full manual control (default)0b00000001 = Set Pitch Rate(0), Pitch Angle(1)0b00000010 = Pitch Control Source: Controller(0), Ground Station(1) 0b00000100 = Roll Control Type: Roll Rate(0), Roll Angle(1)0b00001000 = Roll Control Sources: Controller(0), Ground Station(1)0b00110000 = Throttle control source: Controller(0), Ground Station(1), Autopilot(2) 0b01000000 = Altitude Source: Ground Station(0), Autopilot(1)0b10000000 = Altitude Control On(1) or Off(0)0b100000000 = Heading control source: Ground Station(0), Autopilot(1)0b1000000000=  To fly with Ground Station Control of the Pitch Rate and Roll Angle:set_autonomousLevel:14To fly with Ground Station Control of the Pitch Rate, Roll Angle, and Throttle:set_autonomousLevel:30To fly with Ground Station Control of Altitude, and Throttle (Roll controlled by controller):set_autonomousLevel:134To fly with Ground Station Control of Altitude, Throttle, Roll Angle:set_autonomousLevel:156To reset everything and fly with controller:set_autonomousLevel:0    32  set_angularWalkVariance:  setAngularWalkVariance( )  Float  Sets the Kalman Filter parameter that determines how fast the gyro bias estimates converge.    33  Set_gyroVariance:  setGyroVariance( )  Float  Sets the Kalman filter parameter that determines the weighting of the gryo in the attitude estimates of the plane.    34  set_magneticVariance:  setMagneticVariance( )  Float  Sets the Kalman filter parameter that determines the weighting of the magnetometers in the attitude estimates of the plane.    35  set_accelVariance:  setAccelVariance( )  Float  Sets the Kalman filter parameter that determines the weighting of the accelerometers in the attitude estimates of the plane.    36  set_scaleFactor:  pitchScaleFactor =   Float  Sets the value for the feed-forward term of pitch, when the aircraft is turning. In other words, when the aircraft is turning, this proportion is added to the elevators to prevent the airplane from losing altitude.    37  calibrate_altimeter:  amData.calibrationHeight =  amData.command = PM_CALIBRATE_ALTIMETER  Float  This sets the reference height on the altimeter to a predefined value. This allows one to choose a  relative  value for the height aircraft. For example, one may set 0m to refer to the starting or landing terrain height.    38  clear_waypoints:  amData.waypoint.id =  amData.command = PM_CLEAR_WAYPOINTS  Byte  This command clears ALL waypoints. The   is just a dummy variable.    39  remove_waypoint:  amData.waypoint.id =  amData.command = PM_REMOVE_WAYPOINT  Byte  This command removes a specific waypoint given a specific ID as the parameter.    40  set_targetWaypoint:  amData.waypoint.id =  amData.command = PM_SET_TARGET_WAYPOINT  Byte  The target waypoint is the waypoint which the UAV is trying to currently get to. If this command is called, it can be used to skip waypoints, or return to waypoints. The   is the specified ID for the new target.    41  return_home:  amData.command = PM_RETURN_HOME  Byte  This tells the plane to go to the \"home\" coordinates. The   is just a dummy variable.    42  cancel_returnHome:  amData.command = PM_CANCEL_RETURN_HOME  Byte  This tells the plane to return back to its original path after being called to the \"home\" coordinates.    43  send_heartbeat:  heartbeatTimer = time  Byte  This sends a \"heartbeat\" (verification ping) to the plane to tell it that a data connection is still present. If this command is not received after a certain amount of time, emergency maneuvers will be used.    44  trigger_camera:  triggerCamera( )  Int  This manually triggers the camera via a \"fake\" PWM signal. The   is the integer value of the PWM signal.    45  set_triggerDistance:  setTriggerDistance( )  Float  This sets the trigger distance (how often a picture is taken based on distance). This   is a value in meters.    46  set_gimbleOffset:  setGimbleOffset( )  Int  This provides an offset to the gimbal. If the gimbal is misaligned on start up, this function can correct it.    47  kill_plane:  if (  == 1234)                    killingPlane = 1;  Int  This crashes the plane into the ground (in emergencies). This requires a password (  = \"1234\") to ensure this isn't an accident.    48  unkill_plane:  if (  == 1234)                    killingPlane = 0;  Int  This changes the state of the plane from \"I'm crashing\" to \"Nevermind, this was just a test\". This requires a password (  = \"1234\") to ensure this isn't an accident.    128  new_waypoint: , , ,  amData.command = PM_NEW_WAYPOINTamData.waypoint =   4 floats  This uploads and appends a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius).    129  insert_Waypoint:  amData.command = PM_INSERT_WAYPOINT amData.waypoint =   4 floats followed by 2 Bytes  This uploads and inserts a waypoint to the aircraft based on corresponding gps coordinates and path instructions. The format is (longitude, latitude, altitude,radius,nextID,previousID).    130  set_ReturnHomeCoordinates:  amData.command = PM_SET_RETURN_HOME_COORDINATESamData.waypoint =   3 Floats  This sets the home coordinates, to which the plane will return in case of an emergency. The format is (longitude, latitude, altitude).    131  tare_IMU: , ,  adjustVNOrientationMatrix(float* adjustment);  3 Floats  This adds a bias adjustment to the matrix based on the last setting. The 3 data values are the x,y,z components of the aircraft.    132  Set_IMU: , ,  setVNOrientationMatrix(float* adjustment);  3 Floats  This is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.", 
            "title": "Command (Uplink) Data"
        }, 
        {
            "location": "/picpilot/datalink/#in-the-code", 
            "text": "Prior to usage, the datalink must be initialized.  This is done so in  main.c _using _initDataLink() . This simply initializes the UART2 interface (see UART section) for appropriate usage with the datalink.  After initialization, the data link can be used. The interface used to queue data to the datalink is present in the AttitudeManager.c file.  In the code \u2013 Downlink/Telemetry  Data is exported to the data link at a certain frequency (according to a clock). This is done by calling  writeDatalink(frequency) , where frequency is the time between packets. This subroutine creates a structure (defined in  net.h ) which contains memory locations for every variable. This data is then pushed to be processed in  net_outbound.c .  if (time - lastTime   frequency) {\n\n    lastTime = time;\n\n    struct telem_block* statusData = createTelemetryBlock();\n\n    statusData- lat = gps_Latitude;\n\n    statusData- lon = gps_Longitude;\n\n    ...\n\nreturn pushOutboundTelemetryQueue(statusData);\n\n}  When all the data is assembled in the struct,  pushOutboundTelemetryQueue(statusData)  is called. This pushes the data onto a queue to be processed later:  int pushOutboundTelemetryQueue(struct telem_block *telem) {\n\n    if (getOutboundQueueLength()  = OUTBOUND_QUEUE_SIZE) {\n\n        return -1;\n\n    }\n\n    outBuffer[outbuff_end] = telem;\n\n    outbuff_end++;\n\n    outbuff_end = outbuff_end % OUTBOUND_QUEUE_SIZE;\n\n    return getOutboundQueueLength();\n\n}  Note that this is a circular buffer. When the buffer reaches the OUTBOUND_QUEUE_SIZE, the outbuff_end variable starts from 0 and overwrites the old data.  Every once in a while, the data accumulated must be processed. As a result, every iteration of the program runs a subroutine to maintain and cleanup the circular buffer. For the outgoing buffer, this method is  outboundBufferMaintenance() :  if ( stagingBuffer.sendIndex  = PACKET_LENGTH ) {\n\n    destroyTelemetryBlock(stagingBuffer.telemetry.asStruct);\n\n    if ( getOutboundQueueLength() ) {\n\n        stageTelemetryBlock(popOutboundTelemetryQueue());\n\n    }\n\n} else if ( stagingBuffer.telemetry.asStruct == 0   getOutboundQueueLength() ) {\n\n    stageTelemetryBlock(popOutboundTelemetryQueue());\n\n}  Note that the structure of  stagingBuffer  is as follows:  struct telem_buffer {\n\n    unsigned int sendIndex;             // index into telemetry to send\n\n    unsigned char header[API_HEADER_LENGTH];    // The header for the telem\n\n    union {\n\n        struct telem_block *asStruct;   // The telemetry block being sent\n\n        unsigned char *asArray;         // The telemetry intepreted as an array\n\n    } telemetry;\n\n    unsigned char checksum;             // The checksum so far\n\n};  Note that the  stagingBuffer _converts the data into a data link friendly format. The data link hardware requires that each data packet must be sent with a header, the data, and a checksum (For more specification see the XBEE section). These are 3 components of the _telem_buffer  structure. The 4th component is the  sendIndex  variable. This value is used to keep track (index) what data has already been sent or still needs to be sent.  After sufficient error checking (making sure  sendIndex  is less than the allowed packet size), stageTelemetryBlock(popOutboundTelemetryQueue()) is called. This method takes (pops) the next struct of data and stages it to be sent.  stageTelemetryBlock()  is responsible for converting the telemetry data into a  telem_buffer  structure.  void stageTelemetryBlock(struct telem_block *telem) {\n\n    stagingBuffer.telemetry.asStruct = telem;\n\n    generateApiHeader(stagingBuffer.header, 0);\n\n    stagingBuffer.checksum = 0;\n\n    // Send index should be reset last for reasons\n\n    stagingBuffer.sendIndex = 0;\n\n    sendNextByte();\n\n}  The first line of the subroutine adds the data into the packet. The second line ( generateApiHeader(stagingBuffer.header,0))  creates an appropriate header in the  stagingBuffer.header  memory address with a data frame of 0. (See the XBEE section for the datasheet). The API header includes information involving which device the packet should be sent to, the length of the packet, as well as acknowledgement options, and packet types (data packet, configuration packet, status packet). After the  checksum  and  sendIndex  are explicitly reset, the sending process begins with  sendNextByte() :  void sendNextByte(void) {\n\n    unsigned char sendByte; // The byte to send\n\n    if ( stagingBuffer.sendIndex   API_HEADER_LENGTH ) {\n\n        //while (U2STAbits.TRMT == 0);\n\n        sendByte = stagingBuffer.header[stagingBuffer.sendIndex]   0xFF;\n\n        // Compute checksum\n\n        if (stagingBuffer.sendIndex  = 3) {\n\n            stagingBuffer.checksum += sendByte   0xFF;\n\n        }\n\n    } else if ( stagingBuffer.sendIndex   PACKET_LENGTH - 1 ) {\n\n        sendByte = stagingBuffer.telemetry.asArray[stagingBuffer.sendIndex - API_HEADER_LENGTH]   0xFF;\n\n        stagingBuffer.checksum += sendByte   0xFF;\n\n    } else if ( stagingBuffer.sendIndex == PACKET_LENGTH - 1) {\n\n        sendByte = 0xFF - (stagingBuffer.checksum   0xFF);\n\n    } else {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    stagingBuffer.sendIndex++;\n\n    IFS1bits.U2TXIF = 0;\n\n    U2TXREG = sendByte;\n\n}  All the \" if \" statements above, compile the header, the data and the checksum together. Note that the checksum is the bitwise inverse of the actual sum: sendByte = 0xFF - (stagingBuffer.checksum   0xFF). The most important part of this process is the last line, where each byte is sent to the UART transmit buffer. Since the UART transmit process is interrupt-based, each interrupt keeps calling  sendNextByte() , until there is no more data left:  void __attribute__((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {\n\n    // Short circuit if nothing in the staging area yet\n\n    if ( stagingBuffer.telemetry.asStruct == 0 ) {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    sendNextByte();\n\n}  The process can be described through this flowchart:   In the code \u2013 Uplink  Once every iteration, a command is read from the uplink queue. This is done by calling readDatalink(). The command  popCommand()  is called. If any new commands have been received,  popCommand()  will return a  command  struct (defined in  net.h ):  struct command {\n\n    unsigned char cmd;\n\n    unsigned char data\\_length;\n\n    unsigned char data[101];\n\n};  It is fairly straight forward. The structure contains a  cmd.cmd _which indicates the command ID. This ID corresponds to a certain function that needs to be completed. Following the pop command are a series of case statements (one for each command ID). For instance, if the command ID is 30, the following command is run (in _net_inbound.c ):  struct command* cmd = popCommand();\n\n//TODO: Add rudimentary input validation\n\nif ( cmd ) {\n\n    if (lastCommandSentCode == cmd- cmd){\n\n        lastCommandSentCode++;\n\n    }\n\n    else{\n\n        lastCommandSentCode = cmd- cmd * 100;\n\n    }\n\n    switch (cmd- cmd) {\n\n        ...\n\n        case SET_THROTTLE:\n\n            sp_ThrottleRate = (int)(*(int*)( cmd- data) / 100.0  * (890 - 454) + 454);\n\n            break;\n\n        ...\n    }\n\n}  The throttle ends up being set to the value indicated in the  cmd.data  location. In addition, the last command read is stored and sent to the ground station as verification that the command was received.  The  popCommand() _function waits and reads the next available command from a circular buffer (note the _INBOUND_QUEUE_SIZE  variable). If the command doesn't exist, it exits the function.  In order for the command structure to exist, the  U2RXInterrupt  must have been triggered. This occurs when new data is sent.  void __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {\n\n    unsigned char data = U2RXREG;\n\n    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        IFS1bits.U2RXIF = 0;\n\n        return;\n\n    }\n\n    switch ( payloadPos ) {\n\n        case 0:\n\n            if ( data != START_DELIMITER ) {\n\n                IFS1bits.U2RXIF = 0;\n\n                return;\n\n            }\n\n            break;\n\n        case 1:\n\n            if ( data != 0 ) {\n\n                payloadPos = 0;\n\n                IFS1bits.U2RXIF = 0;\n\n                return;                 // packet length   100 bytes, so msb == 0\n\n            }\n\n            break;\n\n        case 2:\n\n            payloadLength[packetPos] = data;\n\n            break;\n\n        default:        // Normally, don't do anything special\n\n            break;\n\n    }\n\n    rawPackets[packetPos][payloadPos++] = data;\n\n    if ( payloadPos   payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet\n\n        rawPacketStatus[packetPos] = READY;\n\n        payloadPos = 0;\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        if ( rawPacketStatus[packetPos] == EMPTY ) {\n\n            rawPacketStatus[packetPos] = BUSY;\n\n        }\n\n    }\n\n    IFS1bits.U2RXIF = 0;\n\n}  The first thing that occurs when new data arrives is a check to see if there is enough memory to store the data. A  if statement  is used to check if the buffer (rawPacketStatus) is busy or not.  Note that the interrupt will only record the data, if the current  packetPos  marked busy.  If the buffer is full, the next buffer location is checked. Otherwise, the packet is parsed byte by byte.  Firstly, the start delimiter is looked for using a case statement. Until the start delimiter is found, nothing happens. Secondly, for case 1 and 2, the length of the packet is check and recorded. Once the length of the packet is known, the  data  is read into a 2d array called  rawPackets . This array contains each byte of every packet in the circular buffer. Once all the data is copied into the array, the packet is marked as  READY , and the next one is marked  BUSY  if it is  EMPTY , and the processing of the data begins on the next maintenance cycle when  inboundBufferMaintenance()  is called from  main.c :  void inboundBufferMaintenance(void) {\n\n    int i;\n\n    for ( i = 0; i   RAW_PACKET_BUFFER_SIZE; i++ ) {\n\n        if ( rawPacketStatus[i] == READY   checkPacket(rawPackets[i]) ) {\n\n            struct command\\* cmd = createCommand( rawPackets[i] );\n\n            if ( cmd ) {            // create command was successful ?\n\n                pushCommand( cmd ); // queue it up\n\n                rawPacketStatus[i] = EMPTY;         // buffer is now good for writing another packet\n\n            }\n\n        }\n\n    }\n\n    if ( rawPacketStatus[0] == EMPTY ) {\n\n        rawPacketStatus[0] = BUSY;\n\n    }\n\n}  This subroutine iterates through each buffer location and checks for any  READY  packets. If one is found, and it has been verified through a checksum, the command structure is created from the data using the  createCommand(rawPackets[i])  method. Once this is done, the previous spot is marked  EMPTY . The first buffer is always primed if it is empty.", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/analog-to-digital-converter/", 
            "text": "Analog to Digital Converter\n\n\nThe Analog to Digital Converter (ADC) on the PICpilot is used for a single purpose, which to monitor and report the battery life remaining for the vehicle and/or the autopilot. The path managing chip is responsible for measuring the battery voltage. Based on the reference voltage, a percentage is determined which indicates the voltage measured in relationship to the reference voltage. This data is transmitted to the attitude manager chip and then it is transmitted wirelessly along with the telemetry data.\n\n\nThe functionality of the ADC is fairly straightforward. The ADC module switches between two states. One of which is the sampling period, whereas the other is the conversion period. During the conversion period, no sampling is performed. Instead, the previously captured data is converted into a 12 bit number. Therefore, in order to attain the voltage percent, you simply divide the data by 4096, the largest possible 12 bit number.\n\n\nIn the PICpilot, the ADC module is triggered through interrupts (although it can also be manually polled).\n\n\nIn the code\n\n\nAll the code for the voltage sensor is available in the \nvoltageSensor.c\n and \n.h\n files. The code which controls the ADC module is extremely straight forward. The process mostly involves initializations. Most of the \"magic\" is handled automatically by the module, therefore minimal logical coding is required. A few of the important lines have been included below:\n\n\nAD1CON1bits.FORM = 0;                // Data Output Format: Unsigned Int\n\nAD1CON1bits.SSRC = 7;                // Internal Counter (SAMC) ends sampling and starts conversion\n\nAD1CON1bits.AD12B = 1;                // 12-bit single channel operation\n\nAD1CON1bits.SAMP = 1;\n\nAD1CON2bits.SMPI=0;                        // Interrupt address every sample/conversion\n\nAD1CON2bits.CHPS = 0;                //We are using channel 0\n\nAD1CON2bits.VCFG = 0;                 //Voltage Reference is 3.3V and Ground Reference is Ground\n\nAD1CON3bits.SAMC=0;                         // Auto Sample Time = 0\\*Tad\n\nAD1CON3bits.ADCS=6;                        // ADC Conversion Clock Tad=Tcy\\*(ADCS+1)= (1/40M)\\*7 = 175nS\n\n\n\nAD1CHS0bits.CH0SA = 0xC;                 //Channel 0 positive input on AN12 (Sample A)\n\nAD1CHS0bits.CH0SB = 0xC;                 //Channel 0 positive input on AN12 (Sample B)\n\nIFS0bits.AD1IF = 0;                        // Clear the A/D interrupt flag bit\n\nIEC0bits.AD1IE = 1;                        // Enable A/D interrupt\n\nAD1CON1bits.ADON = 1;                // Turn on the A/D converter\n\n\n\nAfter each interrupt, the battery voltage is updated into the \ncurrentSignal\n variable. When the battery voltage is requested, this integer is multiplied by 100 and divided by 4096 to get a percentage (4096 is 12 bits of data).", 
            "title": "Analog to Digital Converter"
        }, 
        {
            "location": "/picpilot/analog-to-digital-converter/#analog-to-digital-converter", 
            "text": "The Analog to Digital Converter (ADC) on the PICpilot is used for a single purpose, which to monitor and report the battery life remaining for the vehicle and/or the autopilot. The path managing chip is responsible for measuring the battery voltage. Based on the reference voltage, a percentage is determined which indicates the voltage measured in relationship to the reference voltage. This data is transmitted to the attitude manager chip and then it is transmitted wirelessly along with the telemetry data.  The functionality of the ADC is fairly straightforward. The ADC module switches between two states. One of which is the sampling period, whereas the other is the conversion period. During the conversion period, no sampling is performed. Instead, the previously captured data is converted into a 12 bit number. Therefore, in order to attain the voltage percent, you simply divide the data by 4096, the largest possible 12 bit number.  In the PICpilot, the ADC module is triggered through interrupts (although it can also be manually polled).", 
            "title": "Analog to Digital Converter"
        }, 
        {
            "location": "/picpilot/analog-to-digital-converter/#in-the-code", 
            "text": "All the code for the voltage sensor is available in the  voltageSensor.c  and  .h  files. The code which controls the ADC module is extremely straight forward. The process mostly involves initializations. Most of the \"magic\" is handled automatically by the module, therefore minimal logical coding is required. A few of the important lines have been included below:  AD1CON1bits.FORM = 0;                // Data Output Format: Unsigned Int\n\nAD1CON1bits.SSRC = 7;                // Internal Counter (SAMC) ends sampling and starts conversion\n\nAD1CON1bits.AD12B = 1;                // 12-bit single channel operation\n\nAD1CON1bits.SAMP = 1;\n\nAD1CON2bits.SMPI=0;                        // Interrupt address every sample/conversion\n\nAD1CON2bits.CHPS = 0;                //We are using channel 0\n\nAD1CON2bits.VCFG = 0;                 //Voltage Reference is 3.3V and Ground Reference is Ground\n\nAD1CON3bits.SAMC=0;                         // Auto Sample Time = 0\\*Tad\n\nAD1CON3bits.ADCS=6;                        // ADC Conversion Clock Tad=Tcy\\*(ADCS+1)= (1/40M)\\*7 = 175nS\n\n\n\nAD1CHS0bits.CH0SA = 0xC;                 //Channel 0 positive input on AN12 (Sample A)\n\nAD1CHS0bits.CH0SB = 0xC;                 //Channel 0 positive input on AN12 (Sample B)\n\nIFS0bits.AD1IF = 0;                        // Clear the A/D interrupt flag bit\n\nIEC0bits.AD1IE = 1;                        // Enable A/D interrupt\n\nAD1CON1bits.ADON = 1;                // Turn on the A/D converter  After each interrupt, the battery voltage is updated into the  currentSignal  variable. When the battery voltage is requested, this integer is multiplied by 100 and divided by 4096 to get a percentage (4096 is 12 bits of data).", 
            "title": "In the code"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/", 
            "text": "Sensors and Peripherals\n\n\nThere are multiple devices and peripherals currently in use on the PICpilot, however, the purpose of this document is not to document their functionality. Instead, appropriate references are listed below.\n\n\nGPS (MEDIATEK-3329)\n\n\nThis GPS module outputs data in the form of NMEA strings. These are ASCI strings with GPS relevant data embedded in them. A separate program is used to convert these strings to a useable format. The PICpilot expects the data to be in the form of a structure:\n\n\ntypedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;\n\n\n\nLatitude\n and \nLongitude\n should be in degrees.\n\n\nTime\n should be in 24 hour time, with the decimal portion indicating milliseconds.\n\n\nSpeed\n should be in m/s.\n\n\nAltitude\n should be in m.\n\n\nHeading\n should be in degrees (geographical heading, not magnetic).\n\n\nSatellites\n is the number of connected satellites.\n\n\nPositionFix\n is a number representing the accuracy of the data (0 = no data, 1 = GPS functional, 2 = DGPS functional)\n\n\nIn the current PICpilot, GPS updates occur 10 times a second.\n\n\nThe data sheets can be retrieved from here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JQXVOR093anI0YXc/view?usp=sharing\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JR2xTV3dCcGJWczQ/view?usp=sharing\n\n\nIMU (VN-100/VectorNav-100)\n\n\nThe VectorNav-100 has a Kalman filter implemented within it. All the registers and commands that can be executed on the oldest VectorNav are available in four files within the PICpilot code. This includes the VN100.c/.h files, the VN_user.c/.h files, the VN_lib.c/.h, and the VN_math.c/.h files.\n\n\nI GET IT that was 8 files, not four....moving on...\n\n\nYou will find the SPI initialization function in the VN100.c file. It initializes the SPI2 interface.\n\n\nIn the PICpilot, the two most commonly called functions are \nVN100_SPI_GetYPR()\n and \nVN100_SPI_GetRates()\n. These two functions get the rate and angles of rotation along the yaw, pitch, and roll axis of the vehicle.\n\n\nFor a complete list of functions and settings take a look at the documentation:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JYXlSdW85NnlxYkE/view?usp=sharing\n\n\nAltimeter (MPL3115A2)\n\n\nThe complete functionality of the altimeter can be found in the MPL3115A2.c/.h files.\n\n\nThere are only 3 functions implemented in the code. An initialization, calibration, and sensor read function.\n\n\nTo see the complete list of functions provided by the altimeter, as well as further details see the documentation here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JeUE4Y3BhQzVMdkk/view?usp=sharing\n\n\nWireless Link - XBEE PRO S3B\n\n\nThe XBEE PRO S3B is currently the wireless interface used with the PICpilot. Nonetheless, many wireless links can be easily substituted with minimal coding as long as a UART interface is supported.\n\n\nThe PICpilot currently only supports this model currently. This wireless link uses the 900MHz spectrum for communication between devices.\n\n\nAccording to the packet structure specification in the datasheet below, the data is sent or received in that manner.\n\n\nFor details on other functions and feature that are part of the XBEE PRO S3B module download the documentation here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JNzdLWXdCWHlEcGs/view?usp=sharing\n\n\nThe above link also includes details on the packet structure. See page 62 for the Tx packet structure. See page 70 for the Rx packet structure.\n\n\nThe configuration options for the base station can be found here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JTXZESmFEMG9uZEk/view?usp=sharing\n\n\nThe configuration options for the aircraft module can be found here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4Jdml6Wlg5UFZKWEE/view?usp=sharing\n\n\nRC Receiver (EzUHF)\n\n\nThe exact model of the RC Receiver is insignificant to the functionality of the PICpilot. However, the PICpilot has 8 PWM inputs and 8 PWM outputs. Therefore, it would be prudent to have a RC Receiver capable of managing 8 channels.\n\n\nThe current receiver uses the 431-437MHz spectrum.\n\n\nThe documentation can be found here:\n\n\nhttp://www.immersionrc.com/downloads/manuals/EzUHFManual_EN_v1.0.pdf\n\n\nAirspeed Sensor (WIP)\n\n\nThis has not been implemented yet.\n\n\nUltrasonic Sensor (WIP)\n\n\nThis has not been implemented yet.", 
            "title": "Sensors and Peripherals"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#sensors-and-peripherals", 
            "text": "There are multiple devices and peripherals currently in use on the PICpilot, however, the purpose of this document is not to document their functionality. Instead, appropriate references are listed below.", 
            "title": "Sensors and Peripherals"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#gps-mediatek-3329", 
            "text": "This GPS module outputs data in the form of NMEA strings. These are ASCI strings with GPS relevant data embedded in them. A separate program is used to convert these strings to a useable format. The PICpilot expects the data to be in the form of a structure:  typedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;  Latitude  and  Longitude  should be in degrees.  Time  should be in 24 hour time, with the decimal portion indicating milliseconds.  Speed  should be in m/s.  Altitude  should be in m.  Heading  should be in degrees (geographical heading, not magnetic).  Satellites  is the number of connected satellites.  PositionFix  is a number representing the accuracy of the data (0 = no data, 1 = GPS functional, 2 = DGPS functional)  In the current PICpilot, GPS updates occur 10 times a second.  The data sheets can be retrieved from here:  https://drive.google.com/file/d/0BySpWXvmBM4JQXVOR093anI0YXc/view?usp=sharing  https://drive.google.com/file/d/0BySpWXvmBM4JR2xTV3dCcGJWczQ/view?usp=sharing", 
            "title": "GPS (MEDIATEK-3329)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#imu-vn-100vectornav-100", 
            "text": "The VectorNav-100 has a Kalman filter implemented within it. All the registers and commands that can be executed on the oldest VectorNav are available in four files within the PICpilot code. This includes the VN100.c/.h files, the VN_user.c/.h files, the VN_lib.c/.h, and the VN_math.c/.h files.  I GET IT that was 8 files, not four....moving on...  You will find the SPI initialization function in the VN100.c file. It initializes the SPI2 interface.  In the PICpilot, the two most commonly called functions are  VN100_SPI_GetYPR()  and  VN100_SPI_GetRates() . These two functions get the rate and angles of rotation along the yaw, pitch, and roll axis of the vehicle.  For a complete list of functions and settings take a look at the documentation:  https://drive.google.com/file/d/0BySpWXvmBM4JYXlSdW85NnlxYkE/view?usp=sharing", 
            "title": "IMU (VN-100/VectorNav-100)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#altimeter-mpl3115a2", 
            "text": "The complete functionality of the altimeter can be found in the MPL3115A2.c/.h files.  There are only 3 functions implemented in the code. An initialization, calibration, and sensor read function.  To see the complete list of functions provided by the altimeter, as well as further details see the documentation here:  https://drive.google.com/file/d/0BySpWXvmBM4JeUE4Y3BhQzVMdkk/view?usp=sharing", 
            "title": "Altimeter (MPL3115A2)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#wireless-link-xbee-pro-s3b", 
            "text": "The XBEE PRO S3B is currently the wireless interface used with the PICpilot. Nonetheless, many wireless links can be easily substituted with minimal coding as long as a UART interface is supported.  The PICpilot currently only supports this model currently. This wireless link uses the 900MHz spectrum for communication between devices.  According to the packet structure specification in the datasheet below, the data is sent or received in that manner.  For details on other functions and feature that are part of the XBEE PRO S3B module download the documentation here:  https://drive.google.com/file/d/0BySpWXvmBM4JNzdLWXdCWHlEcGs/view?usp=sharing  The above link also includes details on the packet structure. See page 62 for the Tx packet structure. See page 70 for the Rx packet structure.  The configuration options for the base station can be found here:  https://drive.google.com/file/d/0BySpWXvmBM4JTXZESmFEMG9uZEk/view?usp=sharing  The configuration options for the aircraft module can be found here:  https://drive.google.com/file/d/0BySpWXvmBM4Jdml6Wlg5UFZKWEE/view?usp=sharing", 
            "title": "Wireless Link - XBEE PRO S3B"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#rc-receiver-ezuhf", 
            "text": "The exact model of the RC Receiver is insignificant to the functionality of the PICpilot. However, the PICpilot has 8 PWM inputs and 8 PWM outputs. Therefore, it would be prudent to have a RC Receiver capable of managing 8 channels.  The current receiver uses the 431-437MHz spectrum.  The documentation can be found here:  http://www.immersionrc.com/downloads/manuals/EzUHFManual_EN_v1.0.pdf", 
            "title": "RC Receiver (EzUHF)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#airspeed-sensor-wip", 
            "text": "This has not been implemented yet.", 
            "title": "Airspeed Sensor (WIP)"
        }, 
        {
            "location": "/picpilot/sensors-and-peripherals/#ultrasonic-sensor-wip", 
            "text": "This has not been implemented yet.", 
            "title": "Ultrasonic Sensor (WIP)"
        }, 
        {
            "location": "/picpilot/attitude-control/", 
            "text": "Attitude Control\n\n\nAttitude Control is very similar regardless of the aircraft which is being used. The end goal is to be able to keep the aircraft stable and in control. The way in which this is achieved is always very similar.\n\n\nIn the PICpilot, we use PID loops to manage our system. Although there are other types of controllers available, PID controllers are the best option due to their reliability, accuracy, and simplicity. The section on PID loops has a detailed explanation of how they work, and how they work together.\n\n\nThis section mostly deals with the \nAttitudeManager.c\n file, as the name implies.\n\n\nThe attitude manager has the 3 main goals, as well as a side task. The 3 main goals include the aggregation of status data (inputs, sensors, etc.), error analysis on the status of the aircraft, and corrections to the aircraft. The side task involves sending all this data to the ground station, as well as receiving from the ground station.\n\n\nInitialization\n\n\nThe initialization process involves beginning communication with all components. The process involves the following steps:\n\n\n\n\nInitializing communication to the Path Manager via SPI and DMA\n\n\nVN 100 is initialized\n\n\nVN 100 is offset according to a rotation matrix\n\n\nVN 100 is then calibrated with confidence parameters for the X/Y/Z magnetometers, accelerometers, and gyroscopes\n\n\nPWM input and output is specified according to the used channels\n\n\n\n\nThis can be found in the \nattitudeInit()\n function in the \nAttitudeManager.c\n file.\n\n\nAggregation of Data\n\n\nUsing the initialized sensors from the prior section, the vehicle can now collect data systematically.\n\n\nEvery loop, new data is acquired from the DMA/SPI interface connected to the Path Manager chip. Data acquired from this chip includes the time, heading, speed, longitude, latitude, altitude, number of satellites, position fix, battery level, waypoint index, set point altitude, and set point heading.\n\n\nNext, data is acquired from the PWM inputs. This includes stick positions, which determine the roll, pitch, yaw, and throttle of the aircraft. These inputs are scaled to values ranging from -1024 to 1024.\n\n\nFinally, the VectorNav is polled for the latest rotational data. The roll, pitch, and yaw rate data is acquired through the \nVN100_SPI_GetRates(0, (float*) \nimuData)\n function call. The roll, pitch, and yaw angles can be determined via the \nVN100_SPI_GetYPR(0, \nimuData[YAW], \nimuData[PITCH], \nimuData[ROLL])\n function call.\n\n\nThis concludes all data acquisition. The next step involves analyzing the error.\n\n\nError Analysis (PID control)\n\n\nPID control works on the basis of minimizing error. The majority of the attitude manager involves consecutive PID loops correcting specific portions of flying an aircraft.\n\n\nAll the PID loop code can be found in the \nOrientationControl.c\n file. It is called from the AttitudeManager.c code.\n\n\nAltitude\n\n\nThe altitude is controlled through a standard PID loop. This can be found in the code:\n\n\n    sp_PitchAngle = controlSignalAltitude(sp_Altitude,(int)gps_Altitude);\n\n    if (sp_PitchAngle \n MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = MAX_PITCH_ANGLE;\n\n    if (sp_PitchAngle \n -MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = -MAX_PITCH_ANGLE;\n\n\n\nLogically, the pitch angle is determined from the desired altitude. If the plane is too low, the pitch angle will be positive (up). If the plane is too high, the pitch angle will be negative (down). The pitch angle is then checked to be within \"safety limits\".\n\n\nThrottle\n\n\nLike the altitude PID loop, the throttle also has PID loop, which is also based on the altitude:\n\n\n    control_Throttle = sp_ThrottleRate + controlSignalThrottle(sp_Altitude, (int)gps_Altitude);\n\n    if (control_Throttle \n MAX_PWM){\n\n        control_Throttle = MAX_PWM;\n\n    }\n\n    else if (control_Throttle \n MIN_PWM){\n\n        control_Throttle = MIN_PWM;\n\n    }\n\n\n\nLogically, if the plane needs to climb, you need to increase the throttle (otherwise it will stall due to low airspeed). Likewise, if the plane needs to reduce its altitude, to prevent high airspeeds, the plane decreases the throttle. If the plane is perfectly positioned, a constant throttle is maintained as per the \nsp_ThrottleRate\n variable. Once again, the throttle is limited within the legal limits of the throttle (to ensure the throttle doesn't become negative or larger than 100%).\n\n\nHeading\n\n\nThe heading control code looks as such:\n\n\n    while (sp_Heading \n 360)\n\n        sp_Heading -=360;\n\n    while (sp_Heading \n 0)\n\n        sp_Heading +=360;\n\n        sp_HeadingRate = controlSignalHeading(sp_Heading, gps_PositionFix==2?gps_Heading:(int)imu_YawAngle);\n\n        //Approximating Roll angle from Heading\n\n        sp_RollAngle = sp_HeadingRate;//(int)(atan((float)(sp_HeadingRate)) * PI/180.0);\n\n    if (sp_RollAngle \n MAX_ROLL_ANGLE)\n\n        sp_RollAngle = MAX_ROLL_ANGLE;\n\n    if (sp_RollAngle \n -MAX_ROLL_ANGLE)\n\n        sp_RollAngle = -MAX_ROLL_ANGLE;\n\n\n\nAs you can see, the input is the heading and the resulting output is a roll angle. In other words, if there is a greater error in the heading, a larger roll angle is established to correct for the heading error.\n\n\nThe first two while loops take into account any angle overflow or underflow, in other words, if the value is above 360 or negative, it is scaled to be between 0 and 360.\n\n\nOnce again the roll value is limited to a reasonable value, to prevent excessive maneuvers.\n\n\nAngles\n\n\nThe code to maintain the angular roll and pitch of the aircraft look as such (one statement for each):\n\n\nsp_ComputedRollRate = controlSignalAngles(sp_RollAngle,  imu_RollAngle, ROLL, -(SP_RANGE) / (MAX_ROLL_ANGLE));\n\n\n\nNote that depending on the on the input angles, the output is a \"rate\". It is an angular rate. In other words, if the difference between the setpoint and the output is large, the angular rate will also be large.\n\n\nAngular Rate\n\n\nThe result from the angular PID loop gives rise to the angular rate PID loop. This loop is often acknowledged as a stabilizing system, where small quick vibrations are accounted for.\n\n\ncontrol_Roll = controlSignal((sp_ComputedRollRate / SERVO_SCALE_FACTOR), imu_RollRate, ROLL);\n\n\n\nThe output of this function completes the PID pipeline. The value of \ncontrol_Roll\n, or the equivalent variable for the pitch for that matter, is then directly applied to the PWM module, in order to create a correction to the system (using the flaps, elevators, rudder, or what not).\n\n\nOutput Corrections\n\n\nOnce the calculations have been made to determine what corrections should be made to the system, it is then time to physically alter the system based on the calculations.\n\n\nThis involves output to the PWM module. After a series of checks, to ensure that all values are within the maximum and minimum parameters for the PWM signal, a PWM call is made to the appropriate channel:\n\n\nsetPWM(1, control_Roll + rollTrim);\n\n\n\nAs long as the PWM module was initialized, there shouldn't be any problem. The vehicle should move its servos appropriately.\n\n\nControl Levels\n\n\nThe control levels implemented in the attitude manager are an important part of the testing process. These levels determine which input sources have primary control over the aircraft, as well as how the input translates into flight.\n\n\nFor instance, when testing, one may wish to have control of the throttle, while the roll and pitch is controlled by the autopilot. Such control is implemented in the code.\n\n\nAs it is evident above, there a separate sections of code, which control individual PID loops. The control levels change the source of the input to the PIDs using a simple bit mask. The control level is actually determined by a single integer. Each value of the integer represents a different \ncontrol level.\n As a result, a bit mask is placed within an, if statement to determine whether or not a specific element of control is enabled or disabled.\n\n\nFor instance, take this scenario:\n\n\nif ((controlLevel \n ROLL_CONTROL_SOURCE) == 0 \n (controlLevel \n HEADING_CONTROL_ON) == 0)\n\n    sp_RollAngle = (int)((-sp_RollRate / ((float)SP\\_RANGE / MAX_ROLL_ANGLE) ));\n\n\n\nThis snippet of code, converts the controller input into a roll angle. For instance, if the stick is centered, the plane will be at a 0\u00b0 roll angle. If the pilot steers left, the plane will angle itself left at that same angle. The \nif\n statement contains two bit masks. Note that the \ncontrolLevel\n variable has a \nbitwise AND \n(\n) applied to it.\n\n\nTherefore, if the controlLevel is (in binary):\n\n\n0b00000000 00010011\n\n\nThe code above will run, because a \nAND\n bit mask of 0b00001000, will return a value of zero, just as well as 0b00000010 00000000 will also return a logical value of zero.\n\n\nThis type of logic is applied to multiple sections of the attitude manager code.", 
            "title": "Attitude Control"
        }, 
        {
            "location": "/picpilot/attitude-control/#attitude-control", 
            "text": "Attitude Control is very similar regardless of the aircraft which is being used. The end goal is to be able to keep the aircraft stable and in control. The way in which this is achieved is always very similar.  In the PICpilot, we use PID loops to manage our system. Although there are other types of controllers available, PID controllers are the best option due to their reliability, accuracy, and simplicity. The section on PID loops has a detailed explanation of how they work, and how they work together.  This section mostly deals with the  AttitudeManager.c  file, as the name implies.  The attitude manager has the 3 main goals, as well as a side task. The 3 main goals include the aggregation of status data (inputs, sensors, etc.), error analysis on the status of the aircraft, and corrections to the aircraft. The side task involves sending all this data to the ground station, as well as receiving from the ground station.", 
            "title": "Attitude Control"
        }, 
        {
            "location": "/picpilot/attitude-control/#initialization", 
            "text": "The initialization process involves beginning communication with all components. The process involves the following steps:   Initializing communication to the Path Manager via SPI and DMA  VN 100 is initialized  VN 100 is offset according to a rotation matrix  VN 100 is then calibrated with confidence parameters for the X/Y/Z magnetometers, accelerometers, and gyroscopes  PWM input and output is specified according to the used channels   This can be found in the  attitudeInit()  function in the  AttitudeManager.c  file.", 
            "title": "Initialization"
        }, 
        {
            "location": "/picpilot/attitude-control/#aggregation-of-data", 
            "text": "Using the initialized sensors from the prior section, the vehicle can now collect data systematically.  Every loop, new data is acquired from the DMA/SPI interface connected to the Path Manager chip. Data acquired from this chip includes the time, heading, speed, longitude, latitude, altitude, number of satellites, position fix, battery level, waypoint index, set point altitude, and set point heading.  Next, data is acquired from the PWM inputs. This includes stick positions, which determine the roll, pitch, yaw, and throttle of the aircraft. These inputs are scaled to values ranging from -1024 to 1024.  Finally, the VectorNav is polled for the latest rotational data. The roll, pitch, and yaw rate data is acquired through the  VN100_SPI_GetRates(0, (float*)  imuData)  function call. The roll, pitch, and yaw angles can be determined via the  VN100_SPI_GetYPR(0,  imuData[YAW],  imuData[PITCH],  imuData[ROLL])  function call.  This concludes all data acquisition. The next step involves analyzing the error.", 
            "title": "Aggregation of Data"
        }, 
        {
            "location": "/picpilot/attitude-control/#error-analysis-pid-control", 
            "text": "PID control works on the basis of minimizing error. The majority of the attitude manager involves consecutive PID loops correcting specific portions of flying an aircraft.  All the PID loop code can be found in the  OrientationControl.c  file. It is called from the AttitudeManager.c code.  Altitude  The altitude is controlled through a standard PID loop. This can be found in the code:      sp_PitchAngle = controlSignalAltitude(sp_Altitude,(int)gps_Altitude);\n\n    if (sp_PitchAngle   MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = MAX_PITCH_ANGLE;\n\n    if (sp_PitchAngle   -MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = -MAX_PITCH_ANGLE;  Logically, the pitch angle is determined from the desired altitude. If the plane is too low, the pitch angle will be positive (up). If the plane is too high, the pitch angle will be negative (down). The pitch angle is then checked to be within \"safety limits\".  Throttle  Like the altitude PID loop, the throttle also has PID loop, which is also based on the altitude:      control_Throttle = sp_ThrottleRate + controlSignalThrottle(sp_Altitude, (int)gps_Altitude);\n\n    if (control_Throttle   MAX_PWM){\n\n        control_Throttle = MAX_PWM;\n\n    }\n\n    else if (control_Throttle   MIN_PWM){\n\n        control_Throttle = MIN_PWM;\n\n    }  Logically, if the plane needs to climb, you need to increase the throttle (otherwise it will stall due to low airspeed). Likewise, if the plane needs to reduce its altitude, to prevent high airspeeds, the plane decreases the throttle. If the plane is perfectly positioned, a constant throttle is maintained as per the  sp_ThrottleRate  variable. Once again, the throttle is limited within the legal limits of the throttle (to ensure the throttle doesn't become negative or larger than 100%).  Heading  The heading control code looks as such:      while (sp_Heading   360)\n\n        sp_Heading -=360;\n\n    while (sp_Heading   0)\n\n        sp_Heading +=360;\n\n        sp_HeadingRate = controlSignalHeading(sp_Heading, gps_PositionFix==2?gps_Heading:(int)imu_YawAngle);\n\n        //Approximating Roll angle from Heading\n\n        sp_RollAngle = sp_HeadingRate;//(int)(atan((float)(sp_HeadingRate)) * PI/180.0);\n\n    if (sp_RollAngle   MAX_ROLL_ANGLE)\n\n        sp_RollAngle = MAX_ROLL_ANGLE;\n\n    if (sp_RollAngle   -MAX_ROLL_ANGLE)\n\n        sp_RollAngle = -MAX_ROLL_ANGLE;  As you can see, the input is the heading and the resulting output is a roll angle. In other words, if there is a greater error in the heading, a larger roll angle is established to correct for the heading error.  The first two while loops take into account any angle overflow or underflow, in other words, if the value is above 360 or negative, it is scaled to be between 0 and 360.  Once again the roll value is limited to a reasonable value, to prevent excessive maneuvers.  Angles  The code to maintain the angular roll and pitch of the aircraft look as such (one statement for each):  sp_ComputedRollRate = controlSignalAngles(sp_RollAngle,  imu_RollAngle, ROLL, -(SP_RANGE) / (MAX_ROLL_ANGLE));  Note that depending on the on the input angles, the output is a \"rate\". It is an angular rate. In other words, if the difference between the setpoint and the output is large, the angular rate will also be large.  Angular Rate  The result from the angular PID loop gives rise to the angular rate PID loop. This loop is often acknowledged as a stabilizing system, where small quick vibrations are accounted for.  control_Roll = controlSignal((sp_ComputedRollRate / SERVO_SCALE_FACTOR), imu_RollRate, ROLL);  The output of this function completes the PID pipeline. The value of  control_Roll , or the equivalent variable for the pitch for that matter, is then directly applied to the PWM module, in order to create a correction to the system (using the flaps, elevators, rudder, or what not).", 
            "title": "Error Analysis (PID control)"
        }, 
        {
            "location": "/picpilot/attitude-control/#output-corrections", 
            "text": "Once the calculations have been made to determine what corrections should be made to the system, it is then time to physically alter the system based on the calculations.  This involves output to the PWM module. After a series of checks, to ensure that all values are within the maximum and minimum parameters for the PWM signal, a PWM call is made to the appropriate channel:  setPWM(1, control_Roll + rollTrim);  As long as the PWM module was initialized, there shouldn't be any problem. The vehicle should move its servos appropriately.", 
            "title": "Output Corrections"
        }, 
        {
            "location": "/picpilot/attitude-control/#control-levels", 
            "text": "The control levels implemented in the attitude manager are an important part of the testing process. These levels determine which input sources have primary control over the aircraft, as well as how the input translates into flight.  For instance, when testing, one may wish to have control of the throttle, while the roll and pitch is controlled by the autopilot. Such control is implemented in the code.  As it is evident above, there a separate sections of code, which control individual PID loops. The control levels change the source of the input to the PIDs using a simple bit mask. The control level is actually determined by a single integer. Each value of the integer represents a different  control level.  As a result, a bit mask is placed within an, if statement to determine whether or not a specific element of control is enabled or disabled.  For instance, take this scenario:  if ((controlLevel   ROLL_CONTROL_SOURCE) == 0   (controlLevel   HEADING_CONTROL_ON) == 0)\n\n    sp_RollAngle = (int)((-sp_RollRate / ((float)SP\\_RANGE / MAX_ROLL_ANGLE) ));  This snippet of code, converts the controller input into a roll angle. For instance, if the stick is centered, the plane will be at a 0\u00b0 roll angle. If the pilot steers left, the plane will angle itself left at that same angle. The  if  statement contains two bit masks. Note that the  controlLevel  variable has a  bitwise AND  ( ) applied to it.  Therefore, if the controlLevel is (in binary):  0b00000000 00010011  The code above will run, because a  AND  bit mask of 0b00001000, will return a value of zero, just as well as 0b00000010 00000000 will also return a logical value of zero.  This type of logic is applied to multiple sections of the attitude manager code.", 
            "title": "Control Levels"
        }, 
        {
            "location": "/picpilot/path-management/", 
            "text": "Path Management\n\n\nPath management can be broken up into 3 sections. The straight parts, the parts where you turn, and the way you put them together. There is not much more to it than that.\n\n\nStraight Line Path Following\n\n\nStraight line path following, also known as, following a line, is the most rudimentary part of any unmanned system. It is mostly a mathematical construct applied to a digital system. The mathematics will be described here, which can be easily compared to the code.\n\n\nThe principle is simple. Given two points, and the location of your vehicle, determine what heading it should follow. Now imagine the plane is directly on the path. The heading would follow the line exactly. Now imagine the plane is slightly off the path. What should happen is that the plane should face slightly towards the path, to minimize its \ncross-track error\n. Now imagine the plane is an infinite distance away. The plane should head at a heading perpendicular to the line, in order to regain distance. This is the premise of the straight line path following algorithm. As a result, a heading vector field would look as such:\n\n\n\n\nThe equations that govern this behaviour are not complicated. There are only a few things required to make this calculation. Firstly, you must know the heading of the path. If you have the XY coordinates of the path endpoints, you can easily determine that through simple trigonometry. If you only have the GPS coordinates, you should use the \nHaversine Formula\n in order to get the XY coordinates.\n\n\nOnce you have the coordinates, subtracting them will give you the direction of travel (in an XY plane). Furthermore, by applying the \narctan\n function on the direction of travel, one will determine the path heading. In addition, the value should be between \u2013PI and +PI. Thus, any 2PI corrections that need to be made can be made at this point.\n\n\nNow the path error (or cross-track error) is calculated. This is calculated as:\n\n\ncos(courseAngle) * (positionY - targetWaypointY) \u2013 sin(courseAngle)*(positionX \u2013 targetWaypointX)\n\n\n\nOn a map, the _cross-track error _looks like this:\n\n\n\n\nUsing trigonometry you can easily derive the formula (as above) for cross-track error to encompass any situation.\n\n\nThe cross track error is then useful to determine the heading of the aircraft. Once again, using the \narctan\n function is suitable to do so:\n\n\n\n\n90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError))\n\n\n\nNote, as the atan term increases, the heading approaches the \n(courseAngle -__MAX_PATH_APPROACH_ANGLE)\n.\n\n\nNote, that the courseAngle is calculated with respect to the x-axis, on the x-y plane. In other words, a path going from West to East would have a courseAngle of 0 degrees. This would be 90 degrees in terms of a true heading. Therefore, to get the true heading, you must subtract the \ncourseAngle\n from 90 degrees.\n\n\nOrbit Following\n\n\nUnlike straight line path following, orbit following involves following a curve of a certain radius. An orbit is depicted by a radius, a center location, and the direction of travel (clockwise or anti-clockwise).\n\n\n\n\nIn order to maintain a certain radius, the Euclidean distance needs to be calculated between the center of the orbit and the plane itself. The goal of this function is to maintain this Euclidean distance constant. The Euclidean distance can be calculated as such:\n\n\nfloat orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));\n\n\n\nThis value is then used to determine the equivalent of \ncross-track _error, but for an orbit. This is done very easily. The term _d\n (Euclidean distance) subtracted by the \n\u03c1\n (desired radius) provides the relative error, which must be minimized.\n\n\n\n\n90 - rad2deg(courseAngle + direction \\* (PI/2 + atan(k\\_gain[ORBIT] \\* (orbitDistance - radius)/radius)))\n\n\n\nThis equation is actually very similar to the equation governing straight line path following. The \narctan\n function forces the heading to converge onto the orbit. The direction of travel (\n\u03bb\n) which can be either \n1\n or \n-1\n, reverses the effect of the heading perturbations. This is then added onto the course angle as a perturbation. Once again, a gain value needs to be tuned to determine the rate of convergence.\n\n\nThe course angle can be determined easily based on the location of the curve. For instance, if the vehicle is in the first quadrant of the circle/orbit, the heading will range between 270\u00b0 and 0\u00b0, assuming a counter-clockwise rotation. This course angle can be calculated using this equation:\n\n\nfloat courseAngle = atan2(position[1] - center[1], position[0] - center[0]);\n\n\n\nPutting it all together\n\n\nThe orbit following and straight path following algorithms are used in combination in order to assemble a path. Both algorithms alternate in usage. Every corner uses the orbit following algorithm. Every straight line uses the straight path following algorithm.\n\n\nIn order to put the two together, you must draw in orbits between each set of points. The additional restriction is that they must be tangent to both lines, as depicted in this diagram:\n\n\n\n\nFiguring out where the tangent will touch requires some basic trigonometry. The derivation won't be explained here, however, the coordinates at which this occurs can be calculated using:\n\n\n\n\nWhere nextX/Y/Z refer to the coordinates of the point Wi+1 and targetX/Y/Z refer to the coordinates of the point Wi.\n\n\nThe turning angle can be calculated via the following equation:\n\n\nfloat turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));\n\n\n\nThis is simply the dot product of the (Wi - Wi-1) vector and the (Wi+1 - Wi) vector. Given the dot product formula, you can use the \narccos\n function to determine the angle between the two lines.\n\n\nAt these calculated points, there is a checkpoint. Imagine a giant plane perpendicular to the path. As soon as the plane crosses this boundary, the next step is executed. For instance, if the vehicle is travelling straight along a path, then passes the plane, it will initiate a turn (orbiting algorithm). Once it passes the next plane, it will initiate the straight line path following algorithm once again.\n\n\nIn order to detect if a vehicle passes the boundary, the dot product of two vectors must be taken. If the value is positive, it is an indicator that the vehicle has crossed the boundary.\n\n\nThe dot product is:\n\n\n\n\nBoth vectors have X, Y, and Z components. Likewise, equations that depict the half plane are stated above.\n\n\nNote that in the code, all \"direction vectors\" such as Wi \u2013 Wi-1 are normalized.\n\n\nFor every pair of \"checkpoints\" the path index is incremented once they are passed. The index is used to identify the data in a linked list through the wireless communications.\n\n\nManaging Path Data\n\n\nPath data is stored in a structure, which contains all necessary information for a single path (line) segment. The construct looks as follows:\n\n\ntypedef struct _PathData{\n\n    struct _PathData* next;\n\n    struct _PathData* previous;\n\n    long double longitude;  //TODO: Longitude and Latitude is bulky. Use cartesian 2D approximations\n\n    long double latitude;\n\n    float altitude;\n\n    float radius; //Radius of turn\n\n    char id;    //Array ID\n\n    char index;\n\n} PathData;\n\n\n\nThis structure is a doubly linked list element. It links to the previous node and the next node. This makes it easy to traverse from one element to another. As a result, it is easy to add, insert, delete, and clear all waypoint nodes.\n\n\nThe included functions are:\n\n\nPathData* initializePathNode(void);\n\nunsigned int destroyPathNode(PathData* node);\n\nPathData* initializePathNodeAndNext(void);\n\nunsigned int appendPathNode(PathData* node);\n\nunsigned int removePathNode(unsigned int ID);\n\nvoid clearPathNodes(void);\n\nunsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID);\n\n\n\nThese functions are all executed in the _checkAMData() _function. This function polls input over the DMA/SPI bus. When a new input is detected (via the WaypointWrapper structure), a corresponding function is executed.", 
            "title": "Path Management"
        }, 
        {
            "location": "/picpilot/path-management/#path-management", 
            "text": "Path management can be broken up into 3 sections. The straight parts, the parts where you turn, and the way you put them together. There is not much more to it than that.", 
            "title": "Path Management"
        }, 
        {
            "location": "/picpilot/path-management/#straight-line-path-following", 
            "text": "Straight line path following, also known as, following a line, is the most rudimentary part of any unmanned system. It is mostly a mathematical construct applied to a digital system. The mathematics will be described here, which can be easily compared to the code.  The principle is simple. Given two points, and the location of your vehicle, determine what heading it should follow. Now imagine the plane is directly on the path. The heading would follow the line exactly. Now imagine the plane is slightly off the path. What should happen is that the plane should face slightly towards the path, to minimize its  cross-track error . Now imagine the plane is an infinite distance away. The plane should head at a heading perpendicular to the line, in order to regain distance. This is the premise of the straight line path following algorithm. As a result, a heading vector field would look as such:   The equations that govern this behaviour are not complicated. There are only a few things required to make this calculation. Firstly, you must know the heading of the path. If you have the XY coordinates of the path endpoints, you can easily determine that through simple trigonometry. If you only have the GPS coordinates, you should use the  Haversine Formula  in order to get the XY coordinates.  Once you have the coordinates, subtracting them will give you the direction of travel (in an XY plane). Furthermore, by applying the  arctan  function on the direction of travel, one will determine the path heading. In addition, the value should be between \u2013PI and +PI. Thus, any 2PI corrections that need to be made can be made at this point.  Now the path error (or cross-track error) is calculated. This is calculated as:  cos(courseAngle) * (positionY - targetWaypointY) \u2013 sin(courseAngle)*(positionX \u2013 targetWaypointX)  On a map, the _cross-track error _looks like this:   Using trigonometry you can easily derive the formula (as above) for cross-track error to encompass any situation.  The cross track error is then useful to determine the heading of the aircraft. Once again, using the  arctan  function is suitable to do so:   90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError))  Note, as the atan term increases, the heading approaches the  (courseAngle -__MAX_PATH_APPROACH_ANGLE) .  Note, that the courseAngle is calculated with respect to the x-axis, on the x-y plane. In other words, a path going from West to East would have a courseAngle of 0 degrees. This would be 90 degrees in terms of a true heading. Therefore, to get the true heading, you must subtract the  courseAngle  from 90 degrees.", 
            "title": "Straight Line Path Following"
        }, 
        {
            "location": "/picpilot/path-management/#orbit-following", 
            "text": "Unlike straight line path following, orbit following involves following a curve of a certain radius. An orbit is depicted by a radius, a center location, and the direction of travel (clockwise or anti-clockwise).   In order to maintain a certain radius, the Euclidean distance needs to be calculated between the center of the orbit and the plane itself. The goal of this function is to maintain this Euclidean distance constant. The Euclidean distance can be calculated as such:  float orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));  This value is then used to determine the equivalent of  cross-track _error, but for an orbit. This is done very easily. The term _d  (Euclidean distance) subtracted by the  \u03c1  (desired radius) provides the relative error, which must be minimized.   90 - rad2deg(courseAngle + direction \\* (PI/2 + atan(k\\_gain[ORBIT] \\* (orbitDistance - radius)/radius)))  This equation is actually very similar to the equation governing straight line path following. The  arctan  function forces the heading to converge onto the orbit. The direction of travel ( \u03bb ) which can be either  1  or  -1 , reverses the effect of the heading perturbations. This is then added onto the course angle as a perturbation. Once again, a gain value needs to be tuned to determine the rate of convergence.  The course angle can be determined easily based on the location of the curve. For instance, if the vehicle is in the first quadrant of the circle/orbit, the heading will range between 270\u00b0 and 0\u00b0, assuming a counter-clockwise rotation. This course angle can be calculated using this equation:  float courseAngle = atan2(position[1] - center[1], position[0] - center[0]);", 
            "title": "Orbit Following"
        }, 
        {
            "location": "/picpilot/path-management/#putting-it-all-together", 
            "text": "The orbit following and straight path following algorithms are used in combination in order to assemble a path. Both algorithms alternate in usage. Every corner uses the orbit following algorithm. Every straight line uses the straight path following algorithm.  In order to put the two together, you must draw in orbits between each set of points. The additional restriction is that they must be tangent to both lines, as depicted in this diagram:   Figuring out where the tangent will touch requires some basic trigonometry. The derivation won't be explained here, however, the coordinates at which this occurs can be calculated using:   Where nextX/Y/Z refer to the coordinates of the point Wi+1 and targetX/Y/Z refer to the coordinates of the point Wi.  The turning angle can be calculated via the following equation:  float turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));  This is simply the dot product of the (Wi - Wi-1) vector and the (Wi+1 - Wi) vector. Given the dot product formula, you can use the  arccos  function to determine the angle between the two lines.  At these calculated points, there is a checkpoint. Imagine a giant plane perpendicular to the path. As soon as the plane crosses this boundary, the next step is executed. For instance, if the vehicle is travelling straight along a path, then passes the plane, it will initiate a turn (orbiting algorithm). Once it passes the next plane, it will initiate the straight line path following algorithm once again.  In order to detect if a vehicle passes the boundary, the dot product of two vectors must be taken. If the value is positive, it is an indicator that the vehicle has crossed the boundary.  The dot product is:   Both vectors have X, Y, and Z components. Likewise, equations that depict the half plane are stated above.  Note that in the code, all \"direction vectors\" such as Wi \u2013 Wi-1 are normalized.  For every pair of \"checkpoints\" the path index is incremented once they are passed. The index is used to identify the data in a linked list through the wireless communications.", 
            "title": "Putting it all together"
        }, 
        {
            "location": "/picpilot/path-management/#managing-path-data", 
            "text": "Path data is stored in a structure, which contains all necessary information for a single path (line) segment. The construct looks as follows:  typedef struct _PathData{\n\n    struct _PathData* next;\n\n    struct _PathData* previous;\n\n    long double longitude;  //TODO: Longitude and Latitude is bulky. Use cartesian 2D approximations\n\n    long double latitude;\n\n    float altitude;\n\n    float radius; //Radius of turn\n\n    char id;    //Array ID\n\n    char index;\n\n} PathData;  This structure is a doubly linked list element. It links to the previous node and the next node. This makes it easy to traverse from one element to another. As a result, it is easy to add, insert, delete, and clear all waypoint nodes.  The included functions are:  PathData* initializePathNode(void);\n\nunsigned int destroyPathNode(PathData* node);\n\nPathData* initializePathNodeAndNext(void);\n\nunsigned int appendPathNode(PathData* node);\n\nunsigned int removePathNode(unsigned int ID);\n\nvoid clearPathNodes(void);\n\nunsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID);  These functions are all executed in the _checkAMData() _function. This function polls input over the DMA/SPI bus. When a new input is detected (via the WaypointWrapper structure), a corresponding function is executed.", 
            "title": "Managing Path Data"
        }, 
        {
            "location": "/picpilot/resources/", 
            "text": "Additional Readings and Resources\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help", 
            "title": "Resources"
        }, 
        {
            "location": "/picpilot/resources/#additional-readings-and-resources", 
            "text": "Information on Model Aircraft  General Aerodynamic Principles  Git Help", 
            "title": "Additional Readings and Resources"
        }, 
        {
            "location": "/picpilot/faq/", 
            "text": "FAQ\n\n\nNo questions here yet.", 
            "title": "FAQ"
        }, 
        {
            "location": "/picpilot/faq/#faq", 
            "text": "No questions here yet.", 
            "title": "FAQ"
        }, 
        {
            "location": "/computervision/", 
            "text": "Welcome to the Computer Vision Docs!", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/computervision/#welcome-to-the-computer-vision-docs", 
            "text": "", 
            "title": "Welcome to the Computer Vision Docs!"
        }, 
        {
            "location": "/bootcamp/mechanical/", 
            "text": "WARG Mechanical Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nMake justified mechanical design decisions based on project constraints and criteria\n\n\nLearn to take accurate measurements of parts using vernier callipers\n\n\nLearn CAD design in SolidWorks\n\n\nLearn how to make assemblies in SolidWorks\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Two-Axis Camera Gimbal:\n\n\nBackground\n\n\nA camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.\n\n\nTask\n\n\nYou are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of \nmm and g\n. If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed \npart files and assembly file\n to a Team Lead for evaluation.\n\n\nProject Checklist\n\n\n\n\nParts made in SolidWorks using dimensions of mm and g\n\n\nGoPro Case measured with power button exposed\n\n\nMounting method using 4 M4 bolts to the flat board\n\n\nMotors / Servos selected and modeled (if required)\n\n\nAssembly created with the gimbal able to rotate 360 degrees in both axis\n\n\n\n\nUsing Solidworks\n\n\nThere are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Mechanical"
        }, 
        {
            "location": "/bootcamp/mechanical/#warg-mechanical-bootcamp", 
            "text": "", 
            "title": "WARG Mechanical Bootcamp"
        }, 
        {
            "location": "/bootcamp/mechanical/#introduction", 
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.", 
            "title": "Introduction"
        }, 
        {
            "location": "/bootcamp/mechanical/#bootcamp-objectives", 
            "text": "Make justified mechanical design decisions based on project constraints and criteria  Learn to take accurate measurements of parts using vernier callipers  Learn CAD design in SolidWorks  Learn how to make assemblies in SolidWorks", 
            "title": "Bootcamp Objectives"
        }, 
        {
            "location": "/bootcamp/mechanical/#bootcamp-outline", 
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.", 
            "title": "Bootcamp Outline"
        }, 
        {
            "location": "/bootcamp/mechanical/#1-two-axis-camera-gimbal", 
            "text": "Background  A camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.  Task  You are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of  mm and g . If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed  part files and assembly file  to a Team Lead for evaluation.  Project Checklist   Parts made in SolidWorks using dimensions of mm and g  GoPro Case measured with power button exposed  Mounting method using 4 M4 bolts to the flat board  Motors / Servos selected and modeled (if required)  Assembly created with the gimbal able to rotate 360 degrees in both axis   Using Solidworks  There are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.", 
            "title": "1. Two-Axis Camera Gimbal:"
        }, 
        {
            "location": "/bootcamp/mechanical/#2-previous-team-contribution", 
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.", 
            "title": "2. Previous Team Contribution"
        }, 
        {
            "location": "/bootcamp/mechanical/#completion-of-bootcamp", 
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.", 
            "title": "Completion of Bootcamp"
        }, 
        {
            "location": "/tutorials/git/", 
            "text": "Git and Github Tutorial\n\n\nThis page is still a work in progress. Please check back later.", 
            "title": "Git and Github"
        }, 
        {
            "location": "/tutorials/git/#git-and-github-tutorial", 
            "text": "This page is still a work in progress. Please check back later.", 
            "title": "Git and Github Tutorial"
        }
    ]
}